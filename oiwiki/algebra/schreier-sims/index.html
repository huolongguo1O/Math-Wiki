
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Enter-tainer, iamtwz, Ir1d, isdanni, ksyx, StudyingFather, Tiphereth-A, Xeonacid, c-forrest">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Schreier sims - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Schreier sims
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../number-theory/basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../am-gm.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        引入
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        概述
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      
        稳定化子链
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      
        基和强生成集
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
        数据结构
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
        应用
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      
        群的阶数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      
        成员判定
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      
        轨道、陪集代表系和稳定化子的计算
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="轨道、陪集代表系和稳定化子的计算">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      
        轨道和陪集代表系的存储
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="轨道和陪集代表系的存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      
        直接存储
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schreier" class="md-nav__link">
    <span class="md-ellipsis">
      
        Schreier 树
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schreier_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Schreier 引理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      
        算法
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#schreiersims" class="md-nav__link">
    <span class="md-ellipsis">
      
        Schreier–Sims 算法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Schreier–Sims 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛选
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      
        过程
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      
        另一种实现
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      
        复杂度
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      
        习题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Schreier sims</h1>

<p>前置知识：<a href="../basic/">抽象代数基本概念</a>、<a href="../group-theory/">群论</a>、<a href="../../permutation/">置换与排列</a></p>
<h2 id="_1">引入</h2>
<p><strong>Schreier–Sims 算法</strong> 是计算群论（computational group theory）的一种算法，以数学家 Otto Schreier 和 Charles Sims 的名字命名。该算法能够在多项式时间内解决诸如找到有限置换群的阶数、查看给定置换是否包含在所给群中等许多问题。Schreier–Sims 算法最早由 Sims 在 1970 年基于 Schreier 引理引入。在 1981 年[^knuth-year]，Donald Knuth 进一步改进了该算法的运行时间。后来，该算法又发展出来一种更快的随机化版本。计算机代数系统（例如 GAP 和 Magma）通常使用该算法的高度优化过的 Monte Carlo 版本[^monte-carlo]。</p>
<p>???+ info "记号"
    本文依照计算群论文献的惯例，将群作用记作右作用，这意味着置换的复合由左向右进行。本文涉及的群作用都可以视为置换作用，尽管部分算法对于更广泛的群作用也成立。相应地，群作用的集合默认为 <span class="arithmatex">\(X=\{1,2,\cdots,n\}\)</span>，其中的元素则称为点。置换 <span class="arithmatex">\(g\)</span> 作用在点 <span class="arithmatex">\(x\)</span> 上得到的结果记作 <span class="arithmatex">\(x^g\)</span>，有时也称置换 <span class="arithmatex">\(g\)</span> 将点 <span class="arithmatex">\(x\)</span> 移动到点 <span class="arithmatex">\(x^g\)</span>。最后，置换群 <span class="arithmatex">\(G\)</span> 作用下，点 <span class="arithmatex">\(x\)</span> 的轨道记作 <span class="arithmatex">\(x^G=\{x^g:g\in G\}\)</span>，它的稳定化子则记作 <span class="arithmatex">\(G_x=\{g\in G:x^g=x\}\)</span>。稳定化子的概念还可以推广到集合 <span class="arithmatex">\(B\subseteq X\)</span>，它的稳定化子定义为 <span class="arithmatex">\(G_B=\bigcap_{x\in B}G_x\)</span>。</p>
<h2 id="_2">概述</h2>
<p>Schreier–Sims 算法主要试图解决这样一个问题：</p>
<ul>
<li>给定大小为 <span class="arithmatex">\(n\)</span> 的集合 <span class="arithmatex">\(X\)</span> 上的一些置换组成的集合 <span class="arithmatex">\(S\)</span>，如何在计算机中高效地存储由 <span class="arithmatex">\(S\)</span> 生成的置换群 <span class="arithmatex">\(G=\langle S\rangle\)</span>，并完成一系列对该群的查询任务？</li>
</ul>
<p>显然，这样的群 <span class="arithmatex">\(G\)</span> 的规模可能很大，且远远大于集合 <span class="arithmatex">\(X\)</span> 和生成集 <span class="arithmatex">\(S\)</span> 的规模。比如，<span class="arithmatex">\(n\)</span> 次对称群 <span class="arithmatex">\(S_n=\langle(123\cdots n),(12)\rangle\)</span> 的大小为 <span class="arithmatex">\(n!\)</span>，但是它可以仅由两个置换生成。存储群中的每一个元素是不现实的。</p>
<p>类似于利用 <a href="../../numerical/gauss/">Gauss 消元法</a> 构建出向量空间的一组 <a href="../../linear-algebra/basis/">线性基</a>，Schreier–Sims 算法的思路是找到有限置换群 <span class="arithmatex">\(G\)</span> 的一组「基」：</p>
<ol>
<li>算法的输入是 <span class="arithmatex">\(G\)</span> 的一个生成集 <span class="arithmatex">\(S\)</span>，其中有若干个置换；</li>
<li>如果群 <span class="arithmatex">\(G\)</span> 不平凡，总能找到在群 <span class="arithmatex">\(G\)</span> 作用下位置会发生变化的点 <span class="arithmatex">\(\beta\)</span>，即 <span class="arithmatex">\(|\beta^G|&gt;1\)</span>；</li>
<li>找到点 <span class="arithmatex">\(\beta\)</span> 的轨道 <span class="arithmatex">\(\Delta=\beta^{G}\)</span>，并对轨道中的每个点 <span class="arithmatex">\(\delta\in\Delta\)</span>，都找到群 <span class="arithmatex">\(G\)</span> 中一个置换 <span class="arithmatex">\(t_{\delta}\)</span>，它能够将点 <span class="arithmatex">\(\beta\)</span> 移动到 <span class="arithmatex">\(\delta\)</span>；</li>
<li>找到点 <span class="arithmatex">\(\beta\)</span> 的稳定化子 <span class="arithmatex">\(G_{\beta}\)</span> 的一个生成集 <span class="arithmatex">\(S'\)</span>；</li>
<li>递归地对 <span class="arithmatex">\(G'=\langle S'\rangle\)</span> 调用该算法，直到得到平凡的群 <span class="arithmatex">\(\{e\}\)</span>。</li>
</ol>
<p>这个思路的合理性在于，点 <span class="arithmatex">\(\beta\)</span> 的稳定化子 <span class="arithmatex">\(G_{\beta}\)</span> 是群 <span class="arithmatex">\(G\)</span> 的子群，它的全体（右）陪集构成群 <span class="arithmatex">\(G\)</span> 的分划，且这些陪集和点 <span class="arithmatex">\(\beta\)</span> 的轨道 <span class="arithmatex">\(\beta^G\)</span> 一一对应，步骤 3 中求得的那些置换 <span class="arithmatex">\(t_{\delta}\)</span> 就是这些陪集的代表元。这个陪集代表元的集合 <span class="arithmatex">\(T\)</span> 称为稳定化子 <span class="arithmatex">\(G_{\beta}\)</span> 的 <strong>陪集代表系</strong>（transversal）。换句话说，群 <span class="arithmatex">\(G\)</span> 中的每个元素 <span class="arithmatex">\(g\)</span> 都和唯一的一对元素 <span class="arithmatex">\((h,t)\in G_\beta\times T\)</span> 对应，且 <span class="arithmatex">\(g=ht\)</span>。因而，只要能想办法存储子群 <span class="arithmatex">\(G_{\beta}\)</span> 和相应的陪集代表系 <span class="arithmatex">\(T\)</span>，就可以存储整个群 <span class="arithmatex">\(G\)</span>。然而，存储子群 <span class="arithmatex">\(G_{\beta}\)</span> 的问题也已经解决了——只要递归调用算法即可。</p>
<p>当然，算法的实现还有很多细节需要梳理，这是本文的主要内容。但是在那之前，首先要考察调用该算法之后得到的结果，看看算法将群存储为怎样的结构，能够解决怎样的查询问题。为此，应当明晰一些概念。</p>
<h3 id="_3">稳定化子链</h3>
<p>假设对群 <span class="arithmatex">\(G=\{S\}\)</span> 调用该算法，共进行了 <span class="arithmatex">\(k\)</span> 次；且在第 <span class="arithmatex">\(i\)</span> 次调用该算法时，输入是置换的集合 <span class="arithmatex">\(S^{(i-1)}\)</span>，找到的点是 <span class="arithmatex">\(\beta_i\)</span>，得到的陪集代表系是 <span class="arithmatex">\(T_i\)</span>，得到的稳定化子的生成集是 <span class="arithmatex">\(S^{(i)}\)</span>。如果记 <span class="arithmatex">\(G^{(i)}=\langle S^{(i)}\rangle\)</span>。那么，算法实际上得到了子群链</p>
<div class="arithmatex">\[
G=G^{(0)}&gt; G^{(1)}&gt;\cdots&gt; G^{(k-1)}&gt; G^{(k)}=\{e\}.
\]</div>
<p>而且，每一个链中的子群都是一个稳定化子</p>
<div class="arithmatex">\[
G^{(i)}=G_{\beta_1,\cdots,\beta_i}.
\]</div>
<p>因而，Schreier–Sims 算法可以看作就是在计算这样一个 <strong>稳定化子链</strong>（stabilizer chain）。</p>
<h3 id="_4">基和强生成集</h3>
<p>如果集合 <span class="arithmatex">\(X\)</span> 的子集 <span class="arithmatex">\(B\)</span> 满足 <span class="arithmatex">\(G_B=\{e\}\)</span>，就称 <span class="arithmatex">\(B\)</span> 是置换群 <span class="arithmatex">\(G\)</span> 的一组 <strong>基</strong>（base）。显然，上述算法得到了一组基 <span class="arithmatex">\(B=\{\beta_1,\cdots,\beta_k\}\)</span>。这意味着，置换 <span class="arithmatex">\(g\in G\)</span> 对这些点作用的结果在群 <span class="arithmatex">\(G\)</span> 中唯一地确定了这个置换。而且，算法输出的这个基还满足条件</p>
<div class="arithmatex">\[
G^{(i-1)}=G_{\beta_1,\cdots,\beta_{i-1}}&gt;G_{\beta_1,\cdots,\beta_{i-1},\beta_i}=G^{(i)}.
\]</div>
<p>这就是说，基中的每个点都蕴含着关于群中的元素的有效信息。这样的基称为 <strong>无冗余的</strong>（nonredundant）。算法总是输出无冗余的基。这样的基对应的稳定化子链是严格递降的。</p>
<p>同时，算法得到的生成集的并集</p>
<div class="arithmatex">\[
\bar S=\bigcup_{i=0}^kS_i
\]</div>
<p>也是群 <span class="arithmatex">\(G\)</span> 的生成集，且成立 <span class="arithmatex">\(\langle\bar S\cap G^{(i)}\rangle = G^{(i)}\)</span>。满足这个条件的生成集称为群 <span class="arithmatex">\(G\)</span> 相对于基 <span class="arithmatex">\(B\)</span> 的 <strong>强生成集</strong>（strong generating set）。因而，Schreier–Sims 算法也可以看作是在计算群 <span class="arithmatex">\(G\)</span> 的 <strong>基和强生成集</strong>（base and strong generating set, BSGS）。这个说法和稳定化子链的说法是等价的，本文不加以区分。</p>
<p>当然，算法还得到了一系列轨道 <span class="arithmatex">\(\Delta_i=\beta_{i}^{G^{(i-1)}}\)</span> 和相应的陪集代表系 <span class="arithmatex">\(T_i\)</span>。这些轨道称为群 <span class="arithmatex">\(G\)</span> 的 <strong>基础轨道</strong>（fundamental orbits）。当本文提及群 <span class="arithmatex">\(G\)</span> 的稳定化子链或者基和强生成集时，总是默认相应的基础轨道和陪集代表系都已经一并求出。</p>
<h3 id="_5">数据结构</h3>
<p>本文会提供一系列伪代码。伪代码中，群的稳定化子链（或基和强生成集）存储在数据结构 <span class="arithmatex">\(C\)</span> 中：</p>
<div class="arithmatex">\[
C=(S,\Delta,T,C').
\]</div>
<p>这个结构中的数据成员分别是当前群的生成集 <span class="arithmatex">\(S\)</span>、基础轨道 <span class="arithmatex">\(\Delta\)</span>、相应的陪集代表系 <span class="arithmatex">\(T\)</span> 和存储为嵌套子结构的稳定化子 <span class="arithmatex">\(C'\)</span>。当然，稳定化子 <span class="arithmatex">\(C'\)</span> 也是这样的一个结构。整个群实际存储在一个层状结构中，每层都描述了稳定化子链中的一个群。最内层是空的结构体，表示 <span class="arithmatex">\(G^{(k)}=\{e\}\)</span>。</p>
<p>在伪代码中，该数据结构中的成员可以分别由 <span class="arithmatex">\(C.generators\)</span>、<span class="arithmatex">\(C.orbit\)</span>、<span class="arithmatex">\(C.transversal\)</span> 和 <span class="arithmatex">\(C.next\)</span> 访问。轨道的首个元素 <span class="arithmatex">\(C.orbit[0]\)</span> 默认是基中的点 <span class="arithmatex">\(\beta\)</span>，而相应的陪集代表元 <span class="arithmatex">\(C.transversal[\beta]\)</span> 默认是恒等变换 <span class="arithmatex">\(e\)</span>。注意，虽然此处用数组下标访问了轨道和陪集代表系中的元素，但是它们未必存储为数组，而应当理解为它们提供了访问轨道首元素和根据轨道中的点查询相应的陪集代表元的方法。下文会讨论具体的实现细节。</p>
<h3 id="_6">应用</h3>
<p>在获得群的基和强生成集后，能够解决一系列关于群的查询问题。其中，最基础的，也是算法竞赛中最常遇到的，是查询群的阶数和查询某个置换是否属于给定群的问题。</p>
<h4 id="_7">群的阶数</h4>
<p>如果已知群 <span class="arithmatex">\(G\)</span> 的基和强生成集，那么应用 Lagrange 定理和轨道稳定化子定理可知，群 <span class="arithmatex">\(G\)</span> 的阶数可以计算为</p>
<div class="arithmatex">\[
|G|=\prod_{i=1}^k[G^{(i-1)}:G^{(i)}]=\prod_{i=1}^k[G^{(i-1)}:G^{(i-1)}_{\beta_i}]=\prod_{i=1}^k|T_i|.
\]</div>
<p>所以，只要将所有陪集代表系 <span class="arithmatex">\(T_i\)</span> 的大小（或者等价地，基础轨道 <span class="arithmatex">\(\Delta_i\)</span> 的长度）乘起来就可以得到群 <span class="arithmatex">\(G\)</span> 的阶数。</p>
<h4 id="_8">成员判定</h4>
<p>已知群 <span class="arithmatex">\(G\)</span> 的基和强生成集，也可以判定某个置换 <span class="arithmatex">\(h\)</span> 是否属于群 <span class="arithmatex">\(G\)</span>。这称为 <strong>成员判定</strong>（membership testing）问题。</p>
<p>这个问题可以递归地解决。要判定 <span class="arithmatex">\(h\in G^{(i-1)}\)</span>，首先要找到 <span class="arithmatex">\(G^{(i)}\)</span> 的包含 <span class="arithmatex">\(h\)</span> 的陪集的代表元 <span class="arithmatex">\(t\in T_i\)</span>。如果能够找到，那么设 <span class="arithmatex">\(h'=ht^{-1}\)</span>，就有 <span class="arithmatex">\(h=h't\)</span> 且 <span class="arithmatex">\(h\in G^{(i-1)}\)</span> 等价于 <span class="arithmatex">\(h'\in G^{(i)}\)</span>；问题就转化为判定 <span class="arithmatex">\(h'\in G^{(i)}\)</span>。如果找不到这样的 <span class="arithmatex">\(t\)</span>，或者已经递归到了 <span class="arithmatex">\(G^{(k)}=\{e\}\)</span> 但是 <span class="arithmatex">\(h\neq e\)</span>，就可以得出结论，<span class="arithmatex">\(h\notin G\)</span>。其实，这个过程不仅判定了 <span class="arithmatex">\(h\in G\)</span>，而且在 <span class="arithmatex">\(h\in G\)</span> 的情形下，还能够将 <span class="arithmatex">\(h\)</span> 表示为一系列陪集代表元的乘积 <span class="arithmatex">\(t_k\cdots t_2t_1\)</span>，其中，<span class="arithmatex">\(t_i\in T_i\)</span>。对于群 <span class="arithmatex">\(G\)</span> 中的元素，这样的表示存在且唯一。这再次证明了上面关于群的阶数的公式是正确的。</p>
<p>现在将该过程写成如下伪代码：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{MembershipTest}(C,h):\\
\textbf{Input. }\textrm{A stabilizer chain }C\textrm{ for a group }G\textrm{ and a permutation }h.\\
\textbf{Output. }\textrm{Whether }h\in G.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \textbf{while }C\textrm{ is not empty }\\
2  &amp; \qquad \beta \leftarrow C.orbit[0]\\
3  &amp; \qquad \delta \leftarrow \beta^h\\
4  &amp; \qquad \textbf{if }\delta\in C.orbit\textbf{ then}\\
5  &amp; \qquad \qquad t \leftarrow C.transversal[\delta]\\
6  &amp; \qquad \qquad h \leftarrow ht^{-1}\\
7  &amp; \qquad \textbf{else }\\
8  &amp; \qquad \qquad \textbf{return }\textrm{false}\\
9  &amp; \qquad \textbf{end if}\\
10 &amp; \qquad C \leftarrow C.next\\
11 &amp; \textbf{end while}\\
12 &amp; \textbf{return }h=e
\end{array}
\end{array}
\]</div>
<p>下文会看到，成员判定问题也是本文所讨论的 Schreier–Sims 算法的实现中的一个重要组成部分。</p>
<h2 id="_9">轨道、陪集代表系和稳定化子的计算</h2>
<p>要实现 Schreier–Sims 算法，首先要解决如下子问题：<a href="这个问题以及本节的算法都并不需要假设所讨论的群作用是置换作用，因而可以应用于更广泛的场景。比如，如果将这些算法应用于共轭作用，同样可以求得轨道（共轭类）、陪集代表系和稳定化子（中心化子）。">^orbit-algo</a></p>
<ul>
<li>给定群 <span class="arithmatex">\(G\)</span> 的生成集 <span class="arithmatex">\(S\)</span> 和一个点 <span class="arithmatex">\(\beta\)</span>，如何求出轨道 <span class="arithmatex">\(\beta^G\)</span>、相应的陪集代表系 <span class="arithmatex">\(T\)</span> 和稳定化子 <span class="arithmatex">\(G_\beta\)</span> 的生成集？</li>
</ul>
<p>这就是本节要解决的问题。</p>
<h3 id="_10">轨道和陪集代表系的存储</h3>
<p>要求得轨道和陪集代表系，只要直接搜索就好了。伪代码如下：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{OrbitTransversal}(S,\beta):\\
\textbf{Input. }\textrm{A generating set }S\textrm{ for a group }G\textrm{ and a point }\beta.\\
\textbf{Output. }\textrm{The orbit }\Delta=\beta^G\textrm{ and the transversal }T.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \Delta \leftarrow [\beta]\\
2  &amp; T[\beta] \leftarrow e\\
3  &amp; \textbf{for }\delta\in\Delta\\
4  &amp; \qquad \textbf{for }s\in S\\
5  &amp; \qquad \qquad \gamma \leftarrow \delta^s\\
6  &amp; \qquad \qquad \textbf{if }\gamma\notin\Delta\textbf{ then}\\
7  &amp; \qquad \qquad \qquad\textrm{append }\gamma\textrm{ to }\Delta\\
8  &amp; \qquad \qquad \qquad T[\gamma] \leftarrow T[\delta]\cdot s\\
9  &amp; \qquad \qquad \textbf{end if}\\
10 &amp; \qquad \textbf{end for}\\
11 &amp; \textbf{end for}\\
12 &amp; \textbf{return }\Delta, T
\end{array}
\end{array}
\]</div>
<p>具体实现的时候，使用广度优先搜索和深度优先搜索都是可以的。搜索遍历到的状态数目是 <span class="arithmatex">\(|S||T|\)</span>，只要能合理地存储轨道和陪集代表系，时间复杂度是完全可以接受的。</p>
<p>由于在置换群的语境下，轨道无非是至多 <span class="arithmatex">\(n\)</span> 个点的集合，为了高效完成查找和添加操作，可以使用布尔值数组或是无序集合存储。这样两个操作的时间复杂度都是 <span class="arithmatex">\(O(1)\)</span> 的，整体的空间占用是 <span class="arithmatex">\(O(n)\)</span> 的。当然，取决于陪集代表系的实现，可能还需要额外标记首元素的位置。</p>
<p>问题在于使用什么样的数据结构存储相应的陪集代表系 <span class="arithmatex">\(T\)</span>。</p>
<h4 id="_11">直接存储</h4>
<p>最简单的方法，当然是直接存储陪集代表系 <span class="arithmatex">\(T\)</span> 中的每一个元素 <span class="arithmatex">\(t\)</span>。单个置换存储为 <a href="../../permutation/#单行记号">单行记号</a>，需要的空间恰为 <span class="arithmatex">\(n\)</span>，所以存储这样的陪集代表系的空间复杂度是 <span class="arithmatex">\(O(|T|n)\)</span> 的。这样做的好处是访问单个陪集代表元的时间复杂度是 <span class="arithmatex">\(O(1)\)</span> 的，代价是初次计算这些陪集代表元的时间复杂度是 <span class="arithmatex">\(O(|T|n)\)</span> 的。</p>
<h4 id="schreier">Schreier 树</h4>
<p>另外一种常见的做法是实现一个树形结构用于存储陪集代表系。它称为 <strong>Schreier 树</strong>（Schreier tree）或 <strong>Schreier 向量</strong>（Schreier vector）[^schreier-vector]。它以 <span class="arithmatex">\(\beta\)</span> 为根，以轨道 <span class="arithmatex">\(\Delta\)</span> 中的元素 <span class="arithmatex">\(\delta\)</span> 为顶点。每次在搜索过程中得到新的顶点 <span class="arithmatex">\(\gamma=\delta^s\)</span> 时，就从旧的顶点 <span class="arithmatex">\(\delta\)</span> 到新的顶点 <span class="arithmatex">\(\gamma\)</span> 连一条边，边上记录生成集 <span class="arithmatex">\(S\)</span> 中置换 <span class="arithmatex">\(s\)</span> 的序号（或指针）。因为已经存储了生成集，存储陪集代表系的额外空间复杂度是 <span class="arithmatex">\(O(|T|)\)</span> 的。对于 <span class="arithmatex">\(n\)</span> 的规模很大的情形，这样做可以有效地节约空间，而且初次计算的时候复杂度是 <span class="arithmatex">\(O(|T|)\)</span> 的。但是，副作用就是每次需要获得陪集代表元的时候，需要遍历顶点到根的路径上的边，重新计算陪集代表元，因而时间复杂度高度依赖于 Schreier 树的深度。对于一般的情形，树的深度可能达到 <span class="arithmatex">\(O(n)\)</span> 级别。</p>
<p>在具体实现的时候，需要根据实际情况权衡算法的时空复杂度。对于算法竞赛可能涉及的情形，<span class="arithmatex">\(n\)</span> 通常都不大，空间充足，而时间复杂度常常成为瓶颈。稍后会看到，Schreier–Sims 算法最耗时的步骤恰好需要多次访问陪集代表元，因而使用直接存储的方式往往更优。但是对于某些应用场景，<span class="arithmatex">\(n\)</span> 可能很大，存储空间可能更为紧张，就有可能需要使用 Schreier 树的方式存储陪集代表系。对于这种情况，为避免 Schreier 树深度过深，研究者提出了很多方法，可以在树的深度过深的时候重构出浅的 Schreier 树。有兴趣的读者可以参考文末的文献。</p>
<p>在伪代码中，本文不会区分具体的陪集代表系的实现，而只假设存储陪集代表系 <span class="arithmatex">\(T\)</span> 的数据结构实现了根据轨道元素 <span class="arithmatex">\(\delta\in\Delta\)</span> 访问和修改对应陪集代表元 <span class="arithmatex">\(T[\delta]\)</span> 的操作。</p>
<h3 id="schreier_1">Schreier 引理</h3>
<p>在获得了轨道 <span class="arithmatex">\(\beta^G\)</span> 和陪集代表系 <span class="arithmatex">\(T\)</span> 后，Schreier 引理继而提供了获得稳定化子 <span class="arithmatex">\(G_\beta\)</span> 的生成集的方法。</p>
<p>???+ note "Schreier 引理"
    设群 <span class="arithmatex">\(G=\langle S\rangle\)</span> 有子群 <span class="arithmatex">\(H\le G\)</span>。设 <span class="arithmatex">\(T\)</span> 是子群 <span class="arithmatex">\(H\)</span> 的（右）陪集代表系，且 <span class="arithmatex">\(e\in T\)</span>[^schreier-lemma-unity]，并记 <span class="arithmatex">\(g\in G\)</span> 所在陪集的代表元 <span class="arithmatex">\(t\in T\)</span> 为 <span class="arithmatex">\(\overline g\)</span>。那么，集合</p>
<pre><code>$$
U=\{ts(\overline{ts})^{-1}:t\in T,s\in S\}
$$

是子群 $H$ 的一个生成集。它的元素称为子群 $H$ 的 **Schreier 生成元**（Schreier generator）。
</code></pre>
<p>??? note "证明"
    首先，根据陪集代表元的定义可知，<span class="arithmatex">\(ts(\overline{ts})^{-1}\in H\)</span> 对所有 <span class="arithmatex">\(t\in T,s\in S\)</span> 都成立，故而 <span class="arithmatex">\(\langle U\rangle\subseteq H\)</span>。</p>
<pre><code>反过来，对于任何 $h\in H$，因为 $S$ 是 $G\ge H$ 的生成集，必然存在一列 $s_i\in S\cup S^{-1}$ 使得

$$
h=s_1s_2\cdots s_r
$$

成立。令 $t_1=e$，并递归地定义 $t_{i+1}=\overline{s_it_i}\in T$，于是，有

$$
\begin{aligned}
h&amp;=\left(t_1s_1t_2^{-1}\right)\left(t_2s_2t_3^{-1}\right)\cdots(t_rs_rt_{r+1})^{-1}t_{r+1}.
\end{aligned}
$$

而对于每个 $i=1,2,\cdots,r$ 都有 $t_is_it_{i+1}^{-1}=t_is_i(\overline{t_is_i})^{-1}\in U\cup U^{-1}\subseteq H$，故而有 $t_{r+1}\in H$。但是，$H\cap T=\{e\}$，所以有 $t_{r+1}=e$。这就说明，任意 $h\in H$ 都可以写作一列 $u_i=t_is_it_{i+1}^{-1}\in U\cup U^{-1}$ 的乘积，亦即 $U$ 生成 $H$。
</code></pre>
<p>因为陪集代表系 <span class="arithmatex">\(T\)</span> 对应的子群就是稳定化子 <span class="arithmatex">\(G_\beta\)</span>，所以求出陪集代表系 <span class="arithmatex">\(T\)</span> 后再结合群 <span class="arithmatex">\(G\)</span> 的生成集 <span class="arithmatex">\(S\)</span> 就能得到稳定化子 <span class="arithmatex">\(G_\beta\)</span> 的生成集。</p>
<h3 id="_12">算法</h3>
<p>只要对上面的伪代码稍作修改，就能在计算轨道和陪集代表系的同时得到相应的稳定化子的生成集：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{OrbitTransversalStabilizer}(S,\beta):\\
\textbf{Input. }\textrm{A generating set }S\textrm{ for a group }G\textrm{ and a point }\beta.\\
\textbf{Output. }\textrm{The orbit }\Delta=\beta^G\textrm{, the transversal }T\textrm{, and a}\\
\qquad\textrm{ generating set }S'\textrm{ for the stabilizer }G_\beta.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \Delta \leftarrow [\beta]\\
2  &amp; T[\beta] \leftarrow e\\
3  &amp; S' \leftarrow [e]\\
4  &amp; \textbf{for }\delta\in\Delta\\
5  &amp; \qquad \textbf{for }s\in S\\
6  &amp; \qquad \qquad \gamma \leftarrow \delta^s\\
7  &amp; \qquad \qquad \textbf{if }\gamma\notin\Delta\textbf{ then}\\
8  &amp; \qquad \qquad \qquad\textrm{append }\gamma\textrm{ to }\Delta\\
9  &amp; \qquad \qquad \qquad T[\gamma] \leftarrow T[\delta]\cdot s\\
10 &amp; \qquad \qquad \textbf{else} \\
11 &amp; \qquad \qquad \qquad \textrm{append }T[\delta]\cdot s\cdot T[\gamma]^{-1}\textrm{ to }S'\\
12 &amp; \qquad \qquad \textbf{end if}\\
13 &amp; \qquad \textbf{end for}\\
14 &amp; \textbf{end for}\\
15 &amp; \textbf{return }\Delta, T, S'
\end{array}
\end{array}
\]</div>
<p>伪代码中，对于每对 <span class="arithmatex">\((\delta,s)\)</span>，只有轨道中不产生新的元素时，<span class="arithmatex">\(t_\delta st_{\delta^s}^{-1}\)</span> 才是新的 Schreier 生成元；否则，它就是恒等变换 <span class="arithmatex">\(e\)</span>。因而，算法中实际生成的 Schreier 生成元（包括最初的恒等变换）最多只有</p>
<div class="arithmatex">\[
|S||T|-(|T|-1) = |S|(|T|-1)+1
\]</div>
<p>个。对于一般的情形，这个上界是紧的。[^upper-bound]但是，对于实际要处理的有限群，这个上界相当地宽松：这些新得到的 Schreier 生成元大多数并都是之前得到的生成元的重复，或者可以由之前的生成元复合而成。</p>
<p>因为 Schreier–Sims 算法的基本流程可以实现为递归地调用上述计算轨道和稳定化子的算法，所以其实此时就已经得到了 Schreier–Sims 算法的一种朴素实现。但是，如果不加以筛选，Schreier 生成元的规模的增长速度是指数级的：反复应用 <span class="arithmatex">\(O(|S_{i}|)=O(|S_{i-1}||T_i|)\)</span> 可知，最内层的稳定化子的生成集的规模将达到 <span class="arithmatex">\(O(|S||G|)\)</span>。这显然低效得荒诞，因为最内层的稳定化子是 <span class="arithmatex">\(\{e\}\)</span>。</p>
<p>Sims 的工作提供了限制 Schreier 生成元的规模的增长速度的方法，它能够保证最终得到的强生成集 <span class="arithmatex">\(\bar S\)</span> 的大小是 <span class="arithmatex">\(O(n^2)\)</span> 的。这样就可以在多项式时间内计算基和强生成集。</p>
<h2 id="schreiersims">Schreier–Sims 算法</h2>
<p>为解决上述问题，本节讨论 Schreier–Sims 算法的一种增量实现，它得到的强生成集的大小是 <span class="arithmatex">\(O(n^2)\)</span> 的。</p>
<h3 id="_13">筛选</h3>
<p>Schreier–Sims 算法对上述朴素算法的核心优化十分简明：它要求在向稳定化子的生成集添加任何 Schreier 生成元之前，都首先需要经过 <strong>筛选</strong>（sifting）。所谓筛选，就是首先判定新的 Schreier 生成元是否已经存在于已有的生成元生成的子群中，然后只添加那些尚不存在的生成元。为此，只需要使用前文的成员判定算法 <span class="arithmatex">\(\textrm{MembershipTest}(C,h)\)</span> 即可。</p>
<p>但是，能够这样做的前提是，基于当前群的已经产生了的 Schreier 生成元，早就构建好了它们生成的群的稳定化子链（或基和强生成集）。这意味着，每次向稳定化子的生成集中添加一个新的 Schreier 生成元，都需要动态地维护内层的稳定化子链，以用于之后的筛选。但是，当前层每插入一个生成元，可能会产生多个 Schreier 生成元，也就可能会多次更新内层结构；而内层结构的每次更新，都可能会引发更内层结构的多次更新。</p>
<p>似乎之前提到的指数级爆炸的问题依然存在。其实不然。因为提前做好了筛选，只有待添加的生成元真的会引发某一层结构的扩大的时候，该层结构才会更新。这说明，单层结构更新的次数实际上等于该层结构存储的群严格增长的次数。但是，大小为 <span class="arithmatex">\(|G|\)</span> 的群至多有长度为 <span class="arithmatex">\(\log|G|\)</span> 的子群链；因为 Lagrange 定理保证，子群链长度每增加一，群的大小至少要翻倍。这就说明，单层结构至多只会更新 <span class="arithmatex">\(\log|G|\)</span> 次，因而最后得到的强生成集 <span class="arithmatex">\(\bar S\)</span> 的大小就是 <span class="arithmatex">\(|B|\log|G|\)</span> 的。</p>
<p>这个估计还可以进一步改进。因为此处出现的群 <span class="arithmatex">\(G\)</span> 已知是 <span class="arithmatex">\(n\)</span> 次对称群 <span class="arithmatex">\(S_n\)</span> 的子群，所以 <span class="arithmatex">\(G\)</span> 的子群链长度不会超过 <span class="arithmatex">\(S_n\)</span> 的子群链长度。可以证明[^subgroup-chain]，<span class="arithmatex">\(S_n\)</span> 的严格递增子群链长度不会超过 <span class="arithmatex">\(3n/2\)</span>。这说明，单层结构更新的次数其实是 <span class="arithmatex">\(O(n)\)</span> 的。显然，基的大小也不超过 <span class="arithmatex">\(n\)</span>。故而，最后得到的强生成集 <span class="arithmatex">\(\bar S\)</span> 的大小就是 <span class="arithmatex">\(O(n^2)\)</span> 的。</p>
<p>此处提到的筛选方法是 Sims 提出的，也称为 Sims 筛（Sims filter）。还有一种更为复杂的筛选方法，是由 Jerrum 提出的，也称为 <a href="https://groupprops.subwiki.org/w/index.php?title=Jerrum%27s_filter">Jerrum 筛</a>（Jerrum filter），它能够保证得到的强生成集的大小是 <span class="arithmatex">\(O(n)\)</span> 的。有兴趣的读者可以自行学习。</p>
<p>对于筛选过程，有一个小优化是，在 <span class="arithmatex">\(\textrm{MembershipTest}(C,h)\)</span> 的实现中，并不输出布尔值，而是输出最后得到的「筛渣」[^siftee]<span class="arithmatex">\(h\)</span>（即用 <span class="arithmatex">\(\textbf{return }h\)</span> 代替伪代码中的第 <span class="arithmatex">\(10\)</span> 和第 <span class="arithmatex">\(14\)</span> 行）。如果「筛渣」<span class="arithmatex">\(h\neq e\)</span>，就说明成员判定失败，此时可以直接将「筛渣」<span class="arithmatex">\(h\)</span> 而不是原来的 <span class="arithmatex">\(h\)</span> 添加到当前层。此处的「筛渣」<span class="arithmatex">\(h\)</span> 已经除去了若干个陪集代表元的因子，因而移动了更少的元素，所以会减少局部的计算量。这个优化对于整体的复杂度没有任何影响。</p>
<h3 id="_14">过程</h3>
<p>现在可以描述 Schreier–Sims 算法的具体过程：首先，初始化一个空结构 <span class="arithmatex">\(C\)</span>，用于存储群的稳定化子链。然后，逐个向结构 <span class="arithmatex">\(C\)</span> 中添加生成集 <span class="arithmatex">\(S\)</span> 中的生成元，最后得到的结构 <span class="arithmatex">\(C\)</span> 就是群 <span class="arithmatex">\(\langle S\rangle\)</span> 的稳定化子链。伪代码如下：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{SchreierSims}(S):\\
\textbf{Input. }\textrm{A generating set }S\textrm{ for a group }G.\\
\textbf{Output. }\textrm{The stabilizer chain }C\textrm{ for the group }G.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; C \leftarrow []\\
2  &amp; \textbf{for }s\in S\\
3  &amp; \qquad C \leftarrow \textrm{Extend}(C,s)\\
4  &amp; \textbf{end for}\\
5  &amp; \textbf{return }C
\end{array}
\end{array}
\]</div>
<p>算法的核心在于向当前的 <span class="arithmatex">\(C\)</span> 中添加新的生成元 <span class="arithmatex">\(s\)</span> 这一步，即子程序 <span class="arithmatex">\(\textrm{Extend}(C,s)\)</span>。正如前文所述，添加置换 <span class="arithmatex">\(s\)</span> 之前和之后，都需要保证 <span class="arithmatex">\(C\)</span> 是稳定化子链。这样，在添加置换 <span class="arithmatex">\(s\)</span> 之前，可以首先做筛选。如果发现 <span class="arithmatex">\(s\)</span> 不在已有的群中，就 <strong>增量地</strong> 计算轨道、陪集代表元和 Schreier 生成元。此处的「增量」的含义是，已经计算过的，不要重复计算。这样才能保证正确的复杂度。</p>
<p>考虑如何将 <span class="arithmatex">\(\textrm{OrbitTransversalStabilizer}(S,\beta)\)</span> 改造为增量版本。算法搜索的状态空间是 <span class="arithmatex">\(\Delta\times S\)</span>。在添加新的生成元 <span class="arithmatex">\(s\)</span> 之后，状态空间将变成 <span class="arithmatex">\(\Delta'\times\left(S\cup\{s\}\right)\)</span>。两者的差集就是</p>
<div class="arithmatex">\[
\left(\Delta\times\{s\}\right)\cup\left((\Delta'\setminus\Delta)\times \left(S\cup\{s\}\right)\right).
\]</div>
<p>这意味着，当加入新的生成元 <span class="arithmatex">\(s\)</span> 的时候，首先需要计算新的生成元 <span class="arithmatex">\(s\)</span> 与旧的轨道和相应的陪集代表元的组合；如果在这个过程中还得到了新的轨道的元素，就再考虑这些元素与所有生成元（无论新旧）的组合；过程重复到轨道不再延长为止。</p>
<p>向结构 <span class="arithmatex">\(C\)</span> 中添加置换 <span class="arithmatex">\(g\)</span> 的伪代码如下：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{Extend}(C,g):\\
\textbf{Input. }\textrm{A stabilizer chain }C\textrm{ for the group generated by }S\textrm{ and a}\\
\qquad \textrm{permutation }g.\\
\textbf{Output. }\textrm{A stabilizer chain }C\textrm{ for the group generated by }S\cup\{g\}.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \textbf{if }\textrm{MembershipTest}(C,g)\textrm{ is passed}\textbf{ then}\\
2  &amp; \qquad \textbf{return }C\\
3  &amp; \textbf{end if}\\
4  &amp; \textbf{if }C\textrm{ is empty}\textbf{ then}\\
5  &amp; \qquad \beta \leftarrow \textrm{an element moved by }g\\
6  &amp; \qquad C.orbit[0] \leftarrow \beta \\
7  &amp; \qquad C.transversal[\beta] \leftarrow e\\
8  &amp; \textbf{end if}\\
9  &amp; \textrm{append }g\textrm{ to }C.generators\\
10  &amp; \Delta \leftarrow C.orbit \\
11 &amp; \textbf{for }\delta\in\Delta \\
12 &amp; \qquad \gamma \leftarrow \delta^g \\
13 &amp; \qquad \textbf{if }\gamma\notin C.orbit\textbf{ then}\\
14 &amp; \qquad \qquad \textrm{append }\gamma\textrm{ to }C.orbit\\
15 &amp; \qquad \qquad C.transversal[\gamma] \leftarrow C.transversal[\delta]\cdot g\\
16 &amp; \qquad \textbf{else}\\
17 &amp; \qquad \qquad s'\leftarrow C.transversal[\delta]\cdot g\cdot C.transversal[\gamma]^{-1}\\
18 &amp; \qquad \qquad C.next \leftarrow \textrm{Extend}(C.next, s')\\
19 &amp; \qquad \textbf{end if}\\
20 &amp; \textbf{end for} \\
21 &amp; \textbf{for }\delta\in C.orbit\setminus\Delta \\ 
22 &amp; \qquad \textbf{for }s\in C.generators \\
23 &amp; \qquad \qquad \gamma \leftarrow \delta^s \\
24 &amp; \qquad \qquad \textbf{if }\gamma\notin C.orbit\textbf{ then}\\
25 &amp; \qquad \qquad \qquad \textrm{append }\gamma\textrm{ to }C.orbit\\
26 &amp; \qquad \qquad \qquad C.transversal[\gamma] \leftarrow C.transversal[\delta]\cdot s\\
27 &amp; \qquad \qquad \textbf{else}\\
28 &amp; \qquad \qquad \qquad s'\leftarrow C.transversal[\delta]\cdot s\cdot C.transversal[\gamma]^{-1}\\
29 &amp; \qquad \qquad \qquad \textrm{Extend}(C.next, s')\\
30 &amp; \qquad \qquad \textbf{end if}\\
31 &amp; \qquad \textbf{end for}\\
32 &amp; \textbf{end for} \\
33 &amp; \textbf{return }C
\end{array}
\end{array}
\]</div>
<p>这样就得到了完整的 Schreier–Sims 算法。</p>
<h3 id="_15">另一种实现</h3>
<p>上述的实现已经是正确的，但是 <span class="arithmatex">\(12\sim 19\)</span> 行和 <span class="arithmatex">\(23\sim 30\)</span> 行略显重复。基于此，Knuth 在论文中提出了一种递归实现，更为简明。他的做法是，将这个重复的部分视作是对陪集剩余系（和轨道）的更新。每次更新陪集剩余系都要和所有的生成元组合，根据是否产生了新的陪集代表元，决定是递归地调用自身还是添加生成元的程序。伪代码如下：</p>
<div class="arithmatex">\[
\begin{array}{l}
\textbf{Algorithm }\textrm{Extend}(C,g):\\
\textbf{Input. }\textrm{A stabilizer chain }C\textrm{ for the group generated by }S\textrm{ and a}\\
\qquad \textrm{permutation }g.\\
\textbf{Output. }\textrm{A stabilizer chain }C\textrm{ for the group generated by }S\cup\{g\}.\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \textbf{if }\textrm{MembershipTest}(C,g)\textrm{ is passed}\textbf{ then}\\
2  &amp; \qquad \textbf{return }C\\
3  &amp; \textbf{end if}\\
4  &amp; \textbf{if }C\textrm{ is empty}\textbf{ then}\\
5  &amp; \qquad \beta \leftarrow \textrm{an element moved by }g\\
6  &amp; \qquad C.orbit[0] \leftarrow \beta \\
7  &amp; \qquad C.transversal[\beta] \leftarrow e\\
8  &amp; \textbf{end if}\\
9  &amp; \textrm{append }g\textrm{ to }C.generators\\
10 &amp; \textbf{for }t\in C.transversal\\
11 &amp; \qquad \textrm{ExtendTranserversal}(C,t\cdot g)\\
12 &amp; \textbf{end for}\\
13 &amp; \textbf{return }C
\end{array}\\
\\
\textbf{Sub-Algorithm }\textrm{ExtendTranserversal}(C,t):\\
\textbf{Method.}\\
\begin{array}{ll}
1  &amp; \beta \leftarrow C.orbit[0]\\
2  &amp; \gamma \leftarrow \beta^t\\
3  &amp; \textbf{if }\gamma\notin C.orbit\textbf{ then}\\
4  &amp; \qquad \textrm{append }\gamma\textrm{ to }C.orbit\\
5  &amp; \qquad C.transversal[\gamma] \leftarrow t\\
6  &amp; \qquad \textbf{for }s\in C.generators\\
7  &amp; \qquad \qquad \textrm{ExtendTranserversal}(C,t\cdot s)\\
8  &amp; \qquad \textbf{end for}\\
9  &amp; \textbf{else}\\
10 &amp; \qquad s' \leftarrow t\cdot C.transversal[\gamma]^{-1}\\
11 &amp; \qquad \textrm{Extend}(C.next,s')\\
12 &amp; \textbf{end if}
\end{array}
\end{array}
\]</div>
<p>将此处的伪代码和上节的相比，就可以知道它是正确的。而且，两者复杂度并无差异。</p>
<h3 id="_16">复杂度</h3>
<p>为了分析 Schreier–Sims 算法的复杂度，需要一些记号。设置换的长度为 <span class="arithmatex">\(n\)</span>，生成集的大小 <span class="arithmatex">\(|S|\)</span> 为 <span class="arithmatex">\(m\)</span>。得到的（无冗余）基的长度记为 <span class="arithmatex">\(|B|\)</span>。而且，最后得到的自外向内第 <span class="arithmatex">\(i\)</span> 层的稳定化子 <span class="arithmatex">\(G_i\)</span> 中，生成元的数目记为 <span class="arithmatex">\(|S_{i-1}|\)</span>，陪集代表系的大小（或轨道的长度）记为 <span class="arithmatex">\(|T_i|\)</span>。下面分析利用上述 Schreier–Sims 算法的增量实现所需要的时间复杂度。算法主要分为两部分：筛选，以及对轨道、陪集代表系和 Schreider 生成元的计算。</p>
<p>最初输入的生成元和算法中得到的 Schreider 生成元都需要进行筛选，因而筛选过程执行的总次数是 <span class="arithmatex">\(O(\sum_{i=1}^{|B|}|S_{i-1}||T_i|+|S|)\)</span>。单次筛选需要与 <span class="arithmatex">\(O(|B|)\)</span> 个陪集代表元计算置换乘积。设计算与单个陪集代表元的乘积的时间是 <span class="arithmatex">\(\tau\)</span>。直接存储陪集代表元时，<span class="arithmatex">\(\tau\in O(n)\)</span>；而用 Schreier 树存储陪集代表元时，<span class="arithmatex">\(\tau\in O(n^2)\)</span>。执行筛选过程的时间复杂度总共为 <span class="arithmatex">\(O(\tau|B|\sum_{i=1}^{|B|}|S_{i-1}||T_i|+\tau|B||S|)\)</span>。</p>
<p>对于轨道等信息的计算，因为是增量实现，状态空间中的每对 <span class="arithmatex">\((\delta,s)\in\Delta_i\times S_{i-1}\)</span> 都只计算了至多一次。对于轨道和陪集代表系的计算，根据存储方式不同，单次计算陪集代表元的时间复杂度可能是 <span class="arithmatex">\(O(n)\)</span> 的或是 <span class="arithmatex">\(O(1)\)</span> 的。但是，无论如何，这都不超过计算 Schreider 生成元的复杂度。直接存储时，它是 <span class="arithmatex">\(O(n)\)</span> 的；使用 Schreier 树时，它是 <span class="arithmatex">\(O(n^2)\)</span> 的。与筛选过程的总时间复杂度比较，会发现计算这些信息的时间复杂度都不会超过筛选需要的时间复杂度。所以，Schreier–Sims 算法的时间复杂度就是上一段得到的 <span class="arithmatex">\(O(\tau|B|\sum_{i=1}^{|B|}|S_{i-1}||T_i|+\tau|B||S|)\)</span>。</p>
<p>至于空间复杂度，算法最后得到的数据结构中存储了 <span class="arithmatex">\(O(\sum_{i=1}^{|B|}|S_{i-1}|)\)</span> 个生成元和 <span class="arithmatex">\(O(\sum_{i=1}^{|B|}|T_i|)\)</span> 个陪集代表元。如果使用直接存储，生成元和陪集代表元都需要 <span class="arithmatex">\(O(n)\)</span> 的空间；如果使用 Schreiner 树，生成元需要 <span class="arithmatex">\(O(n)\)</span> 的空间，而陪集代表元只需要 <span class="arithmatex">\(O(1)\)</span> 的空间。</p>
<p>前文已经说明，<span class="arithmatex">\(n\)</span> 次对称群中严格递增子群链的长度是 <span class="arithmatex">\(O(n)\)</span> 的，这对 <span class="arithmatex">\(|B|\)</span> 和 <span class="arithmatex">\(|S_i|\)</span> 都适用。因而，使用直接存储陪集代表系的方式实现的 Schreier–Sims 算法，时间复杂度是 <span class="arithmatex">\(O(n^5+mn^2)\)</span> 的，空间复杂度是 <span class="arithmatex">\(O(n^3)\)</span> 的。当然对于 <span class="arithmatex">\(\log|G|\in O(n)\)</span> 的情形，一个更好的估计是时间复杂度[^knuth-complexity] <span class="arithmatex">\(O(n^2\log^3|G|+mn\log|G|)\)</span> 和空间复杂度 <span class="arithmatex">\(O(n^2\log|G|)\)</span>。对于随机的生成集的情形，实际测试发现算法的复杂度明显低于 <span class="arithmatex">\(\Theta(n^5)\)</span>，而大致是 <span class="arithmatex">\(\Theta(n^4)\)</span> 的。</p>
<p>虽然相较于直接存储，用 Schreiner 树会在时间复杂度中引入额外的 <span class="arithmatex">\(n\)</span> 的指数，但对于 <span class="arithmatex">\(n\)</span> 很大，但是群本身远小于 <span class="arithmatex">\(n\)</span> 次对称群的情形，它的空间复杂度是 <span class="arithmatex">\(O(n\log^2|G|)\)</span> 的，远小于直接存储的 <span class="arithmatex">\(O(n^2\log|G|)\)</span>。但是在算法竞赛中，很难遇到这样使用 Schreiner 树存储更优的情形。</p>
<h3 id="_17">参考实现</h3>
<p>此处提供一个 Schreier–Sims 算法的参考实现。因为 <span class="arithmatex">\(n\)</span> 规模较小，实现中直接指定基 <span class="arithmatex">\(B=\{n,n-1,\cdots,1\}\)</span> 而不是通过算法选择它。这样做的好处是，自内向外第 <span class="arithmatex">\(k\)</span> 层（不计空结构体）的群中的置换只就会改变前 <span class="arithmatex">\(k\)</span> 个元素，方便后续计算。代码中的另一项优化是，在存储陪集代表元的时候，存储的实际上是它的逆置换，这简化了置换的运算。</p>
<p>??? example "参考实现"
    <code>cpp
    --8&lt;-- "docs/math/code/schreier-sims/schreier-sims.cpp"</code></p>
<h2 id="_18">习题</h2>
<ul>
<li><a href="https://loj.ac/p/177">LOJ 177. 生成子群阶数</a></li>
<li><a href="https://uoj.ac/problem/287">[WC2017] 棋盘</a></li>
<li><a href="https://codeforces.com/gym/421334/problem/A">Permutations</a></li>
<li><a href="https://disk.yandex.com/i/OfEXXcu-anMHuw">[Grand Prix of Yekaterinburg 2015] Problem H. Heimdall</a></li>
</ul>
<h2 id="_19">参考资料与注释</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm">Schreier–Sims algorithm - Wikipedia</a></li>
<li><a href="https://www.sciencedirect.com/science/article/pii/B9780080129754500205">Sims, Charles C, Computational methods in the study of permutation groups, Computational Problems in Abstract Algebra, pp. 169–183, Pergamon, Oxford, 1970.</a></li>
<li><a href="https://arxiv.org/abs/math/9201304">Knuth, Donald E. Efficient representation of perm groups, Combinatorica 11 (1991), no. 1, 33–43.</a></li>
<li><a href="https://www.cambridge.org/core/books/permutation-group-algorithms/199629665EC545A10BCB99FFE6AAFD25">Ákos Seress, Permutation Group Algorithms, Cambridge University Press</a></li>
<li><a href="https://www.math.colostate.edu/%7Ehulpke/CGT/cgtnotes.pdf">Alexander Hulpke's Notes on Computational Group Theory</a></li>
<li><a href="https://blogs.cs.st-andrews.ac.uk/codima/files/2015/11/CoDiMa2015_Holt.pdf">Derek Holt's Slides on The Schreier–Sims algorithm for finite permutation groups</a></li>
<li><a href="https://www.m8j.net/data/List/Files-118/Documentation.pdf">Martin Jaggi, Implementations of 3 Types of the Schreier–Sims Algorithm, MAS334 - Mathematics Computing Project, 2005</a></li>
<li><a href="https://henrik.baarnhielm.net/schreiersims.pdf">Henrik Bäärnhielm. The Schreier–Sims algorithm for matrix groups</a></li>
</ul>
<p>[^knuth-year]: Knuth 的论文是在 1991 年发表的，但是他的改进在 1981 年就通过会议广泛地宣传。论文是基于他的会议讲稿写作的。</p>
<p>[^monte-carlo]: 不要与 Monto Carlo 方法混淆。此处的 Monte Carlo 算法是指出错概率恒定且任意小的随机算法。</p>
<p>[^schreier-vector]: 因为这个树形结构可以通过一列指向父节点的指针来实现，所以也称作 Schreier 向量。</p>
<p>[^schreier-lemma-unity]: 这个 <span class="arithmatex">\(e\in T\)</span> 的条件对于 Schreier 引理的成立不是必要的。</p>
<p>[^upper-bound]: <a href="https://en.wikipedia.org/wiki/Nielsen%E2%80%93Schreier_theorem">Nielsen–Schreier 定理</a> 说明，对于由 <span class="arithmatex">\(n\)</span> 个生成元生成的 <a href="https://en.wikipedia.org/wiki/Free_group">自由群</a>，它的指数为 <span class="arithmatex">\(k\)</span> 的子群是由 <span class="arithmatex">\(k(n-1)+1\)</span> 个生成元生成的自由群。</p>
<p>[^subgroup-chain]: 参见 <a href="https://www.sciencedirect.com/science/article/pii/0021869389902561">Cameron, P. J., Solomon, R., &amp; Turull, A. (1989). Chains of subgroups in symmetric groups. Journal of algebra, 127(2), 340-352.</a></p>
<p>[^siftee]: 这并不是什么严格的术语，在不同的英文文献中可能称作 siftee 或者 sifted element。</p>
<p>[^knuth-complexity]: Knuth 的论文给出的上界还要再少一个对数因子，这需要对群的稳定化子链的基础轨道长度做更仔细的估计。</p>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>