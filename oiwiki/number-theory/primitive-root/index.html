
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../fermat/">
      
      
        <link rel="next" href="../congruence-equation/">
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>阶与原根 - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#阶" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              阶与原根
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/am-gm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/cauchy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    柯西不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#阶" class="md-nav__link">
    <span class="md-ellipsis">
      
        阶
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="阶">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#幂的循环结构" class="md-nav__link">
    <span class="md-ellipsis">
      
        幂的循环结构
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#乘积的阶" class="md-nav__link">
    <span class="md-ellipsis">
      
        乘积的阶
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#原根" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="原根">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#原根判定定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根判定定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#原根个数" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根个数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#原根存在定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根存在定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#求原根的算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        求原根的算法
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#carmichael-函数" class="md-nav__link">
    <span class="md-ellipsis">
      
        Carmichael 函数
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Carmichael 函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#递推公式" class="md-nav__link">
    <span class="md-ellipsis">
      
        递推公式
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#carmichael-数" class="md-nav__link">
    <span class="md-ellipsis">
      
        Carmichael 数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#参考资料与注释" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#阶" class="md-nav__link">
    <span class="md-ellipsis">
      
        阶
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="阶">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#幂的循环结构" class="md-nav__link">
    <span class="md-ellipsis">
      
        幂的循环结构
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#乘积的阶" class="md-nav__link">
    <span class="md-ellipsis">
      
        乘积的阶
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#原根" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="原根">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#原根判定定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根判定定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#原根个数" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根个数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#原根存在定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        原根存在定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#求原根的算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        求原根的算法
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#carmichael-函数" class="md-nav__link">
    <span class="md-ellipsis">
      
        Carmichael 函数
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Carmichael 函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#递推公式" class="md-nav__link">
    <span class="md-ellipsis">
      
        递推公式
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#carmichael-数" class="md-nav__link">
    <span class="md-ellipsis">
      
        Carmichael 数
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#参考资料与注释" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>阶与原根</h1>

<p>前置知识：<a href="../fermat/#费马小定理">费马小定理</a>、<a href="../fermat/#欧拉定理">欧拉定理</a>、<a href="../congruence-equation/#定理-3lagrange-定理">拉格朗日定理</a></p>
<p>阶和原根，是理解模 <span class="arithmatex">\(m\)</span> <a href="../basic/#同余类与剩余系">既约剩余系</a> <span class="arithmatex">\(\mathbf Z_m^*\)</span> 乘法结构的重要工具．基于此，可以定义 <a href="../discrete-logarithm/">离散对数</a> 等概念．更为一般的讨论可以参见抽象代数部分 <a href="../../algebra/group-theory/#阶">群论</a> 和 <a href="../../algebra/ring-theory/#应用整数同余类的乘法群">环论</a> 等页面相关章节．</p>
<h2 id="阶">阶<a class="headerlink" href="#阶" title="Permanent link"></a></h2>
<p>本节中，总是假设模数 <span class="arithmatex">\(m\in\mathbf N_+\)</span> 和底数 <span class="arithmatex">\(a\in\mathbf Z\)</span> 互素，即 <span class="arithmatex">\((a,m)=1\)</span>，也记作 <span class="arithmatex">\(a\perp m\)</span>．</p>
<p>对于 <span class="arithmatex">\(n\in\mathbf Z\)</span>，幂次 <span class="arithmatex">\(a^n\bmod m\)</span> 呈现一种循环结构．这个循环节的最小长度，就是 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的阶．阶就定义为幂 <span class="arithmatex">\(a^n \bmod m\)</span> 第一次回到起点 <span class="arithmatex">\(a^0\bmod m = 1\)</span> 时的指数：</p>
<details class="abstract" open="open">
<summary>阶</summary>
<p>对于 <span class="arithmatex">\(a\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a\perp m\)</span>，满足同余式 <span class="arithmatex">\(a^n \equiv 1 \pmod m\)</span> 的最小正整数 <span class="arithmatex">\(n\)</span> 称作 <strong><span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的阶</strong>（the order of <span class="arithmatex">\(a\)</span> modulo <span class="arithmatex">\(m\)</span>），记作 <span class="arithmatex">\(\delta_m(a)\)</span> 或 <span class="arithmatex">\(\operatorname{ord}_m(a)\)</span>．</p>
</details>
<details class="tip" open="open">
<summary>注</summary>
<p>在 <a href="../../algebra/group-theory/#阶">抽象代数</a> 中，这里的「阶」就是模 <span class="arithmatex">\(m\)</span> 既约剩余系关于乘法形成的群中，元素 <span class="arithmatex">\(a\)</span> 的阶．用记号 <span class="arithmatex">\(\delta\)</span> 表示阶只适用于这个特殊的群．下面的诸多性质可以直接推广到抽象代数中群元素的阶的性质．</p>
<p>另外还有「半阶」的概念，在数论中会用 <span class="arithmatex">\(\delta^-\)</span> 记号表示．它是满足同余式 <span class="arithmatex">\(a^n \equiv -1 \pmod m\)</span> 的最小正整数．半阶不是群论中的概念．阶一定存在，半阶不一定存在．</p>
</details>
<h3 id="幂的循环结构">幂的循环结构<a class="headerlink" href="#幂的循环结构" title="Permanent link"></a></h3>
<p>利用阶，可以刻画幂的循环结构．对于幂 <span class="arithmatex">\(a^n\bmod m\)</span>，可以将指数 <span class="arithmatex">\(n\)</span> 对阶 <span class="arithmatex">\(\delta_m(a)\)</span> 做带余除法：</p>
<div class="arithmatex">\[
n = \delta_m(a)q + r, ~ 0\le r &lt; \delta_m(a). 
\]</div>
<p>进而，利用幂的运算律，就得到</p>
<div class="arithmatex">\[
a^n = a^{\delta_m(a)q + r} = (a^{\delta_m(a)})^q \cdot a^r \equiv a^r \pmod m.
\]</div>
<p>这说明，对于任意指数的幂，可以将它平移到第一个非负的循环节．由此，可以得到一系列关于阶的性质．</p>
<p><a id="ord-prop-1"></a></p>
<details class="note" open="open">
<summary>性质 1</summary>
<p>对于 <span class="arithmatex">\(a\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a\perp m\)</span>，幂次 <span class="arithmatex">\(a^0(=1),a,a^2,\cdots,a^{\delta_m(a)-1}\)</span> 模 <span class="arithmatex">\(m\)</span> 两两不同余．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>考虑反证．假设存在两个数 <span class="arithmatex">\(0\le i&lt; j&lt;\delta_m(a)\)</span>，且 <span class="arithmatex">\(a^i\equiv a^j\pmod m\)</span>，则有 <span class="arithmatex">\(a^{j - i}\equiv 1\pmod m\)</span>．但是，<span class="arithmatex">\(0 &lt; j - i &lt; \delta_m(a)\)</span>．这与阶的最小性矛盾，故原命题成立．</p>
</details>
<p><a id="ord-prop-2"></a></p>
<details class="note" open="open">
<summary>性质 2</summary>
<p>对于 <span class="arithmatex">\(a,n\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a\perp m\)</span>，同余关系 <span class="arithmatex">\(a^n \equiv 1 \pmod m\)</span> 成立，当且仅当 <span class="arithmatex">\(\delta_m(a)\mid n\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>如前文所述，<span class="arithmatex">\(a^{n}\equiv a^{n\bmod\delta_m(a)}\pmod m\)</span>．由 <a href="#ord-prop-1">性质 1</a> 可知，<span class="arithmatex">\(0\le r &lt; \delta_m(a)\)</span> 中唯一一个使得 <span class="arithmatex">\(a^r\equiv 1\pmod m\)</span> 成立的 <span class="arithmatex">\(r\)</span> 就是 <span class="arithmatex">\(r=0\)</span>．因此，<span class="arithmatex">\(a^n \equiv 1 \pmod m\)</span>，当且仅当 <span class="arithmatex">\(n\bmod \delta_m(a) = 0\)</span>，也就是 <span class="arithmatex">\(\delta_m(a)\mid n\)</span>．</p>
</details>
<p><a href="../fermat/#欧拉定理">欧拉定理</a> 中，同余关系 <span class="arithmatex">\(a^{\varphi(m)}\equiv 1\pmod m\)</span> 对于所有 <span class="arithmatex">\(a\perp m\)</span> 都成立．结合 <a href="#ord-prop-2">性质 2</a>，这说明对于所有 <span class="arithmatex">\(a\perp m\)</span>，都有 <span class="arithmatex">\(\delta_m(a)\mid\varphi(m)\)</span>．换句话说，<span class="arithmatex">\(\varphi(m)\)</span> 是所有 <span class="arithmatex">\(a\perp m\)</span> 的阶的一个公倍数．对于一个正整数 <span class="arithmatex">\(m\)</span>，所有 <span class="arithmatex">\(a\perp m\)</span> 的阶 <span class="arithmatex">\(\delta_m(a)\)</span> 的最小公倍数，记作 <span class="arithmatex">\(\lambda(m)\)</span>，就是 <span class="arithmatex">\(m\)</span> 的 <a href="#carmichael-函数">Carmichael 函数</a>．后文会详细讨论它的性质．</p>
<p>和其他的循环结构类似，可以根据 <span class="arithmatex">\(a\)</span> 的阶计算 <span class="arithmatex">\(a^k\)</span> 的阶．</p>
<p><a id="ord-prop-3"></a></p>
<details class="note" open="open">
<summary>性质 3</summary>
<p>对于 <span class="arithmatex">\(k,a\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a\perp m\)</span>，有</p>
<div class="arithmatex">\[
\delta_m(a^k) = \dfrac{\delta_m(a)}{(\delta_m(a),k)}.
\]</div>
</details>
<details class="note">
<summary>证明</summary>
<p>由 <a href="#ord-prop-2">性质 2</a>，同余关系 <span class="arithmatex">\((a^k)^n = a^{kn} \equiv 1\pmod m\)</span> 成立，当且仅当 <span class="arithmatex">\(\delta_m(a) \mid kn\)</span>．这一条件就等价于</p>
<div class="arithmatex">\[
\dfrac{\delta_m(a)}{\left(\delta_m(a),k\right)} \mid n.
\]</div>
<p>使得这一条件成立的最小正整数就是</p>
<div class="arithmatex">\[
\delta_m(a^k)=\dfrac{\delta_m(a)}{\left(\delta_m(a),k\right)}.
\]</div>
</details>
<h3 id="乘积的阶">乘积的阶<a class="headerlink" href="#乘积的阶" title="Permanent link"></a></h3>
<p>设 <span class="arithmatex">\(a,b\)</span> 是与 <span class="arithmatex">\(m\)</span> 互素的不同整数．如果已知阶 <span class="arithmatex">\(\delta_m(a)\)</span> 和 <span class="arithmatex">\(\delta_m(b)\)</span>，那么，同样可以获得一些关于它们乘积 <span class="arithmatex">\(ab\)</span> 的阶 <span class="arithmatex">\(\delta_{m}(ab)\)</span> 的信息．</p>
<p><a id="ord-prop-4"></a></p>
<details class="note" open="open">
<summary>性质 4</summary>
<p>对于 <span class="arithmatex">\(a,b\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a,b\perp m\)</span>，那么，有</p>
<div class="arithmatex">\[
\dfrac{[\delta_m(a),\delta_m(b)]}{(\delta_m(a),\delta_m(b))} \mid \delta_m(ab) \mid [\delta_m(a),\delta_m(b)].
\]</div>
</details>
<details class="note">
<summary>证明</summary>
<p>因为 <span class="arithmatex">\([\delta_m(a),\delta_m(b)]\)</span> 是 <span class="arithmatex">\(\delta_m(a)\)</span> 和 <span class="arithmatex">\(\delta_m(b)\)</span> 的倍数，所以，由 <a href="#ord-prop-2">性质 2</a> 可知</p>
<div class="arithmatex">\[
(ab)^{[\delta_m(a),\delta_m(b)]} = a^{[\delta_m(a),\delta_m(b)]} b^{[\delta_m(a),\delta_m(b)]} \equiv 1 \pmod m.
\]</div>
<p>再次应用性质 2，就得到</p>
<div class="arithmatex">\[
\delta_m(ab) \mid [\delta_m(a),\delta_m(b)].
\]</div>
<p>这就得到右侧的整除关系．</p>
<p>反过来，由于</p>
<div class="arithmatex">\[
1 \equiv (ab)^{\delta_m(ab)\delta_m(b)} \equiv a^{\delta_m(ab)\delta_m(b)} \pmod m,
\]</div>
<p>所以，应用性质 2，就得到 <span class="arithmatex">\(\delta_m(a)\mid\delta_m(ab)\delta_m(b)\)</span>．两侧消去 <span class="arithmatex">\((\delta_m(a),\delta_m(b))\)</span>，就得到</p>
<div class="arithmatex">\[
\dfrac{\delta_m(a)}{(\delta_m(a),\delta_m(b))}\mid\delta_m(ab)\dfrac{\delta_m(b)}{(\delta_m(a),\delta_m(b))}.
\]</div>
<p>消去公因子后，两个分式互素，这就得到</p>
<div class="arithmatex">\[
\dfrac{\delta_m(a)}{(\delta_m(a),\delta_m(b))}\mid\delta_m(ab).
\]</div>
<p>同理，也有</p>
<div class="arithmatex">\[
\dfrac{\delta_m(b)}{(\delta_m(a),\delta_m(b))}\mid\delta_m(ab).
\]</div>
<p>由于两个整除关系的左侧互素，有</p>
<div class="arithmatex">\[
\dfrac{[\delta_m(a),\delta_m(b)]}{(\delta_m(a),\delta_m(b))} =\dfrac{\delta_m(a)\delta_m(b)}{(\delta_m(a),\delta_m(b))^2}\mid\delta_m(ab).
\]</div>
<p>这就得到左侧的整除关系．</p>
</details>
<p>对于 <span class="arithmatex">\(a\)</span> 和 <span class="arithmatex">\(b\)</span> 的阶互素的情形，这一结论有着更为简单的形式．</p>
<p><a id="ord-prop-4p"></a></p>
<details class="note" open="open">
<summary>性质 4'</summary>
<p>对于 <span class="arithmatex">\(a,b\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a,b\perp m\)</span>，那么，有</p>
<div class="arithmatex">\[
\delta_m(ab) = \delta_m(a)\delta_m(b) \iff \delta_m(a)\perp\delta_m(b).
\]</div>
</details>
<details class="note">
<summary>证明</summary>
<p>如果 <span class="arithmatex">\(\delta_m(a)\perp\delta_m(b)\)</span>，那么 <a href="#ord-prop-4">性质 4</a> 中所有整除关系都是等式，所以有</p>
<div class="arithmatex">\[
\delta_m(ab) = [\delta_m(a),\delta_m(b)] = \delta_m(a)\delta_m(b).
\]</div>
<p>反过来，如果 <span class="arithmatex">\(\delta_m(ab)=\delta_m(a)\delta_m(b)\)</span>，那么根据性质 4，就有</p>
<div class="arithmatex">\[
\delta_m(a)\delta_m(b) = \delta_m(ab) \mid [\delta_m(a),\delta_m(b)].
\]</div>
<p>这立马说明 <span class="arithmatex">\((\delta_m(a),\delta_m(b))=1\)</span>，即 <span class="arithmatex">\(\delta_m(a)\perp\delta_m(b)\)</span>．</p>
</details>
<p>一般情形中，<a href="#ord-prop-4">性质 4</a> 得到的界已经是紧的．乘积的阶取得下界的情形很容易构造：例如 <span class="arithmatex">\((a,b,m)=(3,5,7)\)</span> 时，<span class="arithmatex">\(\delta_m(a)=\delta_m(b)=6\)</span>，但是它们的乘积的阶 <span class="arithmatex">\(\delta_m(ab)=1\)</span>．</p>
<p>尽管一般情形中，乘积 <span class="arithmatex">\(ab\)</span> 的阶未必是它们的阶的最小公倍数，但是总能找到一个元素使得它的阶等于这个最小公倍数．</p>
<p><a id="ord-prop-5"></a></p>
<details class="note" open="open">
<summary>性质 5</summary>
<p>对于 <span class="arithmatex">\(a,b\in\mathbf Z,m\in\mathbf N_+\)</span> 且 <span class="arithmatex">\(a,b\perp m\)</span>，总是存在 <span class="arithmatex">\(c\in\mathbf Z\)</span> 且 <span class="arithmatex">\(c\perp m\)</span> 使得</p>
<div class="arithmatex">\[
\delta_m(c) = [\delta_m(a),\delta_m(b)].
\]</div>
</details>
<details class="note">
<summary>证明</summary>
<p>考虑素因数分解：</p>
<div class="arithmatex">\[
\delta_m(a) = \prod_p p^{\alpha_p},~ \delta_m(b) = \prod_p p^{\beta_p}.
\]</div>
<p>利用 <span class="arithmatex">\(\alpha_p\)</span> 和 <span class="arithmatex">\(\beta_p\)</span> 的大小关系，可以将所有素因子分为两类：</p>
<div class="arithmatex">\[
A = \{p : \alpha_p \ge \beta_p\}, ~ B = \{p : \alpha_p &lt; \beta_p\}.
\]</div>
<p>由此，分别设</p>
<div class="arithmatex">\[
\gamma_A = \prod_{p\in A}p^{\alpha_p},~\gamma_B = \prod_{p\in B}p^{\alpha_p},~\eta_A = \prod_{p\in A}p^{\beta_p},~\eta_B = \prod_{p\in B}p^{\beta_p},
\]</div>
<p>就有 <span class="arithmatex">\(\delta_m(a) = \gamma_A\gamma_B\)</span> 和 <span class="arithmatex">\(\delta_m(b)=\eta_A\eta_B\)</span>．根据 <a href="#ord-prop-3">性质 3</a>，可知</p>
<div class="arithmatex">\[
\begin{aligned}
\delta_m(a^{\gamma_B}) &amp;= \dfrac{\delta_m(a)}{(\delta_m(a),\gamma_B)} = \dfrac{\delta_m(a)}{\gamma_B} = \gamma_A,\\
\delta_m(b^{\eta_A}) &amp;= \dfrac{\delta_m(b)}{(\delta_m(b),\eta_A)} = \dfrac{\delta_m(b)}{\eta_A} = \eta_B.
\end{aligned}
\]</div>
<p>因为 <span class="arithmatex">\(\gamma_A\perp\eta_B\)</span>，由 <a href="#ord-prop-4p">性质 4'</a>，就有</p>
<div class="arithmatex">\[
\delta_m(a^{\gamma_B}b^{\eta_A}) = \gamma_A\eta_B = \prod_p p^{\max\{\alpha_p,\beta_p\}} = [\delta_m(a),\delta_m(b)].
\]</div>
<p>因此，<span class="arithmatex">\(c=a^{\gamma_B}b^{\eta_A}\)</span> 就是阶为 <span class="arithmatex">\([\delta_m(a),\delta_m(b)]\)</span> 的元素．</p>
</details>
<p>这一结论常用于构造出指定阶的元素．</p>
<h2 id="原根">原根<a class="headerlink" href="#原根" title="Permanent link"></a></h2>
<p>原根是一些特殊元素——它的阶就等于所有模 <span class="arithmatex">\(m\)</span> 既约剩余系的个数．</p>
<details class="abstract" open="open">
<summary>原根</summary>
<p>对于 <span class="arithmatex">\(m\in\mathbf N_+\)</span>，如果存在 <span class="arithmatex">\(g\in\mathbf Z\)</span> 且 <span class="arithmatex">\(g\perp m\)</span> 使得 <span class="arithmatex">\(\delta_m(g)=|\mathbf Z_m^*|=\varphi(m)\)</span>，就称 <span class="arithmatex">\(g\)</span> 为 <strong>模 <span class="arithmatex">\(m\)</span> 的原根</strong>（primitive root modulo <span class="arithmatex">\(m\)</span>）．其中，<span class="arithmatex">\(\varphi(m)\)</span> 是 <a href="../euler-totient/">欧拉函数</a>．</p>
</details>
<p>并非所有正整数 <span class="arithmatex">\(m\)</span> 都存在模 <span class="arithmatex">\(m\)</span> 的原根．由上文的 <a href="#ord-prop-1">性质 1</a>，如果模 <span class="arithmatex">\(m\)</span> 的原根 <span class="arithmatex">\(g\)</span> 存在，那么，<span class="arithmatex">\(g,g^2,\cdots,g^{\varphi(m)}\)</span> 所在的同余类互不相同，构成模 <span class="arithmatex">\(m\)</span> 既约剩余系．特别地，对于素数 <span class="arithmatex">\(p\)</span>，余数 <span class="arithmatex">\(g^i\bmod p\)</span> 对于 <span class="arithmatex">\(i=1,2,\cdots,p-1\)</span> 两两不同．</p>
<details class="tip" open="open">
<summary>注</summary>
<p>在 <a href="../../algebra/ring-theory/#应用整数同余类的乘法群">抽象代数</a> 中，原根就是循环群的生成元．这个概念只在模 <span class="arithmatex">\(m\)</span> 既约剩余系关于乘法形成的群中有「原根」这个名字，在一般的循环群中都称作「生成元」．并非每个模 <span class="arithmatex">\(m\)</span> 既约剩余系关于乘法形成的群都是循环群，存在原根就表明它同构于循环群，如果不存在原根就表明不同构．</p>
</details>
<p>模为 <span class="arithmatex">\(1\)</span> 时，模 <span class="arithmatex">\(1\)</span> 整数乘法群就是 <span class="arithmatex">\(\{0\}\)</span>．这显然是循环群，所以原根就是 <span class="arithmatex">\(0\)</span>．</p>
<h3 id="原根判定定理">原根判定定理<a class="headerlink" href="#原根判定定理" title="Permanent link"></a></h3>
<p>如果已知模数 <span class="arithmatex">\(\varphi(m)\)</span> 的全体素因子，那么很容易判断模 <span class="arithmatex">\(m\)</span> 的原根是否存在．</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于整数 <span class="arithmatex">\(m\ge 3\)</span> 和 <span class="arithmatex">\(g\perp m\)</span>，那么，<span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(m\)</span> 的原根，当且仅当对于 <span class="arithmatex">\(\varphi(m)\)</span> 的每个素因数 <span class="arithmatex">\(p\)</span>，都有</p>
<div class="arithmatex">\[
g^{\frac{\varphi(m)}{p}}\not\equiv 1 \pmod m.
\]</div>
</details>
<details class="note">
<summary>证明</summary>
<p>必要性显然．为证明充分性，考虑使用反证法．如果 <span class="arithmatex">\(g\)</span> 不是模 <span class="arithmatex">\(m\)</span> 的原根，那么一定有 <span class="arithmatex">\(\delta_m(g)&lt; \varphi(m)\)</span>．由 <a href="#ord-prop-2">性质 2</a> 和欧拉定理可知，<span class="arithmatex">\(\delta_m(g)\mid\varphi(m)\)</span>．由此，设 <span class="arithmatex">\(p\)</span> 是 <span class="arithmatex">\(\dfrac{\varphi(m)}{\delta_m(g)}\)</span> 的一个素因子，就有 <span class="arithmatex">\(\delta_m(g)\mid\dfrac{\varphi(m)}{p}\)</span>．再次应用性质 2 就得到</p>
<div class="arithmatex">\[
g^{\frac{\varphi(m)}{p}} \equiv 1 \pmod m.
\]</div>
<p>但是，<span class="arithmatex">\(p\)</span> 也是 <span class="arithmatex">\(\varphi(m)\)</span> 的一个因子，这就与题设条件矛盾．由此，原命题的充分性成立．</p>
</details>
<h3 id="原根个数">原根个数<a class="headerlink" href="#原根个数" title="Permanent link"></a></h3>
<p>原根如果存在，也未必唯一．一般地，对于模 <span class="arithmatex">\(m\)</span> 既约剩余系中所有元素可能的阶和某个阶的元素数量，有如下结论：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>如果正整数 <span class="arithmatex">\(m\)</span> 有原根 <span class="arithmatex">\(g\)</span>，那么，当且仅当 <span class="arithmatex">\(d\mid\varphi(m)\)</span> 时，模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(d\)</span> 阶元素存在，且恰有 <span class="arithmatex">\(\varphi(d)\)</span> 个．特别地，模 <span class="arithmatex">\(m\)</span> 的原根个数为 <span class="arithmatex">\(\varphi(\varphi(m))\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>根据原根的定义，所有模 <span class="arithmatex">\(m\)</span> 的既约同余类都可以写作 <span class="arithmatex">\(g^k\bmod m\)</span> 的形式，且 <span class="arithmatex">\(k\)</span> 是 <span class="arithmatex">\(1,2,\cdots,\varphi(m)\)</span> 之一．由 <a href="#ord-prop-3">性质 3</a>，这些元素的阶等于</p>
<div class="arithmatex">\[
\delta_m(g^k) = \dfrac{\varphi(m)}{(\varphi(m),k)}.
\]</div>
<p>因此，<span class="arithmatex">\(d\)</span> 阶元素存在，当且仅当 <span class="arithmatex">\(d\mid\varphi(m)\)</span>．而且，对于 <span class="arithmatex">\(d\mid\varphi(m)\)</span>，令 <span class="arithmatex">\(d'=\varphi(m)/d\)</span>，这些元素的集合就是</p>
<div class="arithmatex">\[
\begin{aligned}
A &amp;= \{g^k : (\varphi(m),k)=d',~1\le k \le\varphi(m)\} \\
&amp;= \{g^k : d'\mid k,~ (d, k/d') = 1,~ 1 \le k/d' \le d\}.
\end{aligned}
\]</div>
<p>这些元素对应的 <span class="arithmatex">\(k'=k/d'\)</span> 恰为那些不超过 <span class="arithmatex">\(d\)</span> 且与 <span class="arithmatex">\(d\)</span> 互素的正整数．由欧拉函数的定义，这就是 <span class="arithmatex">\(\varphi(d)\)</span>．</p>
</details>
<h3 id="原根存在定理">原根存在定理<a class="headerlink" href="#原根存在定理" title="Permanent link"></a></h3>
<p>本节将建立如下原根存在定理：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>模 <span class="arithmatex">\(m\)</span> 的原根存在，当且仅当 <span class="arithmatex">\(m=1,2,4,p^e,2p^e\)</span>，其中，<span class="arithmatex">\(p\)</span> 是奇素数且 <span class="arithmatex">\(e\in\mathbf N_+\)</span>．</p>
</details>
<p>为说明这一结论，需要分别讨论如下四种情形：</p>
<ol>
<li>
<p><span class="arithmatex">\(m=1,2,4\)</span>，原根分别是 <span class="arithmatex">\(g=0,1,3\)</span>，显然存在．</p>
</li>
<li>
<p><span class="arithmatex">\(m=p^{e}\)</span> 是奇素数的幂，其中，<span class="arithmatex">\(p\)</span> 为奇素数，<span class="arithmatex">\(e\in\mathbf N_+\)</span>．</p>
<details class="note" open="open">
<summary>引理 1</summary>
<p>对于奇素数 <span class="arithmatex">\(p\)</span>，模 <span class="arithmatex">\(p\)</span> 的原根存在．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>证明分为两步．</p>
<p><strong>第一步</strong>：对于 <span class="arithmatex">\(d\mid(p-1)\)</span>，同余方程 <span class="arithmatex">\(x^d\equiv 1\pmod p\)</span> 恰有 <span class="arithmatex">\(d\)</span> 个互不相同的解．</p>
<p>令 <span class="arithmatex">\(p-1=kd\)</span>，多项式</p>
<div class="arithmatex">\[
f(x) = x^{d(k-1)} + x^{d(k-2)} + \cdots + x^d + 1. 
\]</div>
<p>根据 <a href="../fermat/#欧拉定理">欧拉定理</a>，同余方程 <span class="arithmatex">\((x^d-1)f(x)=x^{p-1}-1\equiv 0\pmod{p}\)</span> 恰有 <span class="arithmatex">\(p-1\)</span> 个互不相同的解．这些解分别是 <span class="arithmatex">\(x^d-1\)</span> 和 <span class="arithmatex">\(f(x)\)</span> 的零点．由 <a href="../congruence-equation/#定理-3lagrange-定理">Lagrange 定理</a>，它们分别至多只能有 <span class="arithmatex">\(d\)</span> 个和 <span class="arithmatex">\(d(k-1)\)</span> 个互不相同的零点．由于 <span class="arithmatex">\(d+d(k-1)=p-1\)</span>，前者只能恰好有 <span class="arithmatex">\(d\)</span> 个互不相同的零点．这说明同余方程 <span class="arithmatex">\(x^d\equiv 1\pmod p\)</span> 恰有 <span class="arithmatex">\(d\)</span> 个互不相同的解．</p>
<p><strong>第二步</strong>：对于 <span class="arithmatex">\(d\mid(p-1)\)</span>，<span class="arithmatex">\(d\)</span> 阶元素恰好有 <span class="arithmatex">\(\varphi(d)\)</span> 个．</p>
<p>对于 <span class="arithmatex">\(\varphi(p)\)</span> 的所有因子排序，然后应用归纳法．因为 <span class="arithmatex">\(1\)</span> 阶元素只能是 <span class="arithmatex">\(1\)</span>，只有一个，归纳起点成立．对于 <span class="arithmatex">\(d\mid(p-1)\)</span>，根据前文的 <a href="#ord-prop-2">性质 2</a>，同余方程 <span class="arithmatex">\(x^d\equiv 1\pmod p\)</span> 的解一定满足 <span class="arithmatex">\(\delta_p(x)\mid d\)</span>．因此，其中 <span class="arithmatex">\(d\)</span> 阶元素个数为</p>
<div class="arithmatex">\[
N(d) = d - \sum_{e\mid d,~e\neq d} N(e) =  d - \sum_{e\mid d,~e\neq d} \varphi(e) = \varphi(d).
\]</div>
<p>第二个等号是归纳假设，第三个等号是欧拉函数的性质．由数学归纳法，就知道对于所有 <span class="arithmatex">\(d\mid(p-1)\)</span>，都恰有 <span class="arithmatex">\(\varphi(d)\)</span> 个 <span class="arithmatex">\(d\)</span> 阶元素．</p>
<p>特别地，对于 <span class="arithmatex">\(d=p-1\)</span>，恰有 <span class="arithmatex">\(\varphi(p-1)\)</span> 个 <span class="arithmatex">\((p-1)\)</span> 阶元素．因此，模 <span class="arithmatex">\(p\)</span> 的原根存在．</p>
</details>
<details class="note" open="open">
<summary>引理 2</summary>
<p>对于奇素数 <span class="arithmatex">\(p\)</span> 和 <span class="arithmatex">\(e \in \mathbf{N}_+\)</span>，模 <span class="arithmatex">\(p^e\)</span> 的原根存在．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>证明分为三步．</p>
<p><strong>第一步</strong>：存在模 <span class="arithmatex">\(p\)</span> 的原根 <span class="arithmatex">\(g\)</span>，使得 <span class="arithmatex">\(g^{p-1}\not\equiv 1\pmod{p^2}\)</span>．</p>
<p>任取一个模 <span class="arithmatex">\(p\)</span> 的原根 <span class="arithmatex">\(g\)</span>．如果它不符合条件，即 <span class="arithmatex">\(g^{p-1}\equiv 1\pmod{p^2}\)</span>，那么，可以证明 <span class="arithmatex">\(g+p\)</span> 符合条件：<span class="arithmatex">\(g+p\)</span> 也是模 <span class="arithmatex">\(p\)</span> 的原根，且</p>
<div class="arithmatex">\[
\begin{aligned}
(g+p)^{p-1} &amp;\equiv \binom{p-1}{0}g^{p-1} + \binom{p-1}{1}g^{p-2}p \\
&amp;= g^{p-1} + g^{p-2}p(p-1) \\ 
&amp;\equiv 1 - pg^{p-2} \not\equiv 1 \pmod{p^2}.
\end{aligned}
\]</div>
<p><strong>第二步</strong>：上文选取的 <span class="arithmatex">\(g\)</span>，对于任意 <span class="arithmatex">\(e\ge 1\)</span>，都有 <span class="arithmatex">\(g^{\varphi(p^e)}\not\equiv 1\pmod{p^{e+1}}\)</span>．</p>
<p>对 <span class="arithmatex">\(g\)</span> 的选取保证了 <span class="arithmatex">\(e=1\)</span> 时，该式成立．假设该式对于 <span class="arithmatex">\(e\)</span> 的情形成立，现要证明 <span class="arithmatex">\(e+1\)</span> 的情形也成立．对于任意 <span class="arithmatex">\(e \ge 1\)</span>，由欧拉定理可知，存在 <span class="arithmatex">\(\lambda\)</span> 使得</p>
<div class="arithmatex">\[
g^{\varphi(p^e)} = 1 + \lambda p^e
\]</div>
<p>成立．由归纳假设，<span class="arithmatex">\(\lambda\perp p\)</span>．因为 <span class="arithmatex">\(\varphi(p^{e+1})=p\varphi(p^e)\)</span>，所以</p>
<div class="arithmatex">\[
g^{\varphi(p^{e+1})} = \left(g^{\varphi(p^{e})}\right)^p = (1 + \lambda p^e)^p \equiv 1 + \lambda p^{e+1} \pmod{p^{e+2}}.
\]</div>
<p>结合 <span class="arithmatex">\(\lambda\perp p\)</span> 可知，<span class="arithmatex">\(g^{\varphi(p^{e+1})}\not\equiv 1\pmod{p^{e+2}}\)</span>．由数学归纳法可知，命题成立．</p>
<p><strong>第三步</strong>：上文选取的 <span class="arithmatex">\(g\)</span>，对于任意 <span class="arithmatex">\(e\ge 1\)</span>，都是模 <span class="arithmatex">\(p^e\)</span> 的原根．</p>
<p>对 <span class="arithmatex">\(g\)</span> 的选取保证了 <span class="arithmatex">\(e=1\)</span> 时，命题成立．假设命题对于 <span class="arithmatex">\(e\)</span> 成立，现在要证明命题对于 <span class="arithmatex">\(e+1\)</span> 也成立．将 <span class="arithmatex">\(\delta_{p^{e+1}}(g)\)</span> 简记为 <span class="arithmatex">\(\delta\)</span>．由于 <span class="arithmatex">\(g^\delta\equiv 1\pmod{p^{e+1}}\)</span>，必然也有 <span class="arithmatex">\(g^\delta\equiv 1\pmod{p^e}\)</span>．由归纳假设可知，<span class="arithmatex">\(\delta_{p^e}(g) = \varphi(p^e)\)</span>．因此，由前文阶的 <a href="#ord-prop-2">性质 2</a>，就有 <span class="arithmatex">\(\varphi(p^e)\mid\delta\)</span>．又由欧拉定理可知，<span class="arithmatex">\(\delta\mid\varphi(p^{e+1})\)</span>．但是，<span class="arithmatex">\(\varphi(p^{e+1})=p\varphi(p^e)\)</span>．因此，只有两种可能：<span class="arithmatex">\(\delta=\varphi(p^e)\)</span> 或 <span class="arithmatex">\(\delta=\varphi(p^{e+1})\)</span>．但是，第二步的结论说明，<span class="arithmatex">\(g^{\varphi(p^e)}\not\equiv 1\pmod{p^{e+1}}\)</span>．因此，可能性 <span class="arithmatex">\(\delta=\varphi(p^e)\)</span> 并不成立．唯一的可能性就是 <span class="arithmatex">\(\delta=\varphi(p^{e+1})\)</span>．这就说明 <span class="arithmatex">\(g\)</span> 是 <span class="arithmatex">\(p^{e+1}\)</span> 的原根．由数学归纳法，命题对于所有 <span class="arithmatex">\(e\ge 1\)</span> 都成立．</p>
</details>
</li>
<li>
<p><span class="arithmatex">\(m=2p^{e}\)</span>，其中，<span class="arithmatex">\(p\)</span> 为奇素数，<span class="arithmatex">\(e\in\mathbf N_+\)</span>．</p>
<details class="note" open="open">
<summary>引理 3</summary>
<p>对于奇素数 <span class="arithmatex">\(p\)</span> 和 <span class="arithmatex">\(e \in \mathbf{N}_+\)</span>，模 <span class="arithmatex">\(2p^e\)</span> 的原根存在．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>设 <span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(p^{e}\)</span> 的原根，则 <span class="arithmatex">\(g+p^e\)</span> 也是模 <span class="arithmatex">\(p^{e}\)</span> 的原根．两者之间必然有一个是奇数，不妨设它就是 <span class="arithmatex">\(g\)</span>．显然，<span class="arithmatex">\((g,2p^e)=1\)</span>．设 <span class="arithmatex">\(\delta=\delta_{2p^e}(g)\)</span>，需要证明 <span class="arithmatex">\(\delta=\varphi(2p^e)\)</span>．由欧拉定理，<span class="arithmatex">\(\delta\mid\varphi(2p^e)\)</span>．同时，根据定义 <span class="arithmatex">\(g^\delta\equiv 1\pmod{2p^e}\)</span>，所以，<span class="arithmatex">\(g^\delta\equiv 1\pmod{p^e}\)</span>，因此，由阶的 <a href="#ord-prop-2">性质 2</a> 和 <span class="arithmatex">\(g\)</span> 的选取可知，<span class="arithmatex">\(\delta_{p^e}(g)=\varphi(p^e)\mid \delta\)</span>．由欧拉函数表达式可知，<span class="arithmatex">\(\varphi(2p^e) = \varphi(p^e)\)</span>．所以，<span class="arithmatex">\(\delta=\delta_{2p^e}(g)=\varphi(p^e)\)</span>．这就说明 <span class="arithmatex">\(\delta\)</span> 是模 <span class="arithmatex">\(2p^e\)</span> 的原根．</p>
</details>
</li>
<li>
<p><span class="arithmatex">\(m\ne 1,2,4,p^{e},2p^{e}\)</span>，其中，<span class="arithmatex">\(p\)</span> 为奇素数，<span class="arithmatex">\(e\in\mathbf N_+\)</span>．</p>
<p><a id="prim-root-lem-4"></a></p>
<details class="note" open="open">
<summary>引理 4</summary>
<p>假设 <span class="arithmatex">\(m\neq 1,2,4\)</span> 且不存在奇素数 <span class="arithmatex">\(p\)</span> 和正整数 <span class="arithmatex">\(e\)</span> 使得 <span class="arithmatex">\(m=p^e\)</span> 或 <span class="arithmatex">\(m=2p^e\)</span>．那么，模 <span class="arithmatex">\(m\)</span> 的原根不存在．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>对于 <span class="arithmatex">\(m=2^e\)</span> 且 <span class="arithmatex">\(e\ge 3\)</span>，假设模 <span class="arithmatex">\(m\)</span> 的原根 <span class="arithmatex">\(g\)</span> 存在．由于 <span class="arithmatex">\(g\perp m\)</span>，它一定是奇数．假设 <span class="arithmatex">\(g=2k+1\)</span> 且 <span class="arithmatex">\(k\in\mathbf N\)</span>，那么，有</p>
<div class="arithmatex">\[
\begin{aligned}
g^{2^{e-2}}
&amp;=(2k+1)^{2^{e-2}} \\
&amp;\equiv 1 + \binom{2^{e-2}}{1}(2k) + \binom{{2^{e-2}}}{2}(2k)^2 \\
&amp;= 1 + 2^{e-1}k + 2^{e-1}(2^{e-2}-1)k^2 \\
&amp;= 1 + 2^{e-1}(k + (2^{e-2}-1)k^2) \\
&amp;\equiv 1 \pmod{2^{e}}.
\end{aligned}
\]</div>
<p>倒数第二行中，因为 <span class="arithmatex">\(k\)</span> 与 <span class="arithmatex">\((2^{e-2}-1)k^2\)</span> 奇偶性相同，所以它们的和是偶数．由阶的定义可知，<span class="arithmatex">\(\delta_{2^{e}}(g)\le 2^{e-2}&lt; \varphi(2^{e}) = 2^{e-1}\)</span>．这与假设中 <span class="arithmatex">\(g\)</span> 是原根矛盾．由反证法，这样的原根并不存在．</p>
<p>假设 <span class="arithmatex">\(m\)</span> 满足所述条件，且不是 <span class="arithmatex">\(2\)</span> 的幂，那么，一定存在 <span class="arithmatex">\(2 &lt; m_1 &lt; m_2\)</span> 且 <span class="arithmatex">\(m_1\perp m_2\)</span> 使得 <span class="arithmatex">\(m=m_1m_2\)</span> 成立．假设模 <span class="arithmatex">\(m\)</span> 的原根 <span class="arithmatex">\(g\)</span> 存在．因为 <span class="arithmatex">\(g\perp m\)</span>，所以对于 <span class="arithmatex">\(i=1,2\)</span>，都有 <span class="arithmatex">\(g\perp m_i\)</span>．由欧拉定理可知，</p>
<div class="arithmatex">\[
g^{\varphi(m_i)} \equiv 1 \pmod{m_i}.
\]</div>
<p>由于 <span class="arithmatex">\(m_i &gt; 2\)</span>，所以 <span class="arithmatex">\(\varphi(m_i)\)</span> 为偶数，所以，对于 <span class="arithmatex">\(i=1,2\)</span>，有</p>
<div class="arithmatex">\[
g^{\frac{1}{2}\varphi(m_1)\varphi(m_2)} \equiv 1 \pmod{m_i}.
\]</div>
<p>由 <a href="../crt/">中国剩余定理</a> 可知</p>
<div class="arithmatex">\[
g^{\frac{1}{2}\varphi(m_1)\varphi(m_2)} \equiv 1 \pmod{m}.
\]</div>
<p>又因为 <span class="arithmatex">\(\varphi(m)=\varphi(m_1)\varphi(m_2)\)</span>，所以由阶的定义可知</p>
<div class="arithmatex">\[
\delta_m(g) \le \frac{1}{2}\varphi(m_1)\varphi(m_2) = \dfrac{1}{2}\varphi(m) &lt; \varphi(m).
\]</div>
<p>这与 <span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(m\)</span> 的原根的假设矛盾．故而，由反证法知，模 <span class="arithmatex">\(m\)</span> 的原根不存在．</p>
</details>
</li>
</ol>
<p>综合以上四个引理，我们便给出了一个数存在原根的充要条件．</p>
<h3 id="求原根的算法">求原根的算法<a class="headerlink" href="#求原根的算法" title="Permanent link"></a></h3>
<p>对于任何存在原根的模数 <span class="arithmatex">\(m\)</span>，要求得它的原根 <span class="arithmatex">\(g\)</span>，只需要枚举可能的正整数，并逐个判断它是否为原根即可．枚举时，通常有两种处理方式：从小到大逐一枚举、随机生成一些正整数．这两种枚举方式的实际效率相当．</p>
<p>从小到大逐一枚举时，得到的是模 <span class="arithmatex">\(m\)</span> 的最小原根 <span class="arithmatex">\(g_m\)</span>，因此，枚举部分的复杂度取决于 <span class="arithmatex">\(g_m\)</span> 的大小．对此，有如下估计：</p>
<ul>
<li>上界的估计：王元<sup id="fnref:yuan1959note"><a class="footnote-ref" href="#fn:yuan1959note">1</a></sup>和 Burgess<sup id="fnref:burgess1962character"><a class="footnote-ref" href="#fn:burgess1962character">2</a></sup>证明了素数 <span class="arithmatex">\(p\)</span> 的最小原根 <span class="arithmatex">\(g_p=O\left(p^{0.25+\epsilon}\right)\)</span>，其中 <span class="arithmatex">\(\epsilon&gt;0\)</span>．Cohen, Odoni, and Stothers<sup id="fnref:cohen1974least"><a class="footnote-ref" href="#fn:cohen1974least">3</a></sup>和 Elliott and Murata<sup id="fnref:elliott1998least"><a class="footnote-ref" href="#fn:elliott1998least">4</a></sup>分别证明了该估计对于模数 <span class="arithmatex">\(p^2\)</span> 和 <span class="arithmatex">\(2p^2\)</span> 也成立，其中，<span class="arithmatex">\(p\)</span> 是奇素数．由于对于 <span class="arithmatex">\(e&gt;2\)</span>，模 <span class="arithmatex">\(p^2\)</span>（或 <span class="arithmatex">\(2p^2\)</span>）的原根也是模 <span class="arithmatex">\(p^e\)</span>（或 <span class="arithmatex">\(2p^e\)</span>）的原根，所以，最小原根的上界 <span class="arithmatex">\(O\left(p^{0.25+\epsilon}\right)\)</span> 对于所有情形都成立．</li>
<li>下界的估计：Fridlander<sup id="fnref:fridlender1949least"><a class="footnote-ref" href="#fn:fridlender1949least">5</a></sup>和 Salié<sup id="fnref:salie1949kleinsten"><a class="footnote-ref" href="#fn:salie1949kleinsten">6</a></sup>证明了存在 <span class="arithmatex">\(C&gt;0\)</span>，使得对于无穷多素数 <span class="arithmatex">\(p\)</span>，都有最小原根 <span class="arithmatex">\(g_p &gt; C\log p\)</span> 成立．</li>
<li>平均情形的估计：Burgess and Elliott<sup id="fnref:burgess1968average"><a class="footnote-ref" href="#fn:burgess1968average">7</a></sup>证明了平均情形下素数 <span class="arithmatex">\(p\)</span> 的最小原根 <span class="arithmatex">\(g_p=O((\log p)^2(\log\log p)^4)\)</span>．Elliott and Murata<sup id="fnref:elliott1997average"><a class="footnote-ref" href="#fn:elliott1997average">8</a></sup>进一步猜想素数 <span class="arithmatex">\(p\)</span> 的最小原根的平均值是一个常数，且通过数值验证<sup id="fnref:more-evidence"><a class="footnote-ref" href="#fn:more-evidence">9</a></sup>得到它大概为 <span class="arithmatex">\(4.926\)</span>．随后，Elliott and Murata<sup id="fnref2:elliott1998least"><a class="footnote-ref" href="#fn:elliott1998least">4</a></sup>将这一猜想推广到模 <span class="arithmatex">\(2p^2\)</span> 的情形．</li>
</ul>
<p>根据这些分析，暴力寻找最小原根时，枚举部分的复杂度 <span class="arithmatex">\(O(g_m(\log m)^2)\)</span> 是可以接受的．</p>
<p>除了从小到大枚举外，还可以通过随机生成正整数并验证的方法寻找原根．原根的密度并不低：<sup id="fnref:density-prim-root"><a class="footnote-ref" href="#fn:density-prim-root">10</a></sup></p>
<div class="arithmatex">\[
\dfrac{\varphi(\varphi(m))}{m} = \Omega\left(\dfrac{1}{\log\log m}\right).
\]</div>
<p>所以，通过随机方法寻找原根时，枚举部分的期望复杂度为 <span class="arithmatex">\(O((\log m)^2\log\log m)\)</span>．</p>
<p>需要注意的是，判定原根时需要已知 <span class="arithmatex">\(\varphi(m)\)</span> 的质因数分解．算法竞赛 <a href="../pollard-rho/">常用质因数分解算法</a> 中，复杂度最优的 Pollard Rho 算法也需要 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span> 的时间．因此，只要 <span class="arithmatex">\(\varphi(m)\)</span> 的质因数分解是未知的，无论采用哪种枚举方式，求原根的复杂度瓶颈都在于质因数分解这一步，而非枚举验证的部分．</p>
<h2 id="carmichael-函数">Carmichael 函数<a class="headerlink" href="#carmichael-函数" title="Permanent link"></a></h2>
<p>相对于模 <span class="arithmatex">\(m\)</span> 元素的阶这一局部概念，Carmichael 函数是一个全局概念．它是所有与 <span class="arithmatex">\(m\)</span> 互素的整数的幂次的最小公共循环节．</p>
<details class="abstract" open="open">
<summary>Carmichael 函数</summary>
<p>对于 <span class="arithmatex">\(m\in\mathbf N_+\)</span>，定义 <span class="arithmatex">\(\lambda(m)\)</span> 为能够使得同余关系 <span class="arithmatex">\(a^n\equiv 1\pmod m\)</span> 对于所有 <span class="arithmatex">\(a\perp m\)</span> 都成立的最小正整数 <span class="arithmatex">\(n\)</span>．函数 <span class="arithmatex">\(\lambda:\mathbf N_+\to\mathbf N_+\)</span> 就称为 <strong>Carmichael 函数</strong>．</p>
</details>
<p>根据 <a href="#ord-prop-2">性质 2</a>，能够使得 <span class="arithmatex">\(a^n\equiv 1\pmod m\)</span> 对于所有 <span class="arithmatex">\(a\perp m\)</span> 都成立，意味着 <span class="arithmatex">\(\delta_m(a)\mid n\)</span> 对于所有 <span class="arithmatex">\(a\perp m\)</span> 都成立．也就是说，符合这一条件的正整数 <span class="arithmatex">\(n\)</span>，一定是全体 <span class="arithmatex">\(\delta_m(a)\)</span> 的公倍数．因此，最小的这样的 <span class="arithmatex">\(n\)</span> 就是它们的最小公倍数：</p>
<div class="arithmatex">\[
\lambda(m) = \operatorname{lcm}\{\delta_m(a) : a\perp m\}.
\]</div>
<p>这也常用作 Carmichael 函数的等价定义．</p>
<p>反复应用 <a href="#ord-prop-5">性质 5</a> 可知，一定存在某个元素 <span class="arithmatex">\(a\perp m\)</span> 使得 <span class="arithmatex">\(\delta_m(a)=\lambda(m)\)</span>．因此，上式也可以写作</p>
<div class="arithmatex">\[
\lambda(m) = \max\{\delta_m(a) : a\perp m\}.
\]</div>
<p>取得这一最值的元素 <span class="arithmatex">\(a\perp m\)</span> 也称为模 <span class="arithmatex">\(m\)</span> 的 <strong><span class="arithmatex">\(\lambda\)</span>‑原根</strong>．它对于所有模数 <span class="arithmatex">\(m\)</span> 都存在．</p>
<h3 id="递推公式">递推公式<a class="headerlink" href="#递推公式" title="Permanent link"></a></h3>
<p>Carmichael 函数是一个 <a href="../basic/#数论函数">数论函数</a>．本节讨论它的一个递推公式，并由此给出原根存在定理的另一个证明．</p>
<p>虽然不是积性函数，但是计算 Carmichael 函数时，同样可以对互素的因子分别处理．</p>
<details class="note" open="open">
<summary>引理</summary>
<p>对于互素的正整数 <span class="arithmatex">\(m_1,m_2\)</span>，有 <span class="arithmatex">\(\lambda(m_1m_2)=[\lambda(m_1),\lambda(m_2)]\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>设 <span class="arithmatex">\(a_1\)</span> 和 <span class="arithmatex">\(a_2\)</span> 分别为模 <span class="arithmatex">\(m_1\)</span> 和模 <span class="arithmatex">\(m_2\)</span> 的 <span class="arithmatex">\(\lambda\)</span>‑原根．令 <span class="arithmatex">\(m=m_1m_2\)</span>，由 <a href="../crt/">中国剩余定理</a> 可知，存在 <span class="arithmatex">\(a\perp m\)</span> 使得 <span class="arithmatex">\(a\equiv a_i\pmod{m_i}\)</span> 对于 <span class="arithmatex">\(i=1,2\)</span> 都成立．由于 <span class="arithmatex">\(a^{\lambda(m)}\equiv 1\pmod m\)</span>，所以对于 <span class="arithmatex">\(i=1,2\)</span>，都有 <span class="arithmatex">\(a_i^{\lambda(m)} \equiv 1\pmod{m_i}\)</span>，进而由 <a href="#ord-prop-2">性质 2</a> 和 <span class="arithmatex">\(a_i\)</span> 的选取可知，<span class="arithmatex">\(\lambda(m_i)=\delta_{m_i}(a_i)\mid \lambda(m)\)</span>．这就说明 <span class="arithmatex">\([\lambda(m_1),\lambda(m_2)]\mid\lambda(m)\)</span>．</p>
<p>反过来，对于任意 <span class="arithmatex">\(a\perp m\)</span> 和 <span class="arithmatex">\(i=1,2\)</span>，都有 <span class="arithmatex">\(a^{[\lambda(m_1),\lambda(m_2)]} \equiv 1 \pmod{m_i}\)</span>．应用中国剩余定理，就得到 <span class="arithmatex">\(a^{[\lambda(m_1),\lambda(m_2)]} \equiv 1 \pmod{m}\)</span> 对于所有 <span class="arithmatex">\(a\perp m\)</span> 都成立．根据 Carmichael 函数的定义可知，<span class="arithmatex">\(\lambda(m)\mid [\lambda(m_1),\lambda(m_2)]\)</span>．</p>
<p>由此，命题中的等式成立．</p>
</details>
<p>因此，接下来只要计算 Carmichael 函数在素数幂处的取值．首先，处理 <span class="arithmatex">\(2\)</span> 的幂次的情形．</p>
<details class="note" open="open">
<summary>引理</summary>
<p>对于 <span class="arithmatex">\(m=2^e\)</span> 且 <span class="arithmatex">\(e\in\mathbf N_+\)</span>，有 <span class="arithmatex">\(\lambda(2)=1\)</span>，<span class="arithmatex">\(\lambda(4)=2\)</span>，且对于 <span class="arithmatex">\(e\ge 3\)</span> 都有 <span class="arithmatex">\(\lambda(m)=2^{e-2}\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>对于 <span class="arithmatex">\(m=2,4\)</span> 的情形，单独讨论即可．对于 <span class="arithmatex">\(m=2^e\)</span> 且 <span class="arithmatex">\(e\ge 3\)</span> 的情形，首先重复前文 <a href="#prim-root-lem-4">引理 4</a> 的证明的第一部分，就得到 <span class="arithmatex">\(\lambda(m)\le 2^{e-2}\)</span>．进而，只需要证明存在 <span class="arithmatex">\(2^{e-2}\)</span> 阶元素即可．为此，有</p>
<div class="arithmatex">\[
5^{2^{e-3}} = (1 + 2^2)^{2^{e-3}} = 1 + 2^2\times 2^{e-3} = 1 + 2^{e-1} \not\equiv 1 \pmod{2^e}.
\]</div>
<p>这说明 <span class="arithmatex">\(\delta_m(5)\nmid 2^{e-3}\)</span>，又因为 <span class="arithmatex">\(\delta_m(5) \mid 2^{e-2}\)</span>，所以，<span class="arithmatex">\(5\)</span> 只能是 <span class="arithmatex">\(2^{e-2}\)</span> 阶元素．这就说明，<span class="arithmatex">\(\lambda(m)=2^{e-2}\)</span>．</p>
</details>
<p>在这个引理的证明过程中，实际上得到了关于模 <span class="arithmatex">\(2^e\)</span> 既约剩余系结构的刻画：</p>
<p><a id="mod-pow-2"></a></p>
<details class="note" open="open">
<summary>推论</summary>
<p>设模数为 <span class="arithmatex">\(2^e\)</span> 且 <span class="arithmatex">\(e \ge 2\)</span>．那么，所有奇数都同余于唯一一个 <span class="arithmatex">\(\pm 5^k\)</span> 形式的整数同余，其中，<span class="arithmatex">\(k\in\mathbf N\)</span> 且 <span class="arithmatex">\(k &lt; 2^{e-2}\)</span>．也就是说，<span class="arithmatex">\(\pm 1,\pm 5,\cdots,\pm 5^{2^{e-2}-1}\)</span> 两两不同余，且构成一个既约剩余系．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>容易验证，<span class="arithmatex">\(e=2\)</span> 的情形成立．对于 <span class="arithmatex">\(e \ge 3\)</span> 的情形，由于前述证明中已经得到 <span class="arithmatex">\(5\)</span> 模 <span class="arithmatex">\(2^e\)</span> 的阶是 <span class="arithmatex">\(2^{e-2}\)</span>，所以，<span class="arithmatex">\(1,5,\cdots,5^{2^{e-2}-1}\)</span> 两两不同余．因为这些整数都模 <span class="arithmatex">\(4\)</span> 余 <span class="arithmatex">\(1\)</span>，它们的相反数都模 <span class="arithmatex">\(4\)</span> 余 <span class="arithmatex">\(3\)</span>，所以 <span class="arithmatex">\(\pm 1,\pm 5,\cdots,\pm 5^{2^{e-2}-1}\)</span> 模 <span class="arithmatex">\(2^e\)</span> 两两不同余．由于它们共计 <span class="arithmatex">\(2^{e-1}\)</span> 个，恰为模 <span class="arithmatex">\(2^{e}\)</span> 的既约剩余系的大小，所以，它们就构成了既约剩余系本身．</p>
</details>
<p>然后，处理奇素数幂的情形．</p>
<details class="note" open="open">
<summary>引理</summary>
<p>对于 <span class="arithmatex">\(m=p^e\)</span>，其中，<span class="arithmatex">\(p\)</span> 是奇素数且 <span class="arithmatex">\(e\in\mathbf N_+\)</span>，有 <span class="arithmatex">\(\lambda(m)=p^{e-1}(p-1)\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>首先证明命题对于 <span class="arithmatex">\(e=1\)</span>，即 <span class="arithmatex">\(m=p\)</span> 是奇素数的情形成立．为此，由 Carmichael 函数的定义可知，与 <span class="arithmatex">\(p\)</span> 互素的所有整数 <span class="arithmatex">\(a\)</span> 都是同余方程 <span class="arithmatex">\(x^{\lambda(p)}\equiv 1\pmod{p}\)</span> 的解．在模 <span class="arithmatex">\(p\)</span> 的意义下，该方程共有 <span class="arithmatex">\(p-1\)</span> 个互不相同的解．根据 <a href="../congruence-equation/#定理-3lagrange-定理">Lagrange 定理</a> 可知，<span class="arithmatex">\(p-1\le\lambda(p)\)</span>．同时，欧拉定理要求，<span class="arithmatex">\(\lambda(p)\mid\varphi(p)=p-1\)</span>．因此，<span class="arithmatex">\(\lambda(p)=p-1\)</span>．</p>
<p>对于 <span class="arithmatex">\(m=p^e\)</span> 且 <span class="arithmatex">\(e&gt; 1\)</span> 的情形，可以从证明 <span class="arithmatex">\(1+p\)</span> 是 <span class="arithmatex">\(p^{e-1}\)</span> 阶元开始．为此，有</p>
<div class="arithmatex">\[
(1+p)^{p^{e-1}} \equiv 1,\quad (1+p)^{p^{e-2}} \equiv 1 + p^{e-1} \not\equiv 1 \pmod{p^e}.
\]</div>
<p>所以，<span class="arithmatex">\(\delta_m(1+p)=p^{e-1}\)</span>．另外，设模 <span class="arithmatex">\(p\)</span> 的原根为 <span class="arithmatex">\(g\)</span>，那么，由于 <span class="arithmatex">\(g^{\delta_m(g)}\equiv 1 \pmod{p}\)</span>，所以，由阶的 <a href="#ord-prop-2">性质 2</a> 可知，<span class="arithmatex">\(p-1\mid\delta_m(p)\)</span>．由 Carmichael 函数的定义和欧拉定理可知</p>
<div class="arithmatex">\[
p^{e-1}(p-1) = [\delta_m(p),p^{e-1}]\mid\lambda(m) \mid \varphi(m) = p^{e-1}(p-1).
\]</div>
<p>因此，<span class="arithmatex">\(\lambda(m)=p^{e-1}(p-1)\)</span>．</p>
</details>
<p>将本节的结果简单归纳，就得到 Carmichael 函数的递推公式：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于任意正整数 <span class="arithmatex">\(m\)</span>，有</p>
<div class="arithmatex">\[
\lambda(m) = \begin{cases}
\varphi(m), &amp; \text{if }m=1,2,4,p^e\text{ for odd prime }p\text{ and }e \ge 1,\\
\frac{1}{2}\varphi(m), &amp;\text{if }m=2^e,~e\ge 3,\\
\operatorname{lcm}\{\lambda(p_1^{e_1}),\lambda(p_2^{e_2}),\cdots,\lambda(p_s^{e_s})\}, &amp;\text{if }m = p_1^{e_1}p_2^{e_2}\cdots p_s^{e_s}\text{ for distinct }p_1,p_2,\cdots,p_s.
\end{cases}
\]</div>
</details>
<p>利用该递推公式可以加强前文的结果：</p>
<details class="note" open="open">
<summary>推论</summary>
<p>对于正整数 <span class="arithmatex">\(m_1,m_2\)</span>，有 <span class="arithmatex">\(\lambda([m_1,m_2])=[\lambda(m_1),\lambda(m_2)]\)</span>．</p>
</details>
<p>比较原根和 Carmichael 函数的定义可知，模 <span class="arithmatex">\(m\)</span> 的原根存在，当且仅当 <span class="arithmatex">\(\lambda(m)=\varphi(m)\)</span>．从 Carmichael 函数的递推公式中，容易归纳出如下结果：</p>
<details class="note" open="open">
<summary>推论</summary>
<p>模 <span class="arithmatex">\(m\)</span> 的原根存在，当且仅当 <span class="arithmatex">\(m=1,2,4,p^e,2p^e\)</span>，其中，<span class="arithmatex">\(p\)</span> 是奇素数且 <span class="arithmatex">\(e\in\mathbf N_+\)</span>．</p>
</details>
<p>由于本节对于递推公式的证明并没有用到原根存在定理，因此，这就构成了对该定理的又一个证明．</p>
<h3 id="carmichael-数">Carmichael 数<a class="headerlink" href="#carmichael-数" title="Permanent link"></a></h3>
<p>利用 Carmichael 函数，可以讨论 Carmichael 数（卡迈克尔数，OEIS:<a href="https://oeis.org/A002997">A002997</a>）的性质与分布．这是 <a href="../prime/#fermat-素性测试">Fermat 素性测试</a> 一定无法正确排除的合数．</p>
<details class="abstract" open="open">
<summary>Carmichael 数</summary>
<p>对于合数 <span class="arithmatex">\(n\)</span>，如果对于所有整数 <span class="arithmatex">\(a\perp n\)</span> 都有同余式 <span class="arithmatex">\(a^{n-1} \equiv 1 \pmod n\)</span> 成立，就称 <span class="arithmatex">\(n\)</span> 为 <strong>Carmichael 数</strong>．</p>
</details>
<p>最小的 Carmichael 数是 <span class="arithmatex">\(561 = 3 \times 11 \times 17\)</span>．</p>
<p>由 Carmichael 函数的定义可知，合数 <span class="arithmatex">\(n\)</span> 是 Carmichael 数当且仅当 <span class="arithmatex">\(\lambda(n)\mid n-1\)</span>，其中 <span class="arithmatex">\(\lambda(n)\)</span> 为 Carmichael 函数．进一步地，可以得到如下判断合数 <span class="arithmatex">\(n\)</span> 是否为 Carmichael 数的方法：</p>
<details class="note" open="open">
<summary>Korselt 判别法<sup id="fnref:korselt1899probleme"><a class="footnote-ref" href="#fn:korselt1899probleme">11</a></sup></summary>
<p>合数 <span class="arithmatex">\(n\)</span> 是 Carmichael 数当且仅当 <span class="arithmatex">\(n\)</span> 无平方因子且对 <span class="arithmatex">\(n\)</span> 的任意质因子 <span class="arithmatex">\(p\)</span> 均有 <span class="arithmatex">\((p-1) \mid (n-1)\)</span>．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>首先证明条件的必要性．假设 <span class="arithmatex">\(\lambda(n)\mid (n-1)\)</span>．检查 Carmichael 函数的递推公式可知，如果 <span class="arithmatex">\(n\)</span> 有平方因子 <span class="arithmatex">\(p\)</span>，那么，一定有 <span class="arithmatex">\(p\mid \lambda(n)\)</span>．但是 <span class="arithmatex">\(p\nmid (n-1)\)</span>，矛盾．同理，Carmichael 函数的递推公式说明，<span class="arithmatex">\((p-1)\mid \lambda(n)\)</span>，所以，也有 <span class="arithmatex">\((p-1) \mid (n-1)\)</span>．</p>
<p>然后证明条件的充分性．因为 <span class="arithmatex">\(n\)</span> 是合数，所以它一定有奇素因子 <span class="arithmatex">\(p\)</span>，因此 <span class="arithmatex">\(n-1\)</span> 是偶数，<span class="arithmatex">\(n\)</span> 也就一定是奇数．对于无平方因子的奇合数 <span class="arithmatex">\(n\)</span>，由 Carmichael 函数的递推公式可知，<span class="arithmatex">\(\lambda(n)=\operatorname{lcm}\{p-1:p\mid n\}\)</span>．因此，只要 <span class="arithmatex">\((p-1) \mid (n-1)\)</span> 对于所有素因子 <span class="arithmatex">\(p\)</span> 都成立，就一定有 <span class="arithmatex">\(\lambda(n)\mid (n-1)\)</span>．</p>
</details>
<p>从这一判别法出发，可以建立 Carmichael 数的一些简单性质：</p>
<details class="note" open="open">
<summary>推论</summary>
<p>Carmichael 数是奇数，没有平方因子，而且至少有 <span class="arithmatex">\(3\)</span> 个不同的素因子．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>前两条性质可以直接从 Korselt 判别法及其证明中得到．要得到第三条性质，只需要再证明：互异素数 <span class="arithmatex">\(p_1,p_2\)</span> 的乘积 <span class="arithmatex">\(n=p_1p_2\)</span> 一定不是 Carmichael 数．假设 <span class="arithmatex">\(n=p_1p_2\)</span> 是 Carmichael 数．由 Korselt 判别法可知，<span class="arithmatex">\((p_i-1)\mid (n-1)\)</span>．但是，有</p>
<div class="arithmatex">\[
n-1=p_1p_2-1\equiv p_2-1 \pmod{p_1-1}.
\]</div>
<p>因此，<span class="arithmatex">\((p_1-1)\mid(p_2-1)\)</span>．同理，<span class="arithmatex">\((p_2-1)\mid(p_1-1)\)</span>．也就是说，<span class="arithmatex">\(p_1=p_2\)</span>．这与假设矛盾．因此，Carmichael 数 <span class="arithmatex">\(n\)</span> 至少有 <span class="arithmatex">\(3\)</span> 个互异素因子．</p>
</details>
<p>利用解析数论还可以得到 Carmichael 数分布的一些性质．设 <span class="arithmatex">\(C(n)\)</span> 为小于等于 <span class="arithmatex">\(n\)</span> 的 Carmichael 数个数．Alford, Granville, and Pomerance<sup id="fnref:alford1994infinitely"><a class="footnote-ref" href="#fn:alford1994infinitely">12</a></sup>证明，对于充分大的 <span class="arithmatex">\(n\)</span>，有 <span class="arithmatex">\(C(n)&gt;n^{2/7}\)</span>．由此，Carmichael 数有无限多个．在这之前，Erdős<sup id="fnref:erdos1956pseudoprimes"><a class="footnote-ref" href="#fn:erdos1956pseudoprimes">13</a></sup>已经证明，<span class="arithmatex">\(C(n) &lt; n\exp\left(-c\dfrac{\ln n\ln\ln\ln n}{\ln\ln n}\right)\)</span>，其中 <span class="arithmatex">\(c\)</span> 为常数．因此，Carmichael 数的分布（相对于素数来说）十分稀疏．实际上，有<sup id="fnref:pinchcarmichael"><a class="footnote-ref" href="#fn:pinchcarmichael">14</a></sup> <span class="arithmatex">\(C(10^9)=646\)</span>，<span class="arithmatex">\(C(10^{18})=1~401~644\)</span>．</p>
<h2 id="参考资料与注释">参考资料与注释<a class="headerlink" href="#参考资料与注释" title="Permanent link"></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Primitive_root_modulo_n">Primitive root modulo n - Wikipedia</a></li>
<li><a href="https://crypto.stanford.edu/pbc/notes/numbertheory/order.html">The order of a unit - Course Notes</a></li>
<li><a href="http://witno.com/philadelphia/notes/won5.pdf">The primitive root theorem - Amin Witno's notes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael function - Wikipedia</a></li>
<li><a href="https://brilliant.org/wiki/carmichaels-lambda-function/">Carmichael's Lambda Function - Brilliant Math &amp; Science Wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/Carmichael_number">Carmichael number - Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/CarmichaelNumber.html">Carmichael Number - Wolfram MathWorld</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:yuan1959note">
<p>Wang Y. "On the least primitive root of a prime." (in Chinese). Acta Math Sinica, 1959, 4: 432–441; English transl. in<em>Sci. Sinica</em>, 1961, 10: 1–14.&#160;<a class="footnote-backref" href="#fnref:yuan1959note" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:burgess1962character">
<p>BURGESS, David A. "On character sums and primitive roots." Proceedings of the London Mathematical Society, 1962, 3.1: 179-192.&#160;<a class="footnote-backref" href="#fnref:burgess1962character" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:cohen1974least">
<p>Cohen, S. D., R. W. K. Odoni, and W. W. Stothers. "On the least primitive root modulo p 2." Bulletin of the London Mathematical Society 6, no. 1 (1974): 42-46.&#160;<a class="footnote-backref" href="#fnref:cohen1974least" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:elliott1998least">
<p>Elliott, P. D. T. A., and L. Murata. "The least primitive root mod 2p2." Mathematika 45, no. 2 (1998): 371-379.&#160;<a class="footnote-backref" href="#fnref:elliott1998least" title="Jump back to footnote 4 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:elliott1998least" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:fridlender1949least">
<p>FRIDLENDER, V. R. "On the least n-th power non-residue." Dokl. Akad. Nauk SSSR. 1949. p. 351-352.&#160;<a class="footnote-backref" href="#fnref:fridlender1949least" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:salie1949kleinsten">
<p>SALIÉ, Hans. "Über den kleinsten positiven quadratischen Nichtrest nach einer Primzahl." Mathematische Nachrichten, 1949, 3.1: 7-8.&#160;<a class="footnote-backref" href="#fnref:salie1949kleinsten" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:burgess1968average">
<p>Burgess, D. A., and P. D. T. A. Elliott. "The average of the least primitive root." Mathematika 15, no. 1 (1968): 39-50.&#160;<a class="footnote-backref" href="#fnref:burgess1968average" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:elliott1997average">
<p>Elliott, Peter DTA, and Leo Murata. "On the average of the least primitive root modulo p." Journal of The london Mathematical Society 56, no. 3 (1997): 435-454.&#160;<a class="footnote-backref" href="#fnref:elliott1997average" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:more-evidence">
<p>更多结果可以参考 <a href="https://sweet.ua.pt/tos/p_roots.html">Least prime primitive root of prime numbers</a>．&#160;<a class="footnote-backref" href="#fnref:more-evidence" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:density-prim-root">
<p>如果模 <span class="arithmatex">\(m\)</span> 的原根存在，那么，<span class="arithmatex">\(\varphi(m)\ge\dfrac{1}{3}m\)</span>，且等号仅在 <span class="arithmatex">\(m=2\times 3^e~(e\in\mathbf N_+)\)</span> 处取得．进一步地，当 <span class="arithmatex">\(m &gt; 2\)</span> 时，对欧拉函数 <span class="arithmatex">\(\varphi(m)\)</span> 有估计：<span class="arithmatex">\(\varphi(m)&gt;\dfrac{m}{e^{\gamma}\log\log m+\frac{3}{\log\log m}}\)</span>．将这两者结合，就得到文中的表达式．关于欧拉函数的该估计，可以参考论文 Rosser, J. Barkley, and Lowell Schoenfeld. "Approximate formulas for some functions of prime numbers." Illinois Journal of Mathematics 6, no. 1 (1962): 64-94．&#160;<a class="footnote-backref" href="#fnref:density-prim-root" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:korselt1899probleme">
<p>Korselt, A. R. (1899). "Problème chinois." L'Intermédiaire des Mathématiciens. 6: 142–143.&#160;<a class="footnote-backref" href="#fnref:korselt1899probleme" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:alford1994infinitely">
<p>W. R. Alford; Andrew Granville; Carl Pomerance (1994). "There are Infinitely Many Carmichael Numbers." Annals of Mathematics. 140 (3): 703–722.&#160;<a class="footnote-backref" href="#fnref:alford1994infinitely" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:erdos1956pseudoprimes">
<p>Erdős, P. (1956). "On pseudoprimes and Carmichael numbers." Publ. Math. Debrecen. 4 (3–4): 201–206.&#160;<a class="footnote-backref" href="#fnref:erdos1956pseudoprimes" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:pinchcarmichael">
<p>PINCH, Richard GE. The Carmichael numbers up to <span class="arithmatex">\({10}^{20}\)</span>.&#160;<a class="footnote-backref" href="#fnref:pinchcarmichael" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
</ol>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../_static/js/math-csr.js?math-csr"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>