
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Residue - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#高次剩余" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Residue
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/am-gm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/cauchy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    柯西不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#高次剩余" class="md-nav__link">
    <span class="md-ellipsis">
      
        高次剩余
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="高次剩余">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#性质" class="md-nav__link">
    <span class="md-ellipsis">
      
        性质
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#单位根" class="md-nav__link">
    <span class="md-ellipsis">
      
        单位根
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="单位根">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#性质_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        性质
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#模意义下开方" class="md-nav__link">
    <span class="md-ellipsis">
      
        模意义下开方
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="模意义下开方">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#朴素算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        朴素算法
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#改良-tonellishanks-算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        改良 Tonelli–Shanks 算法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="改良 Tonelli–Shanks 算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#过程" class="md-nav__link">
    <span class="md-ellipsis">
      
        过程
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#时间复杂度" class="md-nav__link">
    <span class="md-ellipsis">
      
        时间复杂度
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#一般情形的处理" class="md-nav__link">
    <span class="md-ellipsis">
      
        一般情形的处理
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#参考资料与注释" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Residue</h1>

<p>前置知识：<a href="../discrete-logarithm/">离散对数</a></p>
<p>本文讨论模意义下的高次剩余和单位根，并介绍模意义下开方运算的算法．</p>
<h2 id="高次剩余">高次剩余<a class="headerlink" href="#高次剩余" title="Permanent link"></a></h2>
<p>模运算下的高次剩余，可以认为是在讨论模意义下开高次方的可行性．它是 <a href="../quad-residue/">二次剩余</a> 的推广．</p>
<details class="abstract" open="open">
<summary><span class="arithmatex">\(k\)</span> 次剩余</summary>
<p>令整数 <span class="arithmatex">\(k\geq 2\)</span>，整数 <span class="arithmatex">\(a\)</span> 和正整数 <span class="arithmatex">\(m\)</span> 互素．若存在整数 <span class="arithmatex">\(x\)</span> 使得</p>
<div class="arithmatex">\[
x^k\equiv a\pmod m,
\]</div>
<p>则称 <span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <strong><span class="arithmatex">\(k\)</span> 次剩余</strong>（<span class="arithmatex">\(k\)</span>-th residue），<span class="arithmatex">\(x\)</span> 为 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <strong><span class="arithmatex">\(k\)</span> 次方根</strong>（<span class="arithmatex">\(k\)</span>-th root）；否则称 <span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <strong><span class="arithmatex">\(k\)</span> 次非剩余</strong>（<span class="arithmatex">\(k\)</span>-th nonresidue）．</p>
</details>
<p>也就是说，<span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根存在，当且仅当 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余．</p>
<h3 id="性质">性质<a class="headerlink" href="#性质" title="Permanent link"></a></h3>
<p>类似二次剩余，可以讨论 <span class="arithmatex">\(k\)</span> 次剩余的判定、个数以及 <span class="arithmatex">\(k\)</span> 次剩余类的个数问题．和其他 <a href="../congruence-equation/">同余方程</a> 问题一样，可以通过 <a href="../crt/">中国剩余定理</a> 将它们转化为素数幂模的情形．根据原根的有无，这进一步区分为奇素数幂模和模数为 <span class="arithmatex">\(2\)</span> 的幂次的情形．</p>
<p>奇数幂模的情形较为简单．事实上，对于所有原根存在的情形，都有如下结论：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>设整数 <span class="arithmatex">\(k\geq 2\)</span>，整数 <span class="arithmatex">\(a\)</span> 和正整数 <span class="arithmatex">\(m\)</span> 互素．设模 <span class="arithmatex">\(m\)</span> 的原根存在，且 <span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(m\)</span> 的一个原根．记 <span class="arithmatex">\(d=\gcd(k,\varphi(m))\)</span> 且 <span class="arithmatex">\(d'=\dfrac{\varphi(m)}{d}\)</span>，其中，<span class="arithmatex">\(\varphi(m)\)</span> 是 <a href="../euler-totient/">欧拉函数</a>．那么，有：</p>
<ol>
<li>
<p><span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余，当且仅当</p>
<div class="arithmatex">\[
a^{d'} \equiv 1 \pmod m.
\]</div>
</li>
<li>
<p>当 <span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余时，同余意义下，<span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 恰有 <span class="arithmatex">\(d\)</span> 个互不相同的 <span class="arithmatex">\(k\)</span> 次方根，且它们具有形式</p>
<div class="arithmatex">\[
x \equiv g^{y_0+id'}\pmod{\varphi(m)},~0\le y_0 &lt; d',~i=0,1,\cdots,d-1.
\]</div>
</li>
<li>
<p>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余类的个数为 <span class="arithmatex">\(d'\)</span>，且它们的全体就是</p>
<div class="arithmatex">\[
\{g^{di}\bmod m : 0 \le i &lt; d'\}.
\]</div>
</li>
</ol>
</details>
<details class="note">
<summary>证明</summary>
<p>因为 <span class="arithmatex">\(a\perp m\)</span>，所以 <span class="arithmatex">\(x\perp m\)</span>．因为 <span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(m\)</span> 的原根，所以，<span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(a\)</span> 均与某个 <span class="arithmatex">\(g\)</span> 的幂次同余．设 <span class="arithmatex">\(x\equiv g^y\pmod m\)</span>，方程 <span class="arithmatex">\(x^k\equiv a\pmod m\)</span> 就等价于</p>
<div class="arithmatex">\[
g^{ky} \equiv g^{\operatorname{ind}_g a}\pmod m.
\]</div>
<p>其中，<span class="arithmatex">\(\operatorname{ind}_g a\)</span> 是离散对数．根据 <a href="../primitive-root/#幂的循环结构">阶的性质</a> 和 <span class="arithmatex">\(\delta_m(g)=\varphi(m)\)</span>，这等价于同余方程</p>
<div class="arithmatex">\[
ky \equiv \operatorname{ind}_g a \pmod{\varphi(m)}.
\]</div>
<p>这是关于 <span class="arithmatex">\(y\)</span> 的 <a href="../linear-equation/">线性同余方程</a>．应用该页面对其解结构的分析，就可以知道方程有解当且仅当 <span class="arithmatex">\(d\mid\operatorname{ind}_g a\)</span>，且通解形式为</p>
<div class="arithmatex">\[
y = y_0 + id' \pmod{\varphi(m)},~0\le y_0 &lt; d',~i=0,1,\cdots,d-1.
\]</div>
<p>由此，就几乎可以得到本定理的全部内容；唯一需要额外说明的是判别式 <span class="arithmatex">\(a^{d'} \equiv 1 \pmod m\)</span>．由 <a href="../primitive-root/#ord-prop-3">阶的性质 3</a> 可知</p>
<div class="arithmatex">\[
\delta_m(a) = \delta_m(g^{\operatorname{ind}_g a}) = \dfrac{\varphi(m)}{\gcd(\varphi(m),\operatorname{ind}_g a)} = \dfrac{\varphi(m)}{\operatorname{ind}_g a}.
\]</div>
<p>又已知方程有解当且仅当 <span class="arithmatex">\(d\mid \operatorname{ind}_g a\)</span>，亦即 <span class="arithmatex">\(\delta_m(a)\mid d'\)</span>．由 <a href="../primitive-root/#ord-prop-2">阶的性质 2</a> 可知，这就等价于该判别式．</p>
</details>
<p>模数为 <span class="arithmatex">\(2\)</span> 的幂次的情形较为特殊．为处理这种情形，需要用到关于模 <span class="arithmatex">\(2^e\)</span> 既约剩余系结构的一个 <a href="../primitive-root/#mod-pow-2">结论</a>：所有奇数 <span class="arithmatex">\(a\)</span> 都唯一地同余于某个 <span class="arithmatex">\((-1)^s5^r\bmod 2^e\)</span> 形式的整数，其中，<span class="arithmatex">\(s\in\{0,1\}\)</span> 且 <span class="arithmatex">\(0\le r &lt; 2^{e-2}\)</span>．借助这一结果，可以得到如下结论：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>设整数 <span class="arithmatex">\(k\ge 2\)</span>，奇数 <span class="arithmatex">\(a\)</span> 和正整数 <span class="arithmatex">\(m=2^e\)</span> 且 <span class="arithmatex">\(e \ge 2\)</span>．那么，当 <span class="arithmatex">\(k\)</span> 是奇数时，有：</p>
<ol>
<li><span class="arithmatex">\(a\)</span> 恒为模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余．</li>
<li><span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根有且仅有一个．</li>
<li>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余类个数为 <span class="arithmatex">\(2^{e-1}\)</span>，且它们就是全体既约剩余类．</li>
</ol>
<p>当 <span class="arithmatex">\(k\)</span> 是偶数时，记 <span class="arithmatex">\(d=\gcd(k,2^{e-2})\)</span> 且 <span class="arithmatex">\(d'=\dfrac{2^{e-2}}{d}\)</span>，有：</p>
<ol>
<li><span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余，当且仅当 <span class="arithmatex">\(a\equiv 1\pmod 4\)</span> 且 <span class="arithmatex">\(a^{d'}\equiv 1\pmod m\)</span>．</li>
<li>
<p>当 <span class="arithmatex">\(a\)</span> 为模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余时，同余意义下，<span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 恰有 <span class="arithmatex">\(2d\)</span> 个互不相同的 <span class="arithmatex">\(k\)</span> 次方根，且它们具有形式</p>
<div class="arithmatex">\[
x \equiv \pm 5^{y_0 + id'} \pmod{2^{e-1}},~ 0 \le y_0 &lt; d',~i = 0, 1,\cdots,d-1. 
\]</div>
</li>
<li>
<p>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次剩余类的个数为 <span class="arithmatex">\(d'\)</span>，且它们的全体就是</p>
<div class="arithmatex">\[
\{5^{di}\bmod m : 0 \le i &lt; d'\}.
\]</div>
</li>
</ol>
</details>
<details class="note">
<summary>证明</summary>
<p>因为 <span class="arithmatex">\(a\perp m\)</span>，所以 <span class="arithmatex">\(x\perp m\)</span>．因为 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(a\)</span> 都是奇数，由前述结论可知，可以设 <span class="arithmatex">\(a\equiv (-1)^s5^r\pmod{2^e}\)</span> 且 <span class="arithmatex">\(x=(-1)^z5^{y}\pmod{2^e}\)</span>．因为表示是唯一的，所以同余方程 <span class="arithmatex">\(x^k\equiv a\pmod{2^e}\)</span> 等价于 <a href="../linear-equation/">线性同余方程</a> 组</p>
<div class="arithmatex">\[
\begin{aligned}
kz &amp;\equiv s \pmod{2},\\
ky &amp;\equiv r \pmod{2^{e-2}}.
\end{aligned}
\]</div>
<p>结合该页面对于线性同余方程解的分析，就可以得到同余方程 <span class="arithmatex">\(x^k\equiv a\pmod{2^e}\)</span> 解的结构．根据 <span class="arithmatex">\(k\)</span> 的奇偶性不同，可以分为两种情形：</p>
<ul>
<li>当 <span class="arithmatex">\(k\)</span> 是奇数时，因为 <span class="arithmatex">\(\gcd(k,2)=\gcd(k,2^{e-2})=1\)</span>，所以两个线性同余方程对于所有 <span class="arithmatex">\(s,r\)</span> 都有解，故而原同余方程对于所有奇数 <span class="arithmatex">\(a\)</span> 总是有解．</li>
<li>
<p>当 <span class="arithmatex">\(k\)</span> 是偶数时，第一个方程有解当且仅当 <span class="arithmatex">\(2\mid s\)</span>，第二个方程有解当且仅当 <span class="arithmatex">\(d=\gcd(k,2^{e-2})\mid r\)</span>．将两者结合就得到 <span class="arithmatex">\(k\)</span> 次剩余类的全体形式．直接计算可知，第一个条件等价于 <span class="arithmatex">\(a\equiv 1\pmod 4\)</span>；重复奇素数幂情形的分析可知，第二个条件等价于 <span class="arithmatex">\(a^{d'}=1\)</span>．将两点结合起来就得到定理中的判定方法．两个线性同余方程的通解也是已知的：</p>
<div class="arithmatex">\[
\begin{aligned}
z &amp;\equiv0,1\pmod 2, \\
y &amp;\equiv y_0 + id' \pmod{2^{e-2}},~ 0\le y_0 &lt; 2^{e-2}.
\end{aligned}
\]</div>
<p>将两者结合就得到原方程的通解．</p>
</li>
</ul>
</details>
<p>这就完全解决了不同模数下 <span class="arithmatex">\(k\)</span> 次剩余的判定问题．二次剩余中的 Legendre 记号和二次互反律等内容也可以推广到高次剩余的情形，但这并不容易，需要用到 <a href="../../algebra/field-theory/#分圆域">分圆域</a> 等概念．在代数数论中，二次互反律最终可以推广到 <a href="https://en.wikipedia.org/wiki/Artin_reciprocity">Artin 互反律</a>．</p>
<h2 id="单位根">单位根<a class="headerlink" href="#单位根" title="Permanent link"></a></h2>
<p>作为 <span class="arithmatex">\(k\)</span> 次方根的特殊情形，本节讨论 <span class="arithmatex">\(k\)</span> 次（本原）单位根的概念．它可以看作是复数域 <span class="arithmatex">\(\mathbf C\)</span> 中 <span class="arithmatex">\(k\)</span> 次 <a href="../../complex/#单位根">单位根</a> 的概念在模 <span class="arithmatex">\(m\)</span> 既约剩余系 <span class="arithmatex">\(\mathbf Z_m^*\)</span> 中的对应．当模数 <span class="arithmatex">\(m\)</span> 合适时，用模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根代替复数根 <span class="arithmatex">\(\omega_k\)</span> 可以加速计算．</p>
<p>类似于复数域的情形，有如下定义：</p>
<details class="abstract" open="open">
<summary>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根</summary>
<p>对于模数 <span class="arithmatex">\(m\)</span>，元素 <span class="arithmatex">\(1\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根称为 <strong>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根</strong>（<span class="arithmatex">\(k\)</span>-th root of unity modulo <span class="arithmatex">\(m\)</span>）．特别地，如果 <span class="arithmatex">\(x\)</span> 是模 <span class="arithmatex">\(m\)</span> 的一个 <span class="arithmatex">\(k\)</span> 次单位根，且它不是模 <span class="arithmatex">\(m\)</span> 的任何 <span class="arithmatex">\(k' &lt; k\)</span> 次单位根，那么，也称 <span class="arithmatex">\(x\)</span> 为 <strong>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根</strong>（<span class="arithmatex">\(k\)</span>-th primitive root of unity modulo <span class="arithmatex">\(m\)</span>）．</p>
</details>
<p>比较 <a href="../primitive-root/#原根">原根的定义</a> 可知，原根 <span class="arithmatex">\(g\)</span> 就是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\varphi(m)\)</span> 次本原单位根，其中，<span class="arithmatex">\(\varphi(m)\)</span> 是 <a href="../euler-totient/">欧拉函数</a>．</p>
<p>当模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根存在时，它的代数性质和 <span class="arithmatex">\(k\)</span> 次本原单位复根 <span class="arithmatex">\(\omega_k\)</span> 一致，可以代替 <span class="arithmatex">\(\omega_k\)</span> 进行各种计算．例如，将它应用于 <a href="../../poly/fft/">快速傅里叶变换</a> 中，就得到有限域<sup id="fnref:fnnt"><a class="footnote-ref" href="#fn:fnnt">1</a></sup>上的 <a href="../../poly/ntt/">快速数论变换</a>．</p>
<h3 id="性质_1">性质<a class="headerlink" href="#性质_1" title="Permanent link"></a></h3>
<p>复数域中，任意次（本原）单位根都存在．但是，数论中的（本原）单位根并非如此．</p>
<details class="note" open="open">
<summary>性质</summary>
<p>对于模数 <span class="arithmatex">\(m\)</span>，设 <span class="arithmatex">\(\lambda(m)\)</span> 为它的 <a href="../primitive-root/#carmichael-函数">Carmichael 函数</a>，有：</p>
<ol>
<li>所有与 <span class="arithmatex">\(m\)</span> 互素的整数 <span class="arithmatex">\(a\)</span> 都是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\delta_m(a)\)</span> 次本原单位根，其中，<span class="arithmatex">\(\delta_m(a)\)</span> 是 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <a href="../primitive-root/#阶">阶</a>．</li>
<li>元素 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，且 <span class="arithmatex">\(k'\)</span> 是 <span class="arithmatex">\(k\)</span> 的任意倍数，那么 <span class="arithmatex">\(a\)</span> 也是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k'\)</span> 次单位根．</li>
<li>元素 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次（本原）单位根，那么元素 <span class="arithmatex">\(a^{\ell}\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\dfrac{k}{\gcd(k,\ell)}\)</span> 次（本原，相应地）单位根．</li>
<li>当 <span class="arithmatex">\(k'\)</span> 遍历 <span class="arithmatex">\(k\)</span> 的因数，所有模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k'\)</span> 次本原单位根恰构成模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根的一个划分．而且，对于 <span class="arithmatex">\(\ell\perp k\)</span>，映射 <span class="arithmatex">\(x\mapsto x^\ell\)</span> 给出 <span class="arithmatex">\(k\)</span> 次单位根之间的双射，且保持上述划分不变：它将 <span class="arithmatex">\(k'\mid k\)</span> 次本原单位根仍然映射到 <span class="arithmatex">\(k'\)</span> 次本原单位根．</li>
<li>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根存在，当且仅当 <span class="arithmatex">\(k\mid\lambda(m)\)</span>．特别地，模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\lambda(m)\)</span> 次本原单位根存在，称为 <strong>模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\lambda\)</span>‑原根</strong>．</li>
<li>元素 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，当且仅当 <span class="arithmatex">\(a^k\equiv 1\pmod{m}\)</span> 且对于任意素因子 <span class="arithmatex">\(p\mid k\)</span> 都有 <span class="arithmatex">\(a^{k/p}\not\equiv 1\pmod{m}\)</span>．</li>
</ol>
</details>
<details class="note">
<summary>证明</summary>
<p>根据阶的定义，所有与 <span class="arithmatex">\(m\)</span> 互素的整数 <span class="arithmatex">\(a\)</span> 都是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\delta_m(a)\)</span> 次本原单位根，其中，<span class="arithmatex">\(\delta_m(a)\)</span> 是 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的阶．反过来，如果 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，那么 <span class="arithmatex">\(\gcd(a^k,m)=1\)</span>，所以 <span class="arithmatex">\(\gcd(a,m)=1\)</span>．因此，<span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的（本原）单位根，当且仅当 <span class="arithmatex">\(a\)</span> 与 <span class="arithmatex">\(m\)</span> 互素．这就是性质 1．</p>
<p>直接验证定义可知，只要 <span class="arithmatex">\(k\mid k'\)</span>，就可以从 <span class="arithmatex">\(a^k\equiv 1\pmod m\)</span> 推出 <span class="arithmatex">\(a^{k'}\equiv 1\pmod m\)</span>，这就是性质 2．根据 <a href="../primitive-root/#ord-prop-3">阶的性质</a> 可知</p>
<div class="arithmatex">\[
\delta(a^\ell) = \dfrac{\delta_m(a)}{\gcd(\delta_m(a),\ell)}.
\]</div>
<p>如果 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根，那么，<span class="arithmatex">\(\delta_m(a)=k\)</span>，直接代入上式就得到 <span class="arithmatex">\(a^\ell\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\dfrac{k}{\gcd(k,\ell)}\)</span> 次本原单位根．如果 <span class="arithmatex">\(a\)</span> 只是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，设它是 <span class="arithmatex">\(k'\mid k\)</span> 次本原单位根，故而 <span class="arithmatex">\(a^\ell\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\dfrac{k'}{\gcd(k',\ell)}\)</span> 次本原单位根．由于 <span class="arithmatex">\(k'\mid k\)</span>，有</p>
<div class="arithmatex">\[
\dfrac{k'}{\gcd(k',\ell)} \mid \dfrac{k}{\gcd(k,\ell)},
\]</div>
<p>再由性质 2，就得到 <span class="arithmatex">\(a^\ell\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\dfrac{k}{\gcd(k,\ell)}\)</span> 次单位根．这就是性质 3．</p>
<p>对于 <span class="arithmatex">\(k'\mid k\)</span>，由性质 2，模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k'\)</span> 次本原单位根必然是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根．它们两两不交，故而构成划分．而对于 <span class="arithmatex">\(\ell\perp k\)</span>，总有 <span class="arithmatex">\(\ell\perp k'\)</span>，因此对于模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k'\)</span> 次本原单位根 <span class="arithmatex">\(a\)</span>，总有 <span class="arithmatex">\(a^\ell\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k'\)</span> 次本原单位根．取 <span class="arithmatex">\(\ell'=\ell^{-1}\bmod k\)</span>，可以验证 <span class="arithmatex">\(x\mapsto x^\ell\)</span> 和 <span class="arithmatex">\(x\mapsto x^{\ell'}\)</span> 互为逆映射，因此，<span class="arithmatex">\(x\mapsto x^\ell\)</span> 是双射．这就是性质 4．</p>
<p>根据 Carmichael 函数的性质可知，模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\lambda(m)\)</span> 次本原单位根总是存在的，设它为 <span class="arithmatex">\(a\)</span>，且 <span class="arithmatex">\(\delta_m(a)=\lambda(m)\)</span>．对于 <span class="arithmatex">\(k\mid\lambda(m)\)</span>，设 <span class="arithmatex">\(k'=\dfrac{\lambda(m)}{k}\)</span>，总有</p>
<div class="arithmatex">\[
\delta_m(a^{k'}) = \dfrac{\lambda(m)}{(\lambda(m),k')} = \dfrac{\lambda(m)}{k'} = k.
\]</div>
<p>因此，<span class="arithmatex">\(a^{k'}\)</span> 是 <span class="arithmatex">\(k\)</span> 次本原单位根．而根据 Carmichael 函数的定义，所有 <span class="arithmatex">\(x\perp m\)</span> 的阶都是 <span class="arithmatex">\(\lambda(m)\)</span> 的因子．这就得到性质 5．</p>
<p>几乎重复 <a href="../primitive-root/#原根判定定理">原根判定定理</a> 的证明，就可以得到性质 6．这一判别方法实际上在验证 <span class="arithmatex">\(\delta_m(a)=k\)</span>．</p>
</details>
<p>从这些性质可以看出，相对于原根存在的情形，模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\lambda\)</span>‑原根起到了类似的基础作用．与原根不同的是，<span class="arithmatex">\(\lambda\)</span>‑原根的幂次并不能用于生成模 <span class="arithmatex">\(m\)</span> 的全体单位根．尽管如此，由于 <span class="arithmatex">\(\lambda\)</span>‑原根的密度并不低<sup id="fnref:lambda-density"><a class="footnote-ref" href="#fn:lambda-density">2</a></sup>，如果确实需要找到 <span class="arithmatex">\(k\)</span> 次本原单位根，可以首先通过随机方法找到一个 <span class="arithmatex">\(\lambda\)</span>‑原根，再通过求幂次得到一个 <span class="arithmatex">\(k\)</span> 次本原单位根．</p>
<p>如果已知 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的一个 <span class="arithmatex">\(k\)</span> 次方根，可以通过模 <span class="arithmatex">\(m\)</span> 的全体 <span class="arithmatex">\(k\)</span> 次单位根生成 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的全体 <span class="arithmatex">\(k\)</span> 次方根．</p>
<details class="note" open="open">
<summary>定理</summary>
<p>设 <span class="arithmatex">\(x\)</span> 是 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的一个 <span class="arithmatex">\(k\)</span> 次方根，当 <span class="arithmatex">\(r\)</span> 遍历模 <span class="arithmatex">\(m\)</span> 的全体 <span class="arithmatex">\(k\)</span> 次单位根时，<span class="arithmatex">\(xr\)</span> 遍历 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的全体 <span class="arithmatex">\(k\)</span> 次方根．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>对于 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的两个 <span class="arithmatex">\(k\)</span> 次方根 <span class="arithmatex">\(x,y\)</span>，设 <span class="arithmatex">\(r=x^{-1}y\bmod m\)</span>，那么 <span class="arithmatex">\(r\)</span> 满足 <span class="arithmatex">\(r^k\equiv 1\pmod m\)</span>，是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根．反过来，只要 <span class="arithmatex">\(r\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，那么，<span class="arithmatex">\((xr)^{k}= x^kr^k\equiv a\pmod m\)</span>，也就是说，<span class="arithmatex">\(xr\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根．</p>
</details>
<p>利用 <span class="arithmatex">\(k\)</span> 次单位根生成全体 <span class="arithmatex">\(k\)</span> 次方根，就类似于利用齐次线性方程组的解生成非齐次线性方程组的通解一样．</p>
<p>前面讨论的是一般情形．仅对于原根存在的情形，单位根的结构更为简单：</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于模数 <span class="arithmatex">\(m\)</span>，设模 <span class="arithmatex">\(m\)</span> 的原根存在，且 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根．那么，<span class="arithmatex">\(b\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，当且仅当它可以表示为 <span class="arithmatex">\(a\)</span> 的幂次．</p>
</details>
<details class="note">
<summary>证明</summary>
<p>设 <span class="arithmatex">\(g\)</span> 是模 <span class="arithmatex">\(m\)</span> 的原根，那么，所有与 <span class="arithmatex">\(m\)</span> 互素的元素都可以表示为 <span class="arithmatex">\(g\)</span> 的幂次．那么，<span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次本原单位根，当且仅当</p>
<div class="arithmatex">\[
\delta_m(a) = \delta_m(g^{\operatorname{ind}_ga}) = \dfrac{\varphi(m)}{\gcd(\varphi(m),\operatorname{ind}_ga)} = k.
\]</div>
<p>类似地，<span class="arithmatex">\(b\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k\)</span> 次单位根，当且仅当</p>
<div class="arithmatex">\[
\delta_m(b) = \delta_m(g^{\operatorname{ind}_gb}) = \dfrac{\varphi(m)}{\gcd(\varphi(m),\operatorname{ind}_gb)} = k' \mid k.
\]</div>
<p>所以，有</p>
<div class="arithmatex">\[
\gcd(\varphi(m),\operatorname{ind}_ga) \mid \gcd(\varphi(m),\operatorname{ind}_gb)\mid \operatorname{ind}_gb.
\]</div>
<p>根据对线性同余方程的 <a href="../linear-equation/">分析</a> 可知，这一条件就等价于方程</p>
<div class="arithmatex">\[
(\operatorname{ind}_ga) x \equiv \operatorname{ind}_gb \pmod{\varphi(m)}
\]</div>
<p>有解．将这一条件对 <span class="arithmatex">\(g\)</span> 取幂，就得到 <span class="arithmatex">\(a^x\equiv b\pmod{m}\)</span>，亦即 <span class="arithmatex">\(b\)</span> 可以表示为 <span class="arithmatex">\(a\)</span> 的幂次．</p>
</details>
<p>这一定理说明，原根存在时，全体 <span class="arithmatex">\(k\)</span> 次单位根呈现 <a href="../../algebra/group-theory/#循环群">循环群</a> 的结构，而 <span class="arithmatex">\(k\)</span> 次本原单位根则是该循环群的生成元．稍后将会看到，Tonelli–Shanks 算法正是利用这一点，加速了开方运算中离散对数部分的计算．</p>
<h2 id="模意义下开方">模意义下开方<a class="headerlink" href="#模意义下开方" title="Permanent link"></a></h2>
<p>最后，本文讨论 <span class="arithmatex">\(k\)</span> 次方根的求法．对于 <span class="arithmatex">\(k=2\)</span> 的情形，有 <a href="../quad-residue/#模意义下开平方">很多高效算法</a> 可以用于模意义下开平方运算．但是，对于一般的 <span class="arithmatex">\(k\)</span>，并没有已知的多项式时间算法．本节将介绍两种常见算法，分别可以在 <span class="arithmatex">\(O(m^{1/2})\)</span> 和 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span> 时间内求出一个 <span class="arithmatex">\(k\)</span> 次方根．利用中国剩余定理总是可以将问题转换为素数幂模的情形，因此，本节主要讨论素数幂模情形的解法．</p>
<h3 id="朴素算法">朴素算法<a class="headerlink" href="#朴素算法" title="Permanent link"></a></h3>
<p>前文对于 <span class="arithmatex">\(k\)</span> 次剩余性质的 <a href="#性质">分析</a> 实际上已经指出了一种求解素数幂模下 <span class="arithmatex">\(k\)</span> 次方根的方法．严格来说，前文解决的情形是被开方数 <span class="arithmatex">\(a\)</span> 与模数 <span class="arithmatex">\(m\)</span> 互素的情形．算法过程总结如下：</p>
<ul>
<li>
<p>当 <span class="arithmatex">\(m=p^e\)</span> 是奇素数幂时，设模 <span class="arithmatex">\(m\)</span> 的一个原根是 <span class="arithmatex">\(g\)</span>．那么，方程 <span class="arithmatex">\(x^k\equiv a\pmod m\)</span> 可以转化为线性同余方程</p>
<div class="arithmatex">\[
ky \equiv \operatorname{ind}_g a \pmod{\varphi(m)}.
\]</div>
<p>其中，<span class="arithmatex">\(\operatorname{ind}_g a\)</span> 可以通过 <a href="../discrete-logarithm/#大步小步算法">BSGS 算法</a> 求出，而 <a href="../linear-equation/">线性同余方程</a> 的全体解容易求出．由此，就可以得到 <span class="arithmatex">\(a\)</span> 的全部 <span class="arithmatex">\(k\)</span> 次方根 <span class="arithmatex">\(x\equiv g^y\pmod m\)</span>．</p>
<p>除此之外，还有另一种相仿的思路．同样是设 <span class="arithmatex">\(x\equiv g^y\pmod m\)</span>，还可以通过变形</p>
<div class="arithmatex">\[
x^k \equiv (g^k)^y \equiv a \pmod m
\]</div>
<p>转化为求底数为 <span class="arithmatex">\(g^k\)</span> 时 <span class="arithmatex">\(a\)</span> 的离散对数．这同样可以通过 BSGS 算法找到一组特解．它的通解可以通过前文的解的表达式求出，也就是将特解与全体 <span class="arithmatex">\(k\)</span> 次单位根逐一相乘得到．</p>
<p>无论采用哪种思路，原根已知时，该算法求出单个解的复杂度都是 <span class="arithmatex">\(O(m^{1/2})\)</span>．因为可以在 <span class="arithmatex">\(o(m^{1/2})\)</span> 时间内找到一个原根，所以，总的时间复杂度仍然是 <span class="arithmatex">\(O(m^{1/2})\)</span>．</p>
</li>
<li>
<p>当 <span class="arithmatex">\(m=2^e\)</span> 且 <span class="arithmatex">\(e\in\mathbf N_+\)</span> 时，可以首先求出 <span class="arithmatex">\(a\equiv (-1)^s5^r\pmod m\)</span> 中的 <span class="arithmatex">\(s,r\)</span>．这两个指数中，<span class="arithmatex">\(s\)</span> 可以在 <span class="arithmatex">\(O(1)\)</span> 时间内确定：</p>
<div class="arithmatex">\[
s = \begin{cases}0, &amp; a\equiv 1\pmod 4, \\ 1, &amp; a\equiv 3\pmod 4.\end{cases}
\]</div>
<p>而 <span class="arithmatex">\(r=\operatorname{ind}_5((-1)^sa)\)</span> 可以通过 BSGS 算法在 <span class="arithmatex">\(O(m^{1/2})\)</span> 时间内求出．接下来，只需要求解线性同余方程组：</p>
<div class="arithmatex">\[
\begin{aligned}
kz &amp;\equiv s \pmod{2},\\
ky &amp;\equiv r \pmod{2^{e-2}}.
\end{aligned}
\]</div>
<p>这个线性方程组的通解 <span class="arithmatex">\((z,y)\)</span> 容易求出，而 <span class="arithmatex">\(x=(-1)^z5^y\)</span> 就是所求的方根．这一算法求出单个解的复杂度仍然是 <span class="arithmatex">\(O(m^{1/2})\)</span>．</p>
</li>
</ul>
<p>当然，对于无解的情形，其实可以通过前文叙述的判别方法在 <span class="arithmatex">\(O(\log m)\)</span> 时间内快速判断，而无需在求解过程中判断．</p>
<p>求素数模 <span class="arithmatex">\(k\)</span> 次方根的参考实现如下：（代码仅作示意，由于时间复杂度过高，无法通过本题）</p>
<details class="example">
<summary>模板题 <a href="https://judge.yosupo.jp/problem/kth_root_mod">Library Checker - Kth Root (Mod)</a> 参考实现</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/residue/bsgs-mod-p.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h3 id="改良-tonellishanks-算法">改良 Tonelli–Shanks 算法<a class="headerlink" href="#改良-tonellishanks-算法" title="Permanent link"></a></h3>
<p>将用于模意义下开平方的 <a href="../quad-residue/#tonellishanks-算法">Tonelli–Shanks 算法</a> 做适当推广，就可以解决素数幂模下开方运算．一种较为直接的推广方式是 Adleman–Manders–Miller 算法<sup id="fnref:amm"><a class="footnote-ref" href="#fn:amm">3</a></sup>，但是它的复杂度仍然不够优秀<sup id="fnref:amm-comp"><a class="footnote-ref" href="#fn:amm-comp">4</a></sup>．本节介绍由 sugarknri、Min_25、37zigen 等人提出的改良 Tonelli–Shanks 算法．它可以在 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span> 时间内求出一个 <span class="arithmatex">\(k\)</span> 次方根．</p>
<p>Tonelli–Shanks 算法的核心想法是，将离散对数的求解放到阶为 <span class="arithmatex">\(2^e\)</span> 的群里，进而降低时间复杂度．类似地，对于任意素数幂 <span class="arithmatex">\(p^e\)</span> 阶群内的离散对数，同样可以较为高效地求解，但是算法的复杂度为 <span class="arithmatex">\(\Omega\left(\sqrt{p}\right)\)</span>．Adleman–Manders–Miller 算法将 <span class="arithmatex">\(k\)</span> 次方根的求解分拆为多个素数幂阶群内离散对数的计算，但是受限于 <span class="arithmatex">\(k\)</span> 的最大素因子 <span class="arithmatex">\(p_\text{max}(k)\)</span> 的大小，算法复杂度仍然为 <span class="arithmatex">\(\Omega\left(\sqrt{p_\text{max}(k)}\right)\)</span>．本节算法进一步改良了这一过程，避免了对较大的素因子计算离散对数，进而将整体复杂度控制到 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span>．</p>
<h4 id="过程">过程<a class="headerlink" href="#过程" title="Permanent link"></a></h4>
<p>考虑素数幂模 <span class="arithmatex">\(m\)</span> 下 <span class="arithmatex">\(a\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根的计算，即求解同余方程：</p>
<div class="arithmatex">\[
x^k \equiv a \pmod m.
\]</div>
<p>特别地，对于 <span class="arithmatex">\(m=2^e\)</span> 的情形，还需要保证 <span class="arithmatex">\(a\equiv 1\pmod{4}\)</span>，进而 <span class="arithmatex">\(a\)</span> 可以写成 <span class="arithmatex">\(g=5\)</span> 的幂次．类似前文讨论，模 <span class="arithmatex">\(2^e\)</span> 下 <span class="arithmatex">\(k\)</span> 次方根的计算总是可以转化为这样的情形．处理模 <span class="arithmatex">\(2^e\)</span> 的情形时，本节提到的 <span class="arithmatex">\(\varphi(m)\)</span> 都应换作 <span class="arithmatex">\(\delta_m(5)=2^{e-2}\)</span>．</p>
<p>首先，问题可以转化为开方次数整除 <span class="arithmatex">\(\varphi(m)\)</span> 的情形．设 <span class="arithmatex">\(d=\gcd(k,\varphi(m))\)</span>．那么，由 <span class="arithmatex">\(k\)</span> 次剩余的性质可知，当 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 是 <span class="arithmatex">\(k\)</span> 次剩余时，<span class="arithmatex">\(a\)</span> 总是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(\dfrac{\varphi(m)}{d}\)</span> 次单位根．根据单位根的性质，对于任意 <span class="arithmatex">\(\ell\perp\dfrac{\varphi(m)}{d}\)</span>，映射 <span class="arithmatex">\(x\mapsto x^{\ell}\)</span> 都是 <span class="arithmatex">\(\dfrac{\varphi(m)}{d}\)</span> 次单位根之间的双射．因此，可以取</p>
<div class="arithmatex">\[
\ell = \left(\dfrac{k}{d}\right)^{-1}\bmod\dfrac{\varphi(m)}{d}.
\]</div>
<p>将原来的同余方程两侧同时取 <span class="arithmatex">\(\ell\)</span> 次幂，就得到</p>
<div class="arithmatex">\[
x^d\equiv x^{k\ell} \equiv a^{\ell} =: b \pmod{m}.
\]</div>
<p>最左侧同余号利用了 <a href="../fermat/#欧拉定理">欧拉定理</a> 和如下同余关系：（<span class="arithmatex">\(c\in\mathbf Z\)</span>）</p>
<div class="arithmatex">\[
k\ell = d\left(\frac{k}{d}\ell\right) = d\left(c\dfrac{\varphi(m)}{d}+1\right) \equiv d \pmod{\varphi(m)}.
\]</div>
<p>对于转化后的问题，考虑 <span class="arithmatex">\(d\)</span> 的素因数分解：</p>
<div class="arithmatex">\[
d = \prod_{p\in\mathbf P}p^e.
\]</div>
<p>可以从 <span class="arithmatex">\(b=a^\ell\)</span> 开始，对每个 <span class="arithmatex">\(p^e\neq 1\)</span>，依次开 <span class="arithmatex">\(p^e\)</span> 次方，最后就能得到 <span class="arithmatex">\(b\)</span> 的 <span class="arithmatex">\(d\)</span> 次方根，也就是 <span class="arithmatex">\(a\)</span> 的 <span class="arithmatex">\(k\)</span> 次方根．</p>
<p>最后，问题转化为如何求如下方程的解：</p>
<div class="arithmatex">\[
x^{p^e} \equiv b \pmod m.
\]</div>
<p>不妨设 <span class="arithmatex">\(\varphi(m)=p^sr\)</span> 且 <span class="arithmatex">\(p\perp r\)</span>．设 <span class="arithmatex">\(q\in\mathbf N_+\)</span> 是方程 <span class="arithmatex">\(qr\equiv -1\pmod{p^e}\)</span> 的解．那么，因为 <span class="arithmatex">\(b\)</span> 是 <span class="arithmatex">\(rp^{s-e}\)</span> 次单位根，所以 <span class="arithmatex">\(b^{qr}\)</span> 一定是 <span class="arithmatex">\(p^{s-e}\)</span> 次单位根．又设 <span class="arithmatex">\(\zeta\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(p^s\)</span> 次本原单位根．那么，<span class="arithmatex">\(\zeta^{p^e}\)</span> 是 <span class="arithmatex">\(p^{s-e}\)</span> 次本原单位根，进而存在 <span class="arithmatex">\(h\in\mathbf N\)</span> 使得 <span class="arithmatex">\(b^{qr}\equiv \zeta^{hp^{e}}\pmod{m}\)</span>．所以，直接验证可知</p>
<div class="arithmatex">\[
x\equiv b^{(qr+1)/p^e}\zeta^{-h} \pmod{m}
\]</div>
<p>是 <span class="arithmatex">\(b\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(p^e\)</span> 次方根．</p>
<p>为了计算 <span class="arithmatex">\(x\)</span>，需要找到模 <span class="arithmatex">\(m\)</span> 的一个 <span class="arithmatex">\(p\)</span> 次非剩余 <span class="arithmatex">\(\eta\)</span>．为此，由前文性质，只需要随机 <span class="arithmatex">\(\eta\perp m\)</span> 并验证 <span class="arithmatex">\(\eta^{\varphi(m)/p}\bmod{m}\neq 1\)</span> 即可．这样的数的密度是</p>
<div class="arithmatex">\[
\dfrac{\varphi(m)}{m}\left(1-\dfrac{1}{p}\right) \ge \dfrac{1}{4}.
\]</div>
<p>因此，期望随机不超过 <span class="arithmatex">\(4\)</span> 个整数就能找到它．注意到，<span class="arithmatex">\(\eta^{rp^{s-1}}\not\equiv 1\pmod m\)</span> 且 <span class="arithmatex">\(\eta^{rp^s}\equiv 1\pmod m\)</span>，所以，如果设 <span class="arithmatex">\(\zeta=\eta^r\bmod m\)</span> 和 <span class="arithmatex">\(\xi=\eta^{rp^{s-1}}\bmod m\)</span>，那么它们分别是 <span class="arithmatex">\(p^s\)</span> 次和 <span class="arithmatex">\(p\)</span> 次本原单位根．</p>
<p>最后，需要计算 <span class="arithmatex">\(h\in\mathbf N\)</span>．显然，可以取 <span class="arithmatex">\(h &lt; p^{s-e}\)</span>．考虑 <span class="arithmatex">\(h\)</span> 的 <span class="arithmatex">\(p\)</span> 进制表示：</p>
<div class="arithmatex">\[
h = \sum_{j=0}^{s-e-1}h_jp^j = h_0 + h_1p + h_2p^2 +\cdots.
\]</div>
<p>逐位计算这些数位．当前 <span class="arithmatex">\(j\)</span> 个数位都计算完成时，必然有</p>
<div class="arithmatex">\[
\left(b^{qr}\zeta^{-p^e(h_0+h_1p+\cdots + h_{j-1}p^{j-1})}\right)^{p^{s-e-j-1}} \equiv \zeta^{h_jp^{s-1}} \equiv \xi^{h_j} \pmod{m}.
\]</div>
<p>故而，<span class="arithmatex">\(h_j\)</span> 可以通过计算关于 <span class="arithmatex">\(\xi\)</span> 的离散对数求出．为了获得更好的时间复杂度，需要使用 BSGS 算法．总共需要计算 <span class="arithmatex">\((s-e)\)</span> 次离散对数，设预处理 <span class="arithmatex">\(B\)</span> 个 <span class="arithmatex">\(\xi\)</span> 的幂次，则单次求解离散对数的时间复杂度为 <span class="arithmatex">\(O(p/B)\)</span>，总的时间复杂度为</p>
<div class="arithmatex">\[
O\left(B+(s-e)\dfrac{p}{B}\right).
\]</div>
<p>当 <span class="arithmatex">\(B=\sqrt{(s-e)p}\)</span> 时，总的时间复杂度最低，为 <span class="arithmatex">\(O\left(\sqrt{(s-e)p}\right)\)</span>．得到 <span class="arithmatex">\(h\)</span> 之后，代入前文 <span class="arithmatex">\(x\)</span> 的表达式，就可以找到一个特解．</p>
<h4 id="时间复杂度">时间复杂度<a class="headerlink" href="#时间复杂度" title="Permanent link"></a></h4>
<p>这一算法的时间复杂度为 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span>．本节讨论复杂度时，总是假设单次乘法需要 <span class="arithmatex">\(O(1)\)</span> 时间，且计算幂次时，总是应用欧拉定理降幂，则涉及的单个幂的计算总是可以在 <span class="arithmatex">\(O(\log m)\)</span> 时间内完成．</p>
<p>先考虑单个 <span class="arithmatex">\(p^e\)</span> 次方根的计算．找到 <span class="arithmatex">\(p\)</span> 次非剩余只需要验证期望 <span class="arithmatex">\(O(1)\)</span> 个数，总时间复杂度为 <span class="arithmatex">\(O(\log m)\)</span>．计算 <span class="arithmatex">\(s,r,\zeta,\eta,b^{qr}\)</span> 各只需要 <span class="arithmatex">\(O(\log m)\)</span> 时间．计算 <span class="arithmatex">\(h\)</span> 时，单个数位需要通过 <span class="arithmatex">\(O(\log m)\)</span> 时间计算幂次，总共 <span class="arithmatex">\((s-e)\)</span> 位，故而总的时间复杂度为 <span class="arithmatex">\(O((s-e)\log m)\)</span>．前文已经说明，计算离散对数的部分预处理和 <span class="arithmatex">\((s-e)\)</span> 次查询的总时间为 <span class="arithmatex">\(O\left(\sqrt{(s-e)p}\right)\)</span>．因为 <span class="arithmatex">\(s-e\in O(\log m)\)</span>，所以单个 <span class="arithmatex">\(p^e\)</span> 次方根的计算的时间复杂度为 <span class="arithmatex">\(O(p^{1/2+\varepsilon})\)</span>．特别地，当 <span class="arithmatex">\(s=e\)</span> 时，时间复杂度可以进一步减少为 <span class="arithmatex">\(O(\log m)\)</span>．</p>
<p>进而，可以考虑算法总的时间复杂度．计算 <span class="arithmatex">\(\varphi(m),d,\ell\)</span> 的时间复杂度均为 <span class="arithmatex">\(O(\log m)\)</span>．紧接着需要做素因数分解 <span class="arithmatex">\(d=\prod_p{p^e}\)</span>，这一步利用 <a href="../pollard-rho/#pollard-rho-算法">Pollard Rho 算法</a> 可以在 <span class="arithmatex">\(O(m^{1/4})\)</span> 时间内完成．最后，依次求 <span class="arithmatex">\(p^e\)</span> 次方根的总时间复杂度为</p>
<div class="arithmatex">\[
O\left(\sum_{e &lt; s}p^{1/2+\varepsilon}\right).
\]</div>
<p>由于满足 <span class="arithmatex">\(e &lt; s\)</span> 的素因子 <span class="arithmatex">\(p\)</span> 至少在 <span class="arithmatex">\(\varphi(m)\)</span> 中出现 <span class="arithmatex">\(2\)</span> 次，必然有 <span class="arithmatex">\(p &lt; m^{1/2}\)</span>．故而，总时间复杂度为 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span>．</p>
<p>事实上，在这一情景中，无需使用 Pollard Rho 算法分解素因数，仍然可以获得 <span class="arithmatex">\(O(m^{1/4+\varepsilon})\)</span> 的时间复杂度．事实上，只需要对 <span class="arithmatex">\(d\)</span> 暴力试除进行分解，并只枚举到不超过 <span class="arithmatex">\(m^{1/4}\)</span> 的素因子．设去除这些小素因子后得到的整数为 <span class="arithmatex">\(z\)</span>．那么，对于 <span class="arithmatex">\(z\)</span> 的素因子 <span class="arithmatex">\(p &gt; m^{1/4}\)</span>，必然有 <span class="arithmatex">\(\nu_p(\varphi(m)) &lt; 4\)</span>，其中，<span class="arithmatex">\(\nu_p(n)\)</span> 表示 <span class="arithmatex">\(n\)</span> 的素因数分解中 <span class="arithmatex">\(p\)</span> 的次数．由于只需要考虑</p>
<div class="arithmatex">\[
1 \le e = \nu_p(d) &lt; s = \nu_p(\varphi(m)) &lt; 4
\]</div>
<p>的情形，满足该条件的素因子 <span class="arithmatex">\(p\)</span> 至多只能有一个；否则，它们在 <span class="arithmatex">\(\varphi(m)\)</span> 中的次数都不小于 <span class="arithmatex">\(2\)</span>，总的乘积必然超过 <span class="arithmatex">\(m\)</span>．要分离出这个（可能存在的）唯一的大素因子，只需要计算</p>
<div class="arithmatex">\[
p^\star=\gcd\left(z,\dfrac{\varphi(m)}{z}\right) = \prod_{p : \nu_p(d) &lt; \nu_p(\varphi(m))}p^{\min\{\nu_p(d),\nu_p(\varphi(m))-\nu_p(d)\}}.
\]</div>
<p>枚举 <span class="arithmatex">\(\nu_p(d),\nu_p(\varphi(m))\)</span> 的所有可能性可知，乘积中 <span class="arithmatex">\(p\)</span> 的次数一定是 <span class="arithmatex">\(1\)</span>，因此这样算出来的就是唯一的大素因子 <span class="arithmatex">\(p^\star\)</span>（如果存在的话）．至于剩余的部分 <span class="arithmatex">\(z/p^\star\)</span>，因为其中只能包含若干满足 <span class="arithmatex">\(e=s\)</span> 的素因子，所以无需继续分解．</p>
<p>求素数模 <span class="arithmatex">\(k\)</span> 次方根的参考实现如下：</p>
<details class="example">
<summary>模板题 <a href="https://judge.yosupo.jp/problem/kth_root_mod">Library Checker - Kth Root (Mod)</a> 参考实现</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/residue/tonelli-shanks-mod-p.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h3 id="一般情形的处理">一般情形的处理<a class="headerlink" href="#一般情形的处理" title="Permanent link"></a></h3>
<p>考虑一般的情形，仍然设模数 <span class="arithmatex">\(m\)</span> 是素数幂 <span class="arithmatex">\(p^e\)</span>，但是 <span class="arithmatex">\(\gcd(a,m)&gt;1\)</span>．如果 <span class="arithmatex">\(a\equiv 0\pmod{m}\)</span>，那么</p>
<div class="arithmatex">\[
x = p^{\lceil e/k \rceil}\ell\pmod{p^e},~\ell=0,1,\cdots,p^{e-\lceil e/k\rceil}-1
\]</div>
<p>都是原方程的解．接下来，考察 <span class="arithmatex">\(a\not\equiv 0\pmod{m}\)</span> 的情形．设 <span class="arithmatex">\(a = p^sa'\)</span> 且 <span class="arithmatex">\(p\perp a'\)</span>．于是，设 <span class="arithmatex">\(x=p^zx'\)</span> 且 <span class="arithmatex">\(p\perp x'\)</span>，就有</p>
<div class="arithmatex">\[
x^k = p^{kz}(x')^k\equiv p^sa'\pmod{p^e}.
\]</div>
<p>由于 <span class="arithmatex">\((x')^k\perp p\)</span>，所以该式成立当且仅当 <span class="arithmatex">\(kz = s\)</span> 且 <span class="arithmatex">\((x')^k\equiv a'\pmod{p^{e-s}}\)</span>．当且仅当 <span class="arithmatex">\(k\mid s\)</span> 时，第一个方程有解 <span class="arithmatex">\(z=\dfrac{s}{k}\)</span>；而第二个方程的求解已经解决．需要注意的是，因为第二个方程的通解的模数与原方程通解的模数并不相同，所以第二个方程的每一个解 <span class="arithmatex">\(x'\)</span>，都对应原方程的若干解：</p>
<div class="arithmatex">\[
x \equiv p^{s/k}(x' + \ell p^{e-s})\pmod{p^e},~\ell = 0,1,\cdots, p^{s-s/k}-1.
\]</div>
<p>求解任一模数下全体 <span class="arithmatex">\(k\)</span> 次方根的参考实现如下：</p>
<details class="example">
<summary>模板题 <a href="https://www.luogu.com.cn/problem/P5668">Luogu P5668【模板】N 次剩余</a> 参考代码</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">朴素算法</label><label for="__tabbed_1_2">改良 Tonelli–Shanks 算法</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/residue/bsgs.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</div>
<div class="tabbed-block">
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/residue/tonelli-shanks.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</div>
</div>
</div>
</details>
<h2 id="参考资料与注释">参考资料与注释<a class="headerlink" href="#参考资料与注释" title="Permanent link"></a></h2>
<ul>
<li>冯克勤．初等数论及其应用．</li>
<li><a href="https://en.wikipedia.org/wiki/Root_of_unity_modulo_n">Root of unity modulo n - Wikipedia</a></li>
<li><a href="https://yukicoder.me/problems/no/981/editorial">No.981 一般冪乗根 解説 by 37zigen</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:fnnt">
<p>实际上，模数 <span class="arithmatex">\(m\)</span> 未必是素数．只要 <span class="arithmatex">\(a\)</span> 是模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(k=2^e\)</span> 次本原单位根，就可以用于模 <span class="arithmatex">\(m\)</span> 的快速数论变换．但是，由于通常需要处理的 <span class="arithmatex">\(2^e\)</span> 比较大，这意味着模数 <span class="arithmatex">\(m\)</span> 中的每个素因子都是 <span class="arithmatex">\(c2^e+1\)</span> 形式．因此，单个素因子就很大，而模数 <span class="arithmatex">\(m\)</span> 通常会更大，因而一般模数的情形并没有素数模的情形常用．&#160;<a class="footnote-backref" href="#fnref:fnnt" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:lambda-density">
<p>根据 <a href="../primitive-root/#原根个数">原根个数相关结论</a> 可知，<span class="arithmatex">\(\lambda\)</span>‑原根的数量恰为 <span class="arithmatex">\(\varphi(\lambda(m))\)</span>，其中，<span class="arithmatex">\(\varphi(\cdot)\)</span> 和 <span class="arithmatex">\(\lambda(\cdot)\)</span> 分别是欧拉函数和 Carmichael 函数。因为对于几乎所有整数 <span class="arithmatex">\(m\)</span>，都有 <span class="arithmatex">\(\lambda(m)/m = \exp(-(1+o(1))\log\log m\log\log\log m)\)</span>，而存在 <span class="arithmatex">\(C &gt; 0\)</span>，使得对于整数 <span class="arithmatex">\(m &gt; 2\)</span>，都有 <span class="arithmatex">\(\varphi(m)/m = C / \log\log m\)</span>，所以，对于几乎所有整数 <span class="arithmatex">\(m\)</span>，都有 <span class="arithmatex">\(\varphi(\lambda(m))/m = \exp(-(1+o(1))\log\log m\log\log\log m)\)</span>。其中，指数部分系数中的 <span class="arithmatex">\(o(1)\)</span> 吸收了因子 <span class="arithmatex">\(\varphi(\lambda(m))/\lambda(m)\)</span> 的贡献。故而，<span class="arithmatex">\(\lambda\)</span>‑原根可以在期望 <span class="arithmatex">\(\exp((1+o(1))\log\log m\log\log\log m)\)</span> 次内找到。关于欧拉函数的估计，可以参考论文 Rosser, J. Barkley, and Lowell Schoenfeld. "Approximate formulas for some functions of prime numbers." Illinois Journal of Mathematics 6, no. 1 (1962): 64-94．关于 Carmichael 函数的估计，可以参考论文 Erdos, Paul, Carl Pomerance, and Eric Schmutz. "Carmichael’s lambda function." Acta Arith 58, no. 4 (1991): 363-385．&#160;<a class="footnote-backref" href="#fnref:lambda-density" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:amm">
<p>原始论文参见 Adleman, Leonard, Kenneth Manders, and Gary Miller. "On taking roots in finite fields." In 18<sup>th</sup> Annual Symposium on Foundations of Computer Science (sfcs 1977), pp. 175-178. IEEE Computer Society, 1977．一个更易读的介绍可见于 Cao, Zhengjun, Qian Sha, and Xiao Fan. "Adleman-Manders-Miller root extraction method revisited." In International Conference on Information Security and Cryptology, pp. 77-85. Berlin, Heidelberg: Springer Berlin Heidelberg, 2011．&#160;<a class="footnote-backref" href="#fnref:amm" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:amm-comp">
<p>由于这一算法要求 <span class="arithmatex">\(k\)</span> 是素数，所以最差情形中，它需要对 <span class="arithmatex">\(\varphi(m)\)</span> 的最大素因子 <span class="arithmatex">\(p\)</span> 求 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的 <span class="arithmatex">\(p\)</span> 次方根．这一过程中，需要对 <span class="arithmatex">\(p\)</span> 次本原单位根求 <span class="arithmatex">\(a\)</span> 模 <span class="arithmatex">\(m\)</span> 的离散对数．即使应用 BSGS 算法，这一过程也需要 <span class="arithmatex">\(O(\sqrt{p})\)</span> 时间．但是，论文 Fouvry, Étienne. "Theoreme de Brun-Titchmarsh; application au theoreme de Fermat." Inventiones mathematicae 79, no. 2 (1985): 383-407 指出，存在正密度的素数 <span class="arithmatex">\(m\)</span>，使得 <span class="arithmatex">\(\varphi(m)=m-1\)</span> 的最大素因子 <span class="arithmatex">\(p=\Omega(m^{2/3})\)</span>．这意味着这一算法的复杂度至少为 <span class="arithmatex">\(\Omega(m^{1/3})\)</span>，劣于文中介绍的改良 Tonelli–Shanks 算法．&#160;<a class="footnote-backref" href="#fnref:amm-comp" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../_static/js/math-csr.js?math-csr"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>