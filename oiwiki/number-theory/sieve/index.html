
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="inkydragon, TravorLZH, YOYO-UIAT, wood3, shuzhouliu, Mr-Python-in-China, HeRaNO, weilycoder">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Sieve - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Sieve
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/am-gm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/cauchy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    柯西不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        素数筛法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="素数筛法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        引入
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      
        埃拉托斯特尼筛法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="埃拉托斯特尼筛法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      
        过程
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
        实现
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛至平方根
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      
        只筛奇数
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      
        减少内存的占用
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      
        分块筛选
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      
        线性筛法
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛法求欧拉函数
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="筛法求欧拉函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      
        实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛法求莫比乌斯函数
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="筛法求莫比乌斯函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      
        定义
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      
        实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛法求约数个数
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="筛法求约数个数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      
        约数个数定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      
        实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      
        筛法求约数和
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="筛法求约数和">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      
        实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      
        一般的积性函数
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Sieve</h1>

<h2 id="_1">素数筛法</h2>
<h3 id="_2">引入</h3>
<p>如果我们想要知道小于等于 <span class="arithmatex">\(n\)</span> 有多少个素数呢？</p>
<p>一个自然的想法是对于小于等于 <span class="arithmatex">\(n\)</span> 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>
<h3 id="_3">埃拉托斯特尼筛法</h3>
<h4 id="_4">过程</h4>
<p>考虑这样一件事情：对于任意一个大于 <span class="arithmatex">\(1\)</span> 的正整数 <span class="arithmatex">\(n\)</span>，那么它的 <span class="arithmatex">\(x\)</span> 倍就是合数（<span class="arithmatex">\(x &gt; 1\)</span>）。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<h4 id="_5">实现</h4>
<p>=== "C++"
    ```cpp
    vector<int> prime;
    bool is_prime[N];</p>
<pre><code>void Eratosthenes(int n) {
  is_prime[0] = is_prime[1] = false;
  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;
  for (int i = 2; i &lt;= n; ++i) {
    if (is_prime[i]) {
      prime.push_back(i);
      if ((long long)i * i &gt; n) continue;
      for (int j = i * i; j &lt;= n; j += i)
        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i
        // 的倍数开始，提高了运行速度
        is_prime[j] = false;  // 是 i 的倍数的均不是素数
    }
  }
}
```
</code></pre>
<p>=== "Python"
    ```python
    prime = []
    is_prime = [False] * N</p>
<pre><code>def Eratosthenes(n):
    is_prime[0] = is_prime[1] = False
    for i in range(2, n + 1):
        is_prime[i] = True
    for i in range(2, n + 1):
        if is_prime[i]:
            prime.append(i)
            if i * i &gt; n:
                continue
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
```
</code></pre>
<p>以上为 <strong>Eratosthenes 筛法</strong>（埃拉托斯特尼筛法，简称埃氏筛法），时间复杂度是 <span class="arithmatex">\(O(n\log\log n)\)</span>。</p>
<p>???+ note "证明"
    现在我们就来看看推导过程：</p>
<pre><code>如果每一次对数组的操作花费 1 个单位时间，则时间复杂度为：

$$
O\left(\sum_{k=1}^{\pi(n)}{\frac{n}{p_k}}\right)=O\left(n\sum_{k=1}^{\pi(n)}{\frac{1}{p_k}}\right)
$$

其中 $p_k$ 表示第 $k$ 小的素数，$\pi(n)$ 表示 $\le n$ 的素数个数。$\sum_{k=1}^{\pi(n)}$ 表示第一层 for 循环，其中累加上界 $\pi(n)$ 为 `if (prime[i])` 进入 true 分支的次数；$\frac{n}{p_k}$ 表示第二层 for 循环的执行次数。

根据 Mertens 第二定理，存在常数 $B_1$ 使得：

$$
\sum_{k=1}^{\pi(n)}{\frac{1}{p_k}}=\log\log n+B_1+O\left(\frac{1}{\log n}\right)
$$

所以 **Eratosthenes 筛法** 的时间复杂度为 $O(n\log\log n)$。接下来我们证明 Mertens 第二定理的弱化版本 $\sum_{k\le\pi(n)}1/p_k=O(\log\log n)$：

根据 $\pi(n)=\Theta(n/\log n)$，可知第 $n$ 个素数的大小为 $\Theta(n\log n)$。于是就有

$$
\begin{aligned}
\sum_{k=1}^{\pi(n)}{\frac{1}{p_k}}
&amp;=O\left(\sum_{k=2}^{\pi(n)}{\frac{1}{k\log k}}\right) \\
&amp;=O\left(\int_2^{\pi(n)}{\frac{\mathrm dx}{x\log x}}\right) \\
&amp;=O(\log\log\pi(n))=O(\log\log n)
\end{aligned}
$$

当然，上面的做法效率仍然不够高效，应用下面几种方法可以稍微提高算法的执行效率。
</code></pre>
<h4 id="_6">筛至平方根</h4>
<p>显然，要找到直到 <span class="arithmatex">\(n\)</span> 为止的所有素数，仅对不超过 <span class="arithmatex">\(\sqrt n\)</span> 的素数进行筛选就足够了。</p>
<p>=== "C++"
    ```cpp
    vector<int> prime;
    bool is_prime[N];</p>
<pre><code>void Eratosthenes(int n) {
  is_prime[0] = is_prime[1] = false;
  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;
  // i * i &lt;= n 说明 i &lt;= sqrt(n)
  for (int i = 2; i * i &lt;= n; ++i) {
    if (is_prime[i])
      for (int j = i * i; j &lt;= n; j += i) is_prime[j] = false;
  }
  for (int i = 2; i &lt;= n; ++i)
    if (is_prime[i]) prime.push_back(i);
}
```
</code></pre>
<p>=== "Python"
    ```python
    prime = []
    is_prime = [False] * N</p>
<pre><code>def Eratosthenes(n):
    is_prime[0] = is_prime[1] = False
    for i in range(2, n + 1):
        is_prime[i] = True
    # 让 i 循环到 &lt;= sqrt(n)
    for i in range(2, isqrt(n) + 1):  # `isqrt` 是 Python 3.8 新增的函数
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    for i in range(2, n + 1):
        if is_prime[i]:
            prime.append(i)
```
</code></pre>
<p>这种优化不会影响渐近时间复杂度，实际上重复以上证明，我们将得到 <span class="arithmatex">\(n \ln \ln \sqrt n + o(n)\)</span>，根据对数的性质，它们的渐近相同，但操作次数会明显减少。</p>
<h4 id="_7">只筛奇数</h4>
<p>因为除 2 以外的偶数都是合数，所以我们可以直接跳过它们，只用关心奇数就好。</p>
<p>首先，这样做能让我们内存需求减半；其次，所需的操作大约也减半。</p>
<h4 id="_8">减少内存的占用</h4>
<p>我们注意到筛选时只需要 <code>bool</code> 类型的数组。<code>bool</code> 数组的一个元素一般占用 <span class="arithmatex">\(1\)</span> 字节（即 <span class="arithmatex">\(8\)</span> 比特），但是存储一个布尔值只需要 <span class="arithmatex">\(1\)</span> 个比特就足够了。</p>
<p>我们可以使用 <a href="../../bit/">位运算</a> 的相关知识，将每个布尔值压到一个比特位中，这样我们仅需使用 <span class="arithmatex">\(n\)</span> 比特（即 <span class="arithmatex">\(\dfrac n 8\)</span> 字节）而非 <span class="arithmatex">\(n\)</span> 字节，可以显著减少内存占用。这种方式被称为「位级压缩」。</p>
<p>值得一提的是，存在自动执行位级压缩的数据结构，如 C++ 中的 <code>vector&lt;bool&gt;</code> 和 <code>bitset&lt;&gt;</code>。</p>
<p>另外，<code>vector&lt;bool&gt;</code> 和 <code>bitset&lt;&gt;</code> 对程序有常数优化，时间复杂度 <span class="arithmatex">\(O(n \log \log n)\)</span> 的埃氏筛在使用 <code>bitset&lt;&gt;</code> 或 <code>vector&lt;bool&gt;</code> 优化后，性能甚至超过时间复杂度 <span class="arithmatex">\(O(n)\)</span> 的欧拉筛。</p>
<p>参见 <a href="../../lang/csl/bitset.md#与埃氏筛结合">bitset: 与埃氏筛结合</a>。</p>
<h4 id="_9">分块筛选</h4>
<p>由优化「筛至平方根」可知，不需要一直保留整个 <code>is_prime[1...n]</code> 数组。为了进行筛选，只保留到 <span class="arithmatex">\(\sqrt n\)</span> 的素数就足够了，即 <code>prime[1...sqrt(n)]</code>。并将整个范围分成块，每个块分别进行筛选。这样，我们就不必同时在内存中保留多个块，而且 CPU 可以更好地处理缓存。</p>
<p>设 <span class="arithmatex">\(s\)</span> 是一个常数，它决定了块的大小，那么我们就有了 <span class="arithmatex">\(\lceil {\frac n s} \rceil\)</span> 个块，而块 <span class="arithmatex">\(k\)</span>(<span class="arithmatex">\(k = 0 \dots \lfloor {\frac n s} \rfloor\)</span>) 包含了区间 <span class="arithmatex">\([ks, ks + s - 1]\)</span> 中的数字。我们可以依次处理块，也就是说，对于每个块 <span class="arithmatex">\(k\)</span>，我们将遍历所有质数（从 <span class="arithmatex">\(1\)</span> 到 <span class="arithmatex">\(\sqrt n\)</span>）并使用它们进行筛选。</p>
<p>值得注意的是，我们在处理第一个数字时需要稍微修改一下策略：首先，应保留 <span class="arithmatex">\([1, \sqrt n]\)</span> 中的所有的质数；第二，数字 <span class="arithmatex">\(0\)</span> 和 <span class="arithmatex">\(1\)</span> 应该标记为非素数。在处理最后一个块时，不应该忘记最后一个数字 <span class="arithmatex">\(n\)</span> 并不一定位于块的末尾。</p>
<p>以下实现使用块筛选来计算小于等于 <span class="arithmatex">\(n\)</span> 的质数数量。</p>
<p>???+ note "实现"
    <code>cpp
    int count_primes(int n) {
      constexpr static int S = 10000;
      vector&lt;int&gt; primes;
      int nsqrt = sqrt(n);
      vector&lt;char&gt; is_prime(nsqrt + 1, true);
      for (int i = 2; i &lt;= nsqrt; i++) {
        if (is_prime[i]) {
          primes.push_back(i);
          for (int j = i * i; j &lt;= nsqrt; j += i) is_prime[j] = false;
        }
      }
      int result = 0;
      vector&lt;char&gt; block(S);
      for (int k = 0; k * S &lt;= n; k++) {
        fill(block.begin(), block.end(), true);
        int start = k * S;
        for (int p : primes) {
          int start_idx = (start + p - 1) / p;
          int j = max(start_idx, p) * p - start;
          for (; j &lt; S; j += p) block[j] = false;
        }
        if (k == 0) block[0] = block[1] = false;
        for (int i = 0; i &lt; S &amp;&amp; start + i &lt;= n; i++) {
          if (block[i]) result++;
        }
      }
      return result;
    }</code></p>
<p>分块筛法的渐近时间复杂度与埃氏筛法是一样的（除非块非常小），但是所需的内存将缩小为 <span class="arithmatex">\(O(\sqrt{n} + S)\)</span>，并且有更好的缓存结果。
另一方面，对于每一对块和区间 <span class="arithmatex">\([1, \sqrt{n}]\)</span> 中的素数都要进行除法，而对于较小的块来说，这种情况要糟糕得多。
因此，在选择常数 <span class="arithmatex">\(S\)</span> 时要保持平衡。</p>
<p>块大小 <span class="arithmatex">\(S\)</span> 取 <span class="arithmatex">\(10^4\)</span> 到 <span class="arithmatex">\(10^5\)</span> 之间，可以获得最佳的速度。</p>
<h3 id="_10">线性筛法</h3>
<p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。</p>
<p>如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 <span class="arithmatex">\(O(n)\)</span> 了。</p>
<p>???+ note "实现"
    === "C++"
        ```cpp
        vector<int> pri;
        bool not_prime[N];</p>
<pre><code>    void pre(int n) {
      for (int i = 2; i &lt;= n; ++i) {
        if (!not_prime[i]) {
          pri.push_back(i);
        }
        for (int pri_j : pri) {
          if (i * pri_j &gt; n) break;
          not_prime[i * pri_j] = true;
          if (i % pri_j == 0) {
            // i % pri_j == 0
            // 换言之，i 之前被 pri_j 筛过了
            // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被
            // pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break
            // 掉就好了
            break;
          }
        }
      }
    }
    ```

=== "Python"
    ```python
    pri = []
    not_prime = [False] * N


    def pre(n):
        for i in range(2, n + 1):
            if not not_prime[i]:
                pri.append(i)
            for pri_j in pri:
                if i * pri_j &gt; n:
                    break
                not_prime[i * pri_j] = True
                if i % pri_j == 0:
                    """
                    i % pri_j == 0
                    换言之，i 之前被 pri_j 筛过了
                    由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被
                    pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break
                    掉就好了
                    """
                    break
    ```
</code></pre>
<p>上面的这种 <strong>线性筛法</strong> 也称为 <strong>Euler 筛法</strong>（欧拉筛法）。</p>
<p>???+ note "Note"
    注意到筛法求素数的同时也得到了每个数的最小质因子。</p>
<h2 id="_11">筛法求欧拉函数</h2>
<p>注意到在线性筛中，每一个合数都是被最小的质因子筛掉。比如设 <span class="arithmatex">\(p_1\)</span> 是 <span class="arithmatex">\(n\)</span> 的最小质因子，<span class="arithmatex">\(n' = \frac{n}{p_1}\)</span>，那么线性筛的过程中 <span class="arithmatex">\(n\)</span> 通过 <span class="arithmatex">\(n' \times p_1\)</span> 筛掉。</p>
<p>观察线性筛的过程，我们还需要处理两个部分，下面对 <span class="arithmatex">\(n' \bmod p_1\)</span> 分情况讨论。</p>
<p>如果 <span class="arithmatex">\(n' \bmod p_1 = 0\)</span>，那么 <span class="arithmatex">\(n'\)</span> 包含了 <span class="arithmatex">\(n\)</span> 的所有质因子。</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi(n) &amp; = n \times \prod_{i = 1}^s{\frac{p_i - 1}{p_i}} \\\\
&amp; = p_1 \times n' \times \prod_{i = 1}^s{\frac{p_i - 1}{p_i}} \\\\
&amp; = p_1 \times \varphi(n')
\end{aligned}
\]</div>
<p>那如果 <span class="arithmatex">\(n' \bmod p_1 \neq 0\)</span> 呢，这时 <span class="arithmatex">\(n'\)</span> 和 <span class="arithmatex">\(p_1\)</span> 是互质的，根据欧拉函数性质，我们有：</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi(n) &amp; = \varphi(p_1) \times \varphi(n') \\\\
&amp; = (p_1 - 1) \times \varphi(n')
\end{aligned}
\]</div>
<h3 id="_12">实现</h3>
<p>=== "C++"
    ```cpp
    vector<int> pri;
    bool not_prime[N];
    int phi[N];</p>
<pre><code>void pre(int n) {
  phi[1] = 1;
  for (int i = 2; i &lt;= n; i++) {
    if (!not_prime[i]) {
      pri.push_back(i);
      phi[i] = i - 1;
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        phi[i * pri_j] = phi[i] * pri_j;
        break;
      }
      phi[i * pri_j] = phi[i] * phi[pri_j];
    }
  }
}
```
</code></pre>
<p>=== "Python"
    ```python
    pri = []
    not_prime = [False] * N
    phi = [0] * N</p>
<pre><code>def pre(n):
    phi[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            phi[i] = i - 1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                phi[i * pri_j] = phi[i] * pri_j
                break
            phi[i * pri_j] = phi[i] * phi[pri_j]
```
</code></pre>
<h2 id="_13">筛法求莫比乌斯函数</h2>
<h3 id="_14">定义</h3>
<p>根据莫比乌斯函数的定义，设 <span class="arithmatex">\(n\)</span> 是一个合数，<span class="arithmatex">\(p_1\)</span> 是 <span class="arithmatex">\(n\)</span> 的最小质因子，<span class="arithmatex">\(n'=\frac{n}{p_1}\)</span>，有：</p>
<div class="arithmatex">\[
\mu(n)=
\begin{cases}
    0 &amp; n' \bmod p_1 = 0\\\\
    -\mu(n') &amp; \text{otherwise}
\end{cases}
\]</div>
<p>若 <span class="arithmatex">\(n\)</span> 是质数，有 <span class="arithmatex">\(\mu(n)=-1\)</span>。</p>
<h3 id="_15">实现</h3>
<p>=== "C++"
    ```cpp
    vector<int> pri;
    bool not_prime[N];
    int mu[N];</p>
<pre><code>void pre(int n) {
  mu[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    if (!not_prime[i]) {
      mu[i] = -1;
      pri.push_back(i);
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        mu[i * pri_j] = 0;
        break;
      }
      mu[i * pri_j] = -mu[i];
    }
  }
}
```
</code></pre>
<p>=== "Python"
    ```python
    pri = []
    not_prime = [False] * N
    mu = [0] * N</p>
<pre><code>def pre(n):
    mu[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            mu[i] = -1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                mu[i * pri_j] = 0
                break
            mu[i * pri_j] = -mu[i]
```
</code></pre>
<h2 id="_16">筛法求约数个数</h2>
<p>用 <span class="arithmatex">\(d_i\)</span> 表示 <span class="arithmatex">\(i\)</span> 的约数个数，<span class="arithmatex">\(num_i\)</span> 表示 <span class="arithmatex">\(i\)</span> 的最小质因子出现次数。</p>
<h3 id="_17">约数个数定理</h3>
<p>定理：若 <span class="arithmatex">\(n=\prod_{i=1}^m p_i^{c_i}\)</span> 则 <span class="arithmatex">\(d_i=\prod_{i=1}^m (c_i+1)\)</span>。</p>
<p>证明：我们知道 <span class="arithmatex">\(p_i^{c_i}\)</span> 的约数有 <span class="arithmatex">\(p_i^0,p_i^1,\dots ,p_i^{c_i}\)</span> 共 <span class="arithmatex">\(c_i+1\)</span> 个，根据乘法原理，<span class="arithmatex">\(n\)</span> 的约数个数就是 <span class="arithmatex">\(\prod_{i=1}^m (c_i+1)\)</span>。</p>
<h3 id="_18">实现</h3>
<p>因为 <span class="arithmatex">\(d_i\)</span> 是积性函数，所以可以使用线性筛。</p>
<p>在这里简单介绍一下线性筛实现原理。</p>
<ol>
<li>当 <span class="arithmatex">\(i\)</span> 为质数时，<span class="arithmatex">\(\textit{num}_i \gets 1,\textit{d}_i \gets 2\)</span>，同时设 <span class="arithmatex">\(q = \left\lfloor \dfrac {i}{p} \right\rfloor\)</span>，其中 <span class="arithmatex">\(p\)</span> 为 <span class="arithmatex">\(i\)</span> 的最小质因子。</li>
<li>当 <span class="arithmatex">\(p\)</span> 为 <span class="arithmatex">\(q\)</span> 的质因子时，<span class="arithmatex">\(\textit{num}_i \gets \textit{num}_q + 1,\textit{d}_i \gets \dfrac{\textit{d}_q}{\textit{num}_i} \times (\textit{num}_i + 1)\)</span>。</li>
<li>当 <span class="arithmatex">\(p,q\)</span> 互质时，<span class="arithmatex">\(\textit{num}_i \gets 1,\textit{d}_i \gets \textit{d}_q \times (\textit{num}_i+1)\)</span>。</li>
</ol>
<p>=== "C++"
    ```cpp
    vector<int> pri;
    bool not_prime[N];
    int d[N], num[N];</p>
<pre><code>void pre(int n) {
  d[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    if (!not_prime[i]) {
      pri.push_back(i);
      d[i] = 2;
      num[i] = 1;
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        num[i * pri_j] = num[i] + 1;
        d[i * pri_j] = d[i] / num[i * pri_j] * (num[i * pri_j] + 1);
        break;
      }
      num[i * pri_j] = 1;
      d[i * pri_j] = d[i] * 2;
    }
  }
}
```
</code></pre>
<p>=== "Python"
    ```python
    pri = []
    not_prime = [False] * N
    d = [0] * N
    num = [0] * N</p>
<pre><code>def pre(n):
    d[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            d[i] = 2
            num[i] = 1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                num[i * pri_j] = num[i] + 1
                d[i * pri_j] = d[i] // num[i * pri_j] * (num[i * pri_j] + 1)
                break
            num[i * pri_j] = 1
            d[i * pri_j] = d[i] * 2
```
</code></pre>
<h2 id="_19">筛法求约数和</h2>
<p><span class="arithmatex">\(f_i\)</span> 表示 <span class="arithmatex">\(i\)</span> 的约数和，<span class="arithmatex">\(g_i\)</span> 表示 <span class="arithmatex">\(i\)</span> 的最小质因子的 <span class="arithmatex">\(p^0+p^1+p^2+\dots p^k\)</span>.</p>
<h3 id="_20">实现</h3>
<p>=== "C++"
    ```cpp
    vector<int> pri;
    bool not_prime[N];
    int g[N], f[N];</p>
<pre><code>void pre(int n) {
  g[1] = f[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    if (!not_prime[i]) {
      pri.push_back(i);
      g[i] = i + 1;
      f[i] = i + 1;
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        g[i * pri_j] = g[i] * pri_j + 1;
        f[i * pri_j] = f[i] / g[i] * g[i * pri_j];
        break;
      }
      f[i * pri_j] = f[i] * f[pri_j];
      g[i * pri_j] = 1 + pri_j;
    }
  }
}
```
</code></pre>
<p>=== "Python"
    ```python
    pri = []
    not_prime = [False] * N
    f = [0] * N
    g = [0] * N</p>
<pre><code>def pre(n):
    g[1] = f[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            g[i] = i + 1
            f[i] = i + 1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                g[i * pri_j] = g[i] * pri_j + 1
                f[i * pri_j] = f[i] // g[i] * g[i * pri_j]
                break
            f[i * pri_j] = f[i] * f[pri_j]
            g[i * pri_j] = 1 + pri_j
```
</code></pre>
<h2 id="_21">一般的积性函数</h2>
<p>假如一个 <a href="../basic/#积性函数">积性函数</a>  <span class="arithmatex">\(f\)</span> 满足：对于任意质数 <span class="arithmatex">\(p\)</span> 和正整数 <span class="arithmatex">\(k\)</span>，可以在关于 <span class="arithmatex">\(k\)</span> 的低次多项式时间内计算 <span class="arithmatex">\(f(p^k)\)</span>，那么可以在 <span class="arithmatex">\(O(n)\)</span> 时间内筛出 <span class="arithmatex">\(f(1),f(2),\dots,f(n)\)</span> 的值。</p>
<p>设合数 <span class="arithmatex">\(n\)</span> 的质因子分解是 <span class="arithmatex">\(\prod_{i=1}^k p_i^{\alpha_i}\)</span>，其中 <span class="arithmatex">\(p_1&lt;p_2&lt;\dots&lt;p_k\)</span> 为质数，我们在线性筛中记录 <span class="arithmatex">\(g_n=p_1^{\alpha_1}\)</span>，假如 <span class="arithmatex">\(n\)</span> 被 <span class="arithmatex">\(x\cdot p\)</span> 筛掉（<span class="arithmatex">\(p\)</span> 是质数），那么 <span class="arithmatex">\(g\)</span> 满足如下递推式：</p>
<div class="arithmatex">\[
g_n=
\begin{cases}
    g_x\cdot p &amp; x\bmod p=0\\\\
    p &amp; \text{otherwise}
\end{cases}
\]</div>
<p>假如 <span class="arithmatex">\(n=g_n\)</span>，说明 <span class="arithmatex">\(n\)</span> 就是某个质数的次幂，可以 <span class="arithmatex">\(O(1)\)</span> 计算 <span class="arithmatex">\(f(n)\)</span>；否则，<span class="arithmatex">\(f(n)=f(\frac{n}{g_n})\cdot f(g_n)\)</span>。</p>
<p><strong>本节部分内容译自博文 <a href="http://e-maxx.ru/algo/eratosthenes_sieve">Решето Эратосфена</a> 与其英文翻译版 <a href="https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html">Sieve of Eratosthenes</a>。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong></p>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>