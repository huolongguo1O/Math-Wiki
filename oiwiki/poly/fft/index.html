
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="H-J-Granger, ranwen, abc1763613206, Ahacad, Allenyou1126, AndrewWayne, AngelKitty, AtomAlpaca, Backl1ght, billchenchina, c-forrest, CCXXXI, Cheuring, Chrogeek, ChungZH, countercurrent-time, DepletedPrism, Early0v0, EarthMessenger, Enter-tainer, F1shAndCat, GavinZhengOI, Gesrua, Great-designer, greyqz, Haohu Shen, henryrabbit, heroming, hly1204, Ir1d, isdanni, jiang1997, kenlig, Lewy Zeng, lucifer1004, Menci, muoshuosha, NachtgeistW, needtocalmdown, opsiff, ouuan, ouuan, partychicken, schtonn, Sshwy, sshwy, StudyingFather, SukkaW, Taoran-01, Tiphereth-A, TrisolarisHD, untitledunrevised, Xeonacid, YouXam, Yukimaikoriya">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Fft - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Fft
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../number-theory/basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../am-gm.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        引入
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      
        傅里叶变换
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      
        离散傅里叶变换
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="离散傅里叶变换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      
        矩阵公式
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
        快速傅里叶变换
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="快速傅里叶变换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
        分治法实现
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      
        倍增法实现
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="倍增法实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      
        位逆序置换
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      
        蝶形运算优化
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      
        快速傅里叶逆变换
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="快速傅里叶逆变换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      
        线性代数角度
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      
        单位复根周期性
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="单位复根周期性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      
        方法一
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      
        方法二
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      
        代码实现
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考文献
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Fft</h1>

<p>前置知识：<a href="../../complex/">复数</a>。</p>
<p>本文将介绍一种算法，它支持在 <span class="arithmatex">\(O(n\log n)\)</span> 的时间内计算两个 <span class="arithmatex">\(n\)</span> 次多项式的乘法，比朴素的 <span class="arithmatex">\(O(n^2)\)</span> 算法更高效。由于两个整数的乘法也可以被当作多项式乘法，因此这个算法也可以用来加速大整数的乘法计算。</p>
<h2 id="_1">引入</h2>
<p>我们现在引入两个多项式 <span class="arithmatex">\(A\)</span> 和 <span class="arithmatex">\(B\)</span>：</p>
<div class="arithmatex">\[
\begin{aligned}
A ={}&amp; 5x^2 + 3x + 7 \\
B ={}&amp; 7x^2 + 2x + 1 \\
\end{aligned}
\]</div>
<p>两个多项式相乘的积 <span class="arithmatex">\(C = A \times B\)</span>，我们可以在 <span class="arithmatex">\(O(n^2)\)</span> 的时间复杂度中解得（这里 <span class="arithmatex">\(n\)</span> 为 <span class="arithmatex">\(A\)</span> 或者 <span class="arithmatex">\(B\)</span> 多项式的次数）：</p>
<div class="arithmatex">\[
\begin{aligned}
C ={}&amp; A \times B \\
  ={}&amp; 35x^4 + 31x^3 + 60x^2 + 17x + 7
\end{aligned}
\]</div>
<p>很明显，多项式 <span class="arithmatex">\(C\)</span> 的系数 <span class="arithmatex">\(c_i\)</span> 满足 <span class="arithmatex">\(c_i = \sum_{j = 0}^i a_j b_{i - j}\)</span>。而对于这种朴素算法而言，计算每一项的时间复杂度都为 <span class="arithmatex">\(O(n)\)</span>，一共有 <span class="arithmatex">\(O(n)\)</span> 项，那么时间复杂度为 <span class="arithmatex">\(O(n^2)\)</span>。</p>
<p>能否加速使得它的时间复杂度降低呢？如果使用快速傅里叶变换的话，那么我们可以使得其复杂度降低到 <span class="arithmatex">\(O(n \log n)\)</span>。</p>
<h2 id="_2">傅里叶变换</h2>
<p>傅里叶变换（Fourier Transform）是一种分析信号的方法，它可分析信号的成分，也可用这些成分合成信号。许多波形可作为信号的成分，傅里叶变换用正弦波作为信号的成分。</p>
<p>设 <span class="arithmatex">\(f(t)\)</span> 是关于时间 <span class="arithmatex">\(t\)</span> 的函数，则傅里叶变换可以检测频率 <span class="arithmatex">\(\omega\)</span> 的周期在 <span class="arithmatex">\(f(t)\)</span> 出现的程度：</p>
<div class="arithmatex">\[
F(\omega)=\mathbb{F}[f(t)]=\int_{-\infty}^{\infty}f(t)\mathrm{e}^{-\mathrm{i}{\omega}t}dt
\]</div>
<p>它的逆变换是</p>
<div class="arithmatex">\[
f(t)=\mathbb{F}^{-1}[F(\omega)]=\frac{1}{2\pi}\int_{-\infty}^{\infty}F(\omega)\mathrm{e}^{\mathrm{i}{\omega}t}d\omega
\]</div>
<p>逆变换的形式与正变换非常类似，分母 <span class="arithmatex">\(2\pi\)</span> 恰好是指数函数的周期。</p>
<p>傅里叶变换相当于将时域的函数与周期为 <span class="arithmatex">\(2\pi\)</span> 的复指数函数进行连续的内积。逆变换仍旧为一个内积。</p>
<p>傅里叶变换有相应的卷积定理，可以将时域的卷积转化为频域的乘积，也可以将频域的卷积转化为时域的乘积。</p>
<h2 id="_3">离散傅里叶变换</h2>
<p><strong>离散傅里叶变换</strong>（Discrete Fourier transform，DFT）是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT（discrete-time Fourier transform）的频域采样。</p>
<p>傅里叶变换是积分形式的连续的函数内积，离散傅里叶变换是求和形式的内积。</p>
<p>设 <span class="arithmatex">\(\{x_n\}_{n=0}^{N-1}\)</span> 是某一满足有限性条件的序列，它的离散傅里叶变换（DFT）为：</p>
<div class="arithmatex">\[
X_k=\sum_{n=0}^{N-1}x_n\mathrm{e}^{-\mathrm{i}\frac{2\pi}{N}kn}
\]</div>
<p>其中 <span class="arithmatex">\(\mathrm{e}\)</span> 是自然对数的底数，<span class="arithmatex">\(i\)</span> 是虚数单位。通常以符号 <span class="arithmatex">\(\mathcal {F}\)</span> 表示这一变换，即</p>
<div class="arithmatex">\[
\hat{x}=\mathcal{F}x
\]</div>
<p>类似于积分形式，它的 <strong>逆离散傅里叶变换</strong>（IDFT）为：</p>
<div class="arithmatex">\[
x_n=\frac{1}{N}\sum_{k=0}^{N-1}X_k\mathrm{e}^{\mathrm{i}\frac{2\pi}{N}kn}
\]</div>
<p>可以记为：</p>
<div class="arithmatex">\[
x=\mathcal{F}^{-1}\hat{x}
\]</div>
<p>实际上，DFT 和 IDFT 变换式中和式前面的归一化系数并不重要。在上面的定义中，DFT 和 IDFT 前的系数分别为 <span class="arithmatex">\(1\)</span> 和 <span class="arithmatex">\(\frac {1}{N}\)</span>。有时我们会将这两个系数都改 <span class="arithmatex">\(\frac{1}{{\sqrt{N}}}\)</span>。</p>
<p>离散傅里叶变换仍旧是时域到频域的变换。由于求和形式的特殊性，可以有其他的解释方法。</p>
<p>如果把序列 <span class="arithmatex">\(x_n\)</span> 看作多项式 <span class="arithmatex">\(f(x)\)</span> 的 <span class="arithmatex">\(x^n\)</span> 项系数，则计算得到的 <span class="arithmatex">\(X_k\)</span> 恰好是多项式 <span class="arithmatex">\(f(x)\)</span> 代入单位根 <span class="arithmatex">\(\mathrm{e}^{\frac{-2\pi \mathrm{i}k}{N}}\)</span> 的点值 <span class="arithmatex">\(f(\mathrm{e}^{\frac{-2\pi \mathrm{i}k}{N}})\)</span>。</p>
<p>这便构成了卷积定理的另一种解释办法，即对多项式进行特殊的求值操作。离散傅里叶变换恰好是多项式在单位根处进行求值。</p>
<p>例如计算：</p>
<div class="arithmatex">\[
\dbinom{n}{3}+\dbinom{n}{7}+\dbinom{n}{11}+\dbinom{n}{15}+\ldots
\]</div>
<p>定义函数 <span class="arithmatex">\(f(x)\)</span> 为：</p>
<div class="arithmatex">\[
f(x)={(1+x)}^n=\dbinom{n}{0}x^0+\dbinom{n}{1}x^1+\dbinom{n}{2}x^2+\dbinom{n}{3}x^3+\ldots
\]</div>
<p>然后可以发现，代入四次单位根 <span class="arithmatex">\(f(\mathrm{i})\)</span> 得到这样的序列：</p>
<div class="arithmatex">\[
f(\mathrm{i})={(1+\mathrm{i})}^n=\dbinom{n}{0}+\dbinom{n}{1}\mathrm{i}-\dbinom{n}{2}-\dbinom{n}{3}\mathrm{i}+\ldots
\]</div>
<p>于是下面的求和恰好可以把其余各项消掉：</p>
<div class="arithmatex">\[
f(1)+\mathrm{i}f(\mathrm{i})-f(-1)-\mathrm{i}f(-\mathrm{i})=4\dbinom{n}{3}+4\dbinom{n}{7}+4\dbinom{n}{11}+4\dbinom{n}{15}+\ldots
\]</div>
<p>因此这道数学题的答案为：</p>
<div class="arithmatex">\[
\dbinom{n}{3}+\dbinom{n}{7}+\dbinom{n}{11}+\dbinom{n}{15}+\ldots=\frac{2^n+\mathrm{i}(1+\mathrm{i})^n-\mathrm{i}(1-\mathrm{i})^n}{4}
\]</div>
<p>这道数学题在单位根处求值，恰好构成离散傅里叶变换。</p>
<h3 id="_4">矩阵公式</h3>
<p>由于离散傅立叶变换是一个 <strong>线性</strong> 算子，所以它可以用矩阵乘法来描述。在矩阵表示法中，离散傅立叶变换表示如下：</p>
<div class="arithmatex">\[
\begin{bmatrix}
    X_{0}  \\
    X_{1}  \\
    X_{2}  \\
    \vdots \\
    X_{N-1}
\end{bmatrix}
=
\begin{bmatrix}
    1      &amp; 1            &amp; 1               &amp; \cdots &amp; 1                   \\
    1      &amp; \alpha       &amp; \alpha^{2}      &amp; \cdots &amp; \alpha^{N-1}        \\
    1      &amp; \alpha^{2}   &amp; \alpha^{4}      &amp; \cdots &amp; \alpha^{2(N-1)}     \\
    \vdots &amp; \vdots       &amp; \vdots          &amp; \ddots &amp; \vdots              \\
    1      &amp; \alpha^{N-1} &amp; \alpha^{2(N-1)} &amp; \cdots &amp; \alpha^{(N-1)(N-1)}
\end{bmatrix}
\begin{bmatrix}
    x_{0}  \\
    x_{1}  \\
    x_{2}  \\
    \vdots \\
    x_{N-1}
\end{bmatrix}
\]</div>
<p>其中 <span class="arithmatex">\(\alpha = \mathrm{e}^{-\mathrm{i}\frac{2\pi}{N}}\)</span>。</p>
<h2 id="_5">快速傅里叶变换</h2>
<p>FFT 是一种高效实现 DFT 的算法，称为快速傅立叶变换（Fast Fourier Transform，FFT）。它对傅里叶变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。快速数论变换（NTT）是快速傅里叶变换（FFT）在数论基础上的实现。</p>
<p>在 1965 年，Cooley 和 Tukey 发表了快速傅里叶变换算法。事实上 FFT 早在这之前就被发现过了，但是在当时现代计算机并未问世，人们没有意识到 FFT 的重要性。一些调查者认为 FFT 是由 Runge 和 König 在 1924 年发现的。但事实上高斯早在 1805 年就发明了这个算法，但一直没有发表。</p>
<h3 id="_6">分治法实现</h3>
<p>FFT 算法的基本思想是分治。就 DFT 来说，它分治地来求当 <span class="arithmatex">\(x=\omega_n^k\)</span> 的时候 <span class="arithmatex">\(f(x)\)</span> 的值。基 - 2 FFT 的分治思想体现在将多项式分为奇次项和偶次项处理。</p>
<p>举个例子，对于一共 <span class="arithmatex">\(8\)</span> 项的多项式：</p>
<div class="arithmatex">\[
f(x) = a_0 + a_1x + a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7
\]</div>
<p>按照次数的奇偶来分成两组，然后右边提出来一个 <span class="arithmatex">\(x\)</span>：</p>
<div class="arithmatex">\[
\begin{aligned}
f(x) &amp;= (a_0+a_2x^2+a_4x^4+a_6x^6) + (a_1x+a_3x^3+a_5x^5+a_7x^7)\\
     &amp;= (a_0+a_2x^2+a_4x^4+a_6x^6) + x(a_1+a_3x^2+a_5x^4+a_7x^6)
\end{aligned}
\]</div>
<p>分别用奇偶次次项数建立新的函数：</p>
<div class="arithmatex">\[
\begin{aligned}
G(x) &amp;= a_0+a_2x+a_4x^2+a_6x^3\\
H(x) &amp;= a_1+a_3x+a_5x^2+a_7x^3
\end{aligned}
\]</div>
<p>那么原来的 <span class="arithmatex">\(f(x)\)</span> 用新函数表示为：</p>
<div class="arithmatex">\[
f(x)=G\left(x^2\right) + x  \times  H\left(x^2\right)
\]</div>
<p>利用偶数次单位根的性质 <span class="arithmatex">\(\omega^i_n = -\omega^{i + n/2}_n\)</span>，和 <span class="arithmatex">\(G\left(x^2\right)\)</span> 和 <span class="arithmatex">\(H\left(x^2\right)\)</span> 是偶函数，我们知道在复平面上 <span class="arithmatex">\(\omega^i_n\)</span> 和 <span class="arithmatex">\(\omega^{i+n/2}_n\)</span> 的 <span class="arithmatex">\(G(x^2)\)</span> 的 <span class="arithmatex">\(H(x^2)\)</span> 对应的值相同。得到：</p>
<div class="arithmatex">\[
\begin{aligned}
f(\omega_n^k) &amp;= G((\omega_n^k)^2) + \omega_n^k  \times H((\omega_n^k)^2) \\
              &amp;= G(\omega_n^{2k}) + \omega_n^k  \times H(\omega_n^{2k}) \\
              &amp;= G(\omega_{n/2}^k) + \omega_n^k  \times H(\omega_{n/2}^k)
\end{aligned}
\]</div>
<p>和：</p>
<div class="arithmatex">\[
\begin{aligned}
f(\omega_n^{k+n/2}) &amp;= G(\omega_n^{2k+n}) + \omega_n^{k+n/2}  \times H(\omega_n^{2k+n}) \\
                    &amp;= G(\omega_n^{2k}) - \omega_n^k  \times H(\omega_n^{2k}) \\
                    &amp;= G(\omega_{n/2}^k) - \omega_n^k  \times H(\omega_{n/2}^k)
\end{aligned}
\]</div>
<p>因此我们求出了 <span class="arithmatex">\(G(\omega_{n/2}^k)\)</span> 和 <span class="arithmatex">\(H(\omega_{n/2}^k)\)</span> 后，就可以同时求出 <span class="arithmatex">\(f(\omega_n^k)\)</span> 和 <span class="arithmatex">\(f(\omega_n^{k+n/2})\)</span>。于是对 <span class="arithmatex">\(G\)</span> 和 <span class="arithmatex">\(H\)</span> 分别递归 DFT 即可。</p>
<p>考虑到分治 DFT 能处理的多项式长度只能是 <span class="arithmatex">\(2^m(m \in \mathbf{N}^ \ast )\)</span>，否则在分治的时候左右不一样长，右边就取不到系数了。所以要在第一次 DFT 之前就把序列向上补成长度为 <span class="arithmatex">\(2^m(m \in \mathbf{N}^\ast )\)</span>（高次系数补 <span class="arithmatex">\(0\)</span>）、最高项次数为 <span class="arithmatex">\(2^m-1\)</span> 的多项式。</p>
<p>在代入值的时候，因为要代入 <span class="arithmatex">\(n\)</span> 个不同值，所以我们代入 <span class="arithmatex">\(\omega_n^0,\omega_n^1,\omega_n^2,\cdots, \omega_n^{n-1} (n=2^m(m \in \mathbf{N}^ \ast ))\)</span> 一共 <span class="arithmatex">\(2^m\)</span> 个不同值。</p>
<p>代码实现方面，STL 提供了复数的模板，当然也可以手动实现。两者区别在于，使用 STL 的 <code>complex</code> 可以调用 <code>exp</code> 函数求出 <span class="arithmatex">\(\omega_n\)</span>。但事实上使用欧拉公式得到的虚数来求 <span class="arithmatex">\(\omega_n\)</span> 也是等价的。</p>
<p>以上就是 FFT 算法中 DFT 的介绍，它将一个多项式从系数表示法变成了点值表示法。</p>
<p>值的注意的是，因为是单位复根，所以说我们需要令 <span class="arithmatex">\(n\)</span> 项式的高位补为零，使得 <span class="arithmatex">\(n = 2 ^ k, k \in \mathbf{N}^ \ast\)</span>。</p>
<p>???+ note "递归版 FFT"
    ```cpp
    #include <cmath>
    #include <complex></p>
<pre><code>using Comp = std::complex&lt;double&gt;;  // STL complex

constexpr Comp I(0, 1);  // i
constexpr int MAX_N = 1 &lt;&lt; 20;

Comp tmp[MAX_N];

// rev=1, DFT; rev=-1, IDFT
// 应用完本函数后需要注意归一化系数的处理
void DFT(Comp* f, int n, int rev) {
  if (n == 1) return;
  for (int i = 0; i &lt; n; ++i) tmp[i] = f[i];
  // 偶数放左边，奇数放右边
  for (int i = 0; i &lt; n; ++i) {
    if (i &amp; 1)
      f[n / 2 + i / 2] = tmp[i];
    else
      f[i / 2] = tmp[i];
  }
  Comp *g = f, *h = f + n / 2;
  // 递归 DFT
  DFT(g, n / 2, rev), DFT(h, n / 2, rev);
  // cur 是当前单位复根，对于 k = 0 而言，它对应的单位复根 omega^0_n = 1。
  // step 是两个单位复根的差，即满足 omega^k_n = step*omega^{k-1}*n，
  // 定义等价于 exp(I*(-2*M_PI/n*rev))
  Comp cur(1, 0), step(cos(2 * M_PI / n), sin(-2 * M_PI * rev / n));
  for (int k = 0; k &lt; n / 2;
       ++k) {  // F(omega^k_n) = G(omega^k*{n/2}) + omega^k*n\*H(omega^k*{n/2})
    tmp[k] = g[k] + cur * h[k];
    // F(omega^{k+n/2}*n) = G(omega^k*{n/2}) - omega^k_n*H(omega^k\_{n/2})
    tmp[k + n / 2] = g[k] - cur * h[k];
    cur *= step;
  }
  for (int i = 0; i &lt; n; ++i) f[i] = tmp[i];
}
```
</code></pre>
<p>时间复杂度 <span class="arithmatex">\(O(n\log n)\)</span>。</p>
<h3 id="_7">倍增法实现</h3>
<p>这个算法还可以从「分治」的角度继续优化。对于基 - 2 FFT，我们每一次都会把整个多项式的奇数次项和偶数次项系数分开，一直分到只剩下一个系数。但是，这个递归的过程需要更多的内存。因此，我们可以先「模仿递归」把这些系数在原数组中「拆分」，然后再「倍增」地去合并这些算出来的值。</p>
<p>对于「拆分」，可以使用位逆序置换实现。</p>
<p>对于「合并」，使用蝶形运算优化可以做到只用 <span class="arithmatex">\(O(1)\)</span> 的额外空间来完成。</p>
<h4 id="_8">位逆序置换</h4>
<p>以 <span class="arithmatex">\(8\)</span> 项多项式为例，模拟拆分的过程：</p>
<ul>
<li>初始序列为 <span class="arithmatex">\(\{x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7\}\)</span></li>
<li>一次二分之后 <span class="arithmatex">\(\{x_0, x_2, x_4, x_6\},\{x_1, x_3, x_5, x_7 \}\)</span></li>
<li>两次二分之后 <span class="arithmatex">\(\{x_0,x_4\} \{x_2, x_6\},\{x_1, x_5\},\{x_3, x_7 \}\)</span></li>
<li>三次二分之后 <span class="arithmatex">\(\{x_0\}\{x_4\}\{x_2\}\{x_6\}\{x_1\}\{x_5\}\{x_3\}\{x_7 \}\)</span></li>
</ul>
<p>规律：其实就是原来的那个序列，每个数用二进制表示，然后把二进制翻转对称一下，就是最终那个位置的下标。比如 <span class="arithmatex">\(x_1\)</span> 是 001，翻转是 100，也就是 4，而且最后那个位置确实是 4。我们称这个变换为位逆序置换（bit-reversal permutation），证明留给读者自证。</p>
<p>根据它的定义，我们可以在 <span class="arithmatex">\(O(n)\)</span> 的时间内求出每个数变换后的结果：</p>
<p>???+ note "位逆序置换实现（<span class="arithmatex">\(O(n)\)</span>）"
    <code>cpp
    /*
     * 进行 FFT 和 IFFT 前的反置变换
     * 位置 i 和 i 的二进制反转后的位置互换
     * len 必须为 2 的幂
     */
    void change(Complex y[], int len) {
      // 一开始 i 是 0...01，而 j 是 10...0，在二进制下相反对称。
      // 之后 i 逐渐加一，而 j 依然维持着和 i 相反对称，一直到 i = 1...11。
      for (int i = 1, j = len / 2, k; i &lt; len - 1; i++) {
        // 交换互为小标反转的元素，i &lt; j 保证交换一次
        if (i &lt; j) swap(y[i], y[j]);
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的。
        // 这里 k 代表了 0 出现的最高位。j 先减去高位的全为 1 的数字，
        // 直到遇到了 0，之后再加上即可。
        // 考虑 j 中比特位的翻转次数，最高位将会翻转 n 次，
        // 第二高位将会翻转 n/2 次，以此类推，所以时间复杂度为：
        // T(n) = n + n/2 + n/4 + ... = O(n)
        k = len / 2;
        while (j &gt;= k) {
          j = j - k;
          k = k / 2;
        }
        j += k;
      }
    }</code></p>
<p>位逆序置换也可以 <span class="arithmatex">\(O(n)\)</span> 从小到大递推实现，设 <span class="arithmatex">\(len=2^k\)</span>，其中 <span class="arithmatex">\(k\)</span> 表示二进制数的长度，设 <span class="arithmatex">\(R(x)\)</span> 表示长度为 <span class="arithmatex">\(k\)</span> 的二进制数 <span class="arithmatex">\(x\)</span> 翻转后的数（高位补 <span class="arithmatex">\(0\)</span>）。我们要求的是 <span class="arithmatex">\(R(0),R(1),\cdots,R(n-1)\)</span>。</p>
<p>首先 <span class="arithmatex">\(R(0)=0\)</span>。</p>
<p>我们从小到大求 <span class="arithmatex">\(R(x)\)</span>。因此在求 <span class="arithmatex">\(R(x)\)</span> 时，<span class="arithmatex">\(R\left(\left\lfloor \dfrac{x}{2} \right\rfloor\right)\)</span> 的值是已知的。因此我们把 <span class="arithmatex">\(x\)</span> 右移一位（除以 <span class="arithmatex">\(2\)</span>），然后翻转，再右移一位，就得到了 <span class="arithmatex">\(x\)</span>  <strong>除了（二进制）个位</strong> 之外其它位的翻转结果。</p>
<p>考虑个位的翻转结果：如果个位是 <span class="arithmatex">\(0\)</span>，翻转之后最高位就是 <span class="arithmatex">\(0\)</span>。如果个位是 <span class="arithmatex">\(1\)</span>，则翻转后最高位是 <span class="arithmatex">\(1\)</span>，因此还要加上 <span class="arithmatex">\(\dfrac{len}{2}=2^{k-1}\)</span>。综上</p>
<div class="arithmatex">\[
R(x)=\left\lfloor \frac{R\left(\left\lfloor \frac{x}{2} \right\rfloor\right)}{2} \right\rfloor + (x\bmod 2)\times \frac{len}{2}
\]</div>
<p>举个例子：设 <span class="arithmatex">\(k=5\)</span>，<span class="arithmatex">\(len=(100000)_2\)</span>。为了翻转 <span class="arithmatex">\((11001)_2\)</span>：</p>
<ol>
<li>考虑 <span class="arithmatex">\((1100)_2\)</span>，我们知道 <span class="arithmatex">\(R((1100)_2)=R((01100)_2)=(00110)_2\)</span>，再右移一位就得到了 <span class="arithmatex">\((00011)_2\)</span>。</li>
<li>考虑个位，如果是 <span class="arithmatex">\(1\)</span>，它就要翻转到数的最高位，即翻转数加上 <span class="arithmatex">\((10000)_2=2^{k-1}\)</span>，如果是 <span class="arithmatex">\(0\)</span> 则不用更改。</li>
</ol>
<p>???+ note "位逆序置换实现（<span class="arithmatex">\(O(n)\)</span>）"
    <code>cpp
    // 同样需要保证 len 是 2 的幂
    // 记 rev[i] 为 i 翻转后的值
    void change(Complex y[], int len) {
      for (int i = 0; i &lt; len; ++i) {
        rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;
        if (i &amp; 1) {  // 如果最后一位是 1，则翻转成 len/2
          rev[i] |= len &gt;&gt; 1;
        }
      }
      for (int i = 0; i &lt; len; ++i) {
        if (i &lt; rev[i]) {  // 保证每对数只翻转一次
          swap(y[i], y[rev[i]]);
        }
      }
      return;
    }</code></p>
<h4 id="_9">蝶形运算优化</h4>
<p>已知 <span class="arithmatex">\(G(\omega_{n/2}^k)\)</span> 和 <span class="arithmatex">\(H(\omega_{n/2}^k)\)</span> 后，需要使用下面两个式子求出 <span class="arithmatex">\(f(\omega_n^k)\)</span> 和 <span class="arithmatex">\(f(\omega_n^{k+n/2})\)</span>：</p>
<div class="arithmatex">\[
\begin{aligned}
    f(\omega_n^k)       &amp; = G(\omega_{n/2}^k) + \omega_n^k \times H(\omega_{n/2}^k) \\
    f(\omega_n^{k+n/2}) &amp; = G(\omega_{n/2}^k) - \omega_n^k \times H(\omega_{n/2}^k)
\end{aligned}
\]</div>
<p>使用位逆序置换后，对于给定的 <span class="arithmatex">\(n, k\)</span>：</p>
<ul>
<li><span class="arithmatex">\(G(\omega_{n/2}^k)\)</span> 的值存储在数组下标为 <span class="arithmatex">\(k\)</span> 的位置，<span class="arithmatex">\(H(\omega_{n/2}^k)\)</span> 的值存储在数组下标为 <span class="arithmatex">\(k + \dfrac{n}{2}\)</span> 的位置。</li>
<li><span class="arithmatex">\(f(\omega_n^k)\)</span> 的值将存储在数组下标为 <span class="arithmatex">\(k\)</span> 的位置，<span class="arithmatex">\(f(\omega_n^{k+n/2})\)</span> 的值将存储在数组下标为 <span class="arithmatex">\(k + \dfrac{n}{2}\)</span> 的位置。</li>
</ul>
<p>因此可以直接在数组下标为 <span class="arithmatex">\(k\)</span> 和 <span class="arithmatex">\(k + \frac{n}{2}\)</span> 的位置进行覆写，而不用开额外的数组保存值。此方法即称为 <strong>蝶形运算</strong>，或更准确的，基 - 2 蝶形运算。</p>
<p>再详细说明一下如何借助蝶形运算完成所有段长度为 <span class="arithmatex">\(\frac{n}{2}\)</span> 的合并操作：</p>
<ol>
<li>令段长度为 <span class="arithmatex">\(s = \frac{n}{2}\)</span>；</li>
<li>同时枚举序列 <span class="arithmatex">\(\{G(\omega_{n/2}^k)\}\)</span> 的左端点 <span class="arithmatex">\(l_g = 0, 2s, 4s, \cdots, N-2s\)</span> 和序列 <span class="arithmatex">\(\{H(\omega_{n/2}^k)\}\)</span> 的左端点 <span class="arithmatex">\(l_h = s, 3s, 5s, \cdots, N-s\)</span>；</li>
<li>合并两个段时，枚举 <span class="arithmatex">\(k = 0, 1, 2, \cdots, s-1\)</span>，此时 <span class="arithmatex">\(G(\omega_{n/2}^k)\)</span> 存储在数组下标为 <span class="arithmatex">\(l_g + k\)</span> 的位置，<span class="arithmatex">\(H(\omega_{n/2}^k)\)</span> 存储在数组下标为 <span class="arithmatex">\(l_h + k\)</span> 的位置；</li>
<li>使用蝶形运算求出 <span class="arithmatex">\(f(\omega_n^k)\)</span> 和 <span class="arithmatex">\(f(\omega_n^{k+n/2})\)</span>，然后直接在原位置覆写。</li>
</ol>
<h2 id="_10">快速傅里叶逆变换</h2>
<p>傅里叶逆变换可以用傅里叶变换表示。对此我们有两种理解方式。</p>
<h3 id="_11">线性代数角度</h3>
<p>IDFT（傅里叶反变换）的作用，是把目标多项式的点值形式转换成系数形式。而 DFT 本身是个线性变换，可以理解为将目标多项式当作向量，左乘一个矩阵得到变换后的向量，以模拟把单位复根代入多项式的过程：</p>
<div class="arithmatex">\[
\begin{bmatrix}y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1} \end{bmatrix}
=
\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \omega_n^2 &amp; \omega_n^3 &amp; \cdots &amp; \omega_n^{n-1} \\
1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \omega_n^6 &amp; \cdots &amp; \omega_n^{2(n-1)} \\
1 &amp; \omega_n^3 &amp; \omega_n^6 &amp; \omega_n^9 &amp; \cdots &amp; \omega_n^{3(n-1)} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \omega_n^{3(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)^2} \end{bmatrix}
\begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1} \end{bmatrix}
\]</div>
<p>现在我们已经得到最左边的结果了，中间的 <span class="arithmatex">\(x\)</span> 值在目标多项式的点值表示中也是一一对应的，所以，根据矩阵的基础知识，我们只要在式子两边左乘中间那个大矩阵的逆矩阵就行了。</p>
<p>由于这个矩阵的元素非常特殊，它的逆矩阵也有特殊的性质，就是每一项 <strong>取倒数</strong>，再 <strong>除以变换的长度 <span class="arithmatex">\(n\)</span></strong>，就能得到它的逆矩阵。</p>
<p>注意：傅里叶变换的长度，并不是多项式的长度，变换的长度应比乘积多项式的长度长。待相乘的多项式不够长，需要在高次项处补 <span class="arithmatex">\(0\)</span>。</p>
<p>为了使计算的结果为原来的倒数，根据欧拉公式，可以得到</p>
<div class="arithmatex">\[
\frac{1}{\omega_k}=\omega_k^{-1}=\mathrm{e}^{-\frac{2\pi \mathrm{i}}{k}}=\cos\left(\frac{2\pi}{k}\right)+\mathrm{i} \sin\left(-\frac{2\pi}{k}\right)
\]</div>
<p>因此我们可以尝试着把单位根 <span class="arithmatex">\(\omega_k\)</span> 取成 <span class="arithmatex">\(\mathrm{e}^{-\frac{2\pi \mathrm{i}}{k}}\)</span>，这样我们的计算结果就会变成原来的倒数，之后唯一多的操作就只有再 <strong>除以它的长度 <span class="arithmatex">\(n\)</span></strong>，而其它的操作过程与 DFT 是完全相同的。我们可以定义一个函数，在里面加一个参数 <span class="arithmatex">\(1\)</span> 或者是 <span class="arithmatex">\(-1\)</span>，然后把它乘到 <span class="arithmatex">\(\pi\)</span> 上。传入 <span class="arithmatex">\(1\)</span> 就是 DFT，传入 <span class="arithmatex">\(-1\)</span> 就是 IDFT。</p>
<h3 id="_12">单位复根周期性</h3>
<p>利用单位复根的周期性同样可以理解 IDFT 与 DFT 之间的关系。</p>
<p>考虑原本的多项式是 <span class="arithmatex">\(f(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}=\sum_{i=0}^{n-1}a_ix^i\)</span>。而 IDFT 就是把你的点值表示还原为系数表示。</p>
<p>考虑 <strong>构造法</strong>。我们已知 <span class="arithmatex">\(y_i=f\left( \omega_n^i \right),i\in\{0,1,\cdots,n-1\}\)</span>，求 <span class="arithmatex">\(\{a_0,a_1,\cdots,a_{n-1}\}\)</span>。构造多项式如下</p>
<div class="arithmatex">\[
A(x)=\sum_{i=0}^{n-1}y_ix^i
\]</div>
<p>相当于把 <span class="arithmatex">\(\{y_0,y_1,y_2,\cdots,y_{n-1}\}\)</span> 当做多项式 <span class="arithmatex">\(A\)</span> 的系数表示法。</p>
<p>这时我们有两种推导方式，这对应了两种实现方法。</p>
<h4 id="_13">方法一</h4>
<p>设 <span class="arithmatex">\(b_i=\omega_n^{-i}\)</span>，则多项式 <span class="arithmatex">\(A\)</span> 在 <span class="arithmatex">\(x=b_0,b_1,\cdots,b_{n-1}\)</span> 处的点值表示法为 <span class="arithmatex">\(\left\{ A(b_0),A(b_1),\cdots,A(b_{n-1}) \right\}\)</span>。</p>
<p>对 <span class="arithmatex">\(A(x)\)</span> 的定义式做一下变换，可以将 <span class="arithmatex">\(A(b_k)\)</span> 表示为</p>
<div class="arithmatex">\[
\begin{aligned}
A(b_k)&amp;=\sum_{i=0}^{n-1}f(\omega_n^i)\omega_n^{-ik}=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^{j}\\
&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{i(j-k)}=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}\left(\omega_n^{j-k}\right)^i\\
\end{aligned}
\]</div>
<p>记 <span class="arithmatex">\(S\left(\omega_n^a\right)=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i\)</span>。</p>
<p>当 <span class="arithmatex">\(a=0 \pmod{n}\)</span> 时，<span class="arithmatex">\(S\left(\omega_n^a\right)=n\)</span>。</p>
<p>当 <span class="arithmatex">\(a\neq 0 \pmod{n}\)</span> 时，我们错位相减</p>
<div class="arithmatex">\[
\begin{aligned}
S\left(\omega_n^a\right)&amp;=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i\\
\omega_n^a S\left(\omega_n^a\right)&amp;=\sum_{i=1}^{n}\left(\omega_n^a\right)^i\\
S\left(\omega_n^a\right)&amp;=\frac{\left(\omega_n^a\right)^n-\left(\omega_n^a\right)^0}{\omega_n^a-1}=0\\
\end{aligned}
\]</div>
<p>也就是说</p>
<div class="arithmatex">\[
S\left(\omega_n^a\right)=
\begin{cases}
n,&amp;a=0\\
0,&amp;a\neq 0
\end{cases}
\]</div>
<p>那么代回原式</p>
<div class="arithmatex">\[
A(b_k)=\sum_{j=0}^{n-1}a_jS\left(\omega_n^{j-k}\right)=a_k\cdot n
\]</div>
<p>也就是说给定点 <span class="arithmatex">\(b_i=\omega_n^{-i}\)</span>，则 <span class="arithmatex">\(A\)</span> 的点值表示法为</p>
<div class="arithmatex">\[
\begin{aligned}
&amp;\left\{ (b_0,A(b_0)),(b_1,A(b_1)),\cdots,(b_{n-1},A(b_{n-1})) \right\}\\
=&amp;\left\{ (b_0,a_0\cdot n),(b_1,a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n) \right\}
\end{aligned}
\]</div>
<p>综上所述，我们取单位根为其倒数，对 <span class="arithmatex">\(\{y_0,y_1,y_2,\cdots,y_{n-1}\}\)</span> 跑一遍 FFT，然后除以 <span class="arithmatex">\(n\)</span> 即可得到 <span class="arithmatex">\(f(x)\)</span> 的系数表示。</p>
<h4 id="_14">方法二</h4>
<p>我们直接将 <span class="arithmatex">\(\omega_n^i\)</span> 代入 <span class="arithmatex">\(A(x)\)</span>。</p>
<p>推导的过程与方法一大同小异，最终我们得到 <span class="arithmatex">\(A(\omega_n^k) = \sum_{j=0}^{n-1}a_jS\left(\omega_n^{j+k}\right)\)</span>。</p>
<p>当且仅当 <span class="arithmatex">\(j+k=0 \pmod{n}\)</span> 时有 <span class="arithmatex">\(S\left(\omega_n^{j+k}\right) = n\)</span>，否则为 <span class="arithmatex">\(0\)</span>。因此 <span class="arithmatex">\(A(\omega_n^k) = a_{n-k}\cdot n\)</span>。</p>
<p>这意味着我们将 <span class="arithmatex">\(\{y_0,y_1,y_2,\cdots,y_{n-1}\}\)</span> 做 DFT 变换后除以 <span class="arithmatex">\(n\)</span>，再反转后 <span class="arithmatex">\(n - 1\)</span> 个元素，同样可以还原 <span class="arithmatex">\(f(x)\)</span> 的系数表示。</p>
<h3 id="_15">代码实现</h3>
<p>所以我们 FFT 函数可以集 DFT 和 IDFT 于一身。代码实现如下：</p>
<p>???+ note "非递归版 FFT（对应方法一）"
    <code>cpp
    /*
     * 做 FFT
     * len 必须是 2^k 形式
     * on == 1 时是 DFT，on == -1 时是 IDFT
     */
    void fft(Complex y[], int len, int on) {
      // 位逆序置换
      change(y, len);
      // 模拟合并过程，一开始，从长度为一合并到长度为二，一直合并到长度为 len。
      for (int h = 2; h &lt;= len; h &lt;&lt;= 1) {
        // wn：当前单位复根的间隔：w^1_h
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));
        // 合并，共 len / h 次。
        for (int j = 0; j &lt; len; j += h) {
          // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
          // ...
          Complex w(1, 0);
          for (int k = j; k &lt; j + h / 2; k++) {
            // 左侧部分和右侧是子问题的解
            Complex u = y[k];
            Complex t = w * y[k + h / 2];
            // 这就是把两部分分治的结果加起来
            y[k] = u + t;
            y[k + h / 2] = u - t;
            // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
            // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
            // 一个数相反数的平方与这个数自身的平方相等
            w = w * wn;
          }
        }
      }
      // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
      if (on == -1) {
        for (int i = 0; i &lt; len; i++) {
          y[i].x /= len;
          y[i].y /= len;
        }
      }
    }</code></p>
<p>???+ note "非递归版 FFT（对应方法二）"
    <code>cpp
    /*
     * 做 FFT
     * len 必须是 2^k 形式
     * on == 1 时是 DFT，on == -1 时是 IDFT
     */
    void fft(Complex y[], int len, int on) {
      change(y, len);
      for (int h = 2; h &lt;= len; h &lt;&lt;= 1) {             // 模拟合并过程
        Complex wn(cos(2 * PI / h), sin(2 * PI / h));  // 计算当前单位复根
        for (int j = 0; j &lt; len; j += h) {
          Complex w(1, 0);  // 计算当前单位复根
          for (int k = j; k &lt; j + h / 2; k++) {
            Complex u = y[k];
            Complex t = w * y[k + h / 2];
            y[k] = u + t;  // 这就是把两部分分治的结果加起来
            y[k + h / 2] = u - t;
            // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
            // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
            // 一个数相反数的平方与这个数自身的平方相等
            w = w * wn;
          }
        }
      }
      if (on == -1) {
        reverse(y + 1, y + len);
        for (int i = 0; i &lt; len; i++) {
          y[i].x /= len;
          y[i].y /= len;
        }
      }
    }</code></p>
<p>??? note "FFT 模板（<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1402">HDU 1402 - A * B Problem Plus</a>）"
    <code>cpp
    --8&lt;-- "docs/math/code/poly/fft/fft_3.cpp"</code></p>
<h2 id="_16">参考文献</h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/41867199">桃酱的算法笔记</a>.</li>
</ol>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>