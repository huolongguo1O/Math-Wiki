
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="jifbt, billchenchina, Enter-tainer, Great-designer, iamtwz, ImpleLee, isdanni, Menci, ouuan, Tiphereth-A, warzone-oier, Xeonacid, c-forrest, cervoliu">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Group theory - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#引入" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Group theory
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../number-theory/basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/am-gm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/cauchy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    柯西不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mod-arithmetic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    模运算
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    质数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/gcd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最大公约数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/euler-function.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/linear-congruence-equation.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    线性同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic-residue.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/lifting-the-exponent.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../number-theory/quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#引入" class="md-nav__link">
    <span class="md-ellipsis">
      
        引入
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#子群" class="md-nav__link">
    <span class="md-ellipsis">
      
        子群
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="子群">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#由子集生成的子群" class="md-nav__link">
    <span class="md-ellipsis">
      
        由子集生成的子群
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#循环群" class="md-nav__link">
    <span class="md-ellipsis">
      
        循环群
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#阶" class="md-nav__link">
    <span class="md-ellipsis">
      
        阶
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#陪集" class="md-nav__link">
    <span class="md-ellipsis">
      
        陪集
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#正规子群" class="md-nav__link">
    <span class="md-ellipsis">
      
        正规子群
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#商群" class="md-nav__link">
    <span class="md-ellipsis">
      
        商群
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#群同态" class="md-nav__link">
    <span class="md-ellipsis">
      
        群同态
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="群同态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#群同构" class="md-nav__link">
    <span class="md-ellipsis">
      
        群同构
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#同态的核" class="md-nav__link">
    <span class="md-ellipsis">
      
        同态的核
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#同态基本定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        同态基本定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#自然同态" class="md-nav__link">
    <span class="md-ellipsis">
      
        自然同态
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#群的同构定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        群的同构定理
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#群作用" class="md-nav__link">
    <span class="md-ellipsis">
      
        群作用
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="群作用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#轨道" class="md-nav__link">
    <span class="md-ellipsis">
      
        轨道
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#稳定化子" class="md-nav__link">
    <span class="md-ellipsis">
      
        稳定化子
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#burnside-引理" class="md-nav__link">
    <span class="md-ellipsis">
      
        Burnside 引理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cayley-定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cayley 定理
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#共轭作用" class="md-nav__link">
    <span class="md-ellipsis">
      
        共轭作用
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#正规化子和中心化子" class="md-nav__link">
    <span class="md-ellipsis">
      
        正规化子和中心化子
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sylow-定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        Sylow 定理
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#有限生成-abel-群" class="md-nav__link">
    <span class="md-ellipsis">
      
        有限生成 Abel 群
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="有限生成 Abel 群">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#直积" class="md-nav__link">
    <span class="md-ellipsis">
      
        直积
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#分类定理" class="md-nav__link">
    <span class="md-ellipsis">
      
        分类定理
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#参考资料与注释" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Group theory</h1>

<p>前置知识：<a href="../basic/">抽象代数基本概念</a>、<a href="../../permutation/">置换与排列</a></p>
<h2 id="引入">引入<a class="headerlink" href="#引入" title="Permanent link"></a></h2>
<p><strong>群论</strong>（group theory）主要研究群这个 <a href="https://en.wikipedia.org/wiki/Algebraic_structure">代数结构</a>。</p>
<p>为了研究群的结构，需要掌握一些基本工具，这包括子群、群同态和群作用。算法竞赛中，主要涉及到的群是数论相关的群（比如整数模 <span class="arithmatex">\(n\)</span> 乘法群 <span class="arithmatex">\((\mathbf Z/n\mathbf Z)^\times\)</span>）以及置换群，本文将着重介绍相关的概念。本文未涉及的群论部分，比如有限群的结构理论和群的线性表示理论，有兴趣的读者应当参考专业书籍。</p>
<details class="info" open="open">
<summary>记号</summary>
<p>在不引起歧义时，本文可能会将 <span class="arithmatex">\(g\cdot h\)</span> 写作 <span class="arithmatex">\(gh\)</span>，也可能会将群 <span class="arithmatex">\((G,\cdot)\)</span> 写作群 <span class="arithmatex">\(G\)</span>。</p>
</details>
<p>理解抽象代数不能够离开实例。作为理解下文概念的例子，这里讨论正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span></summary>
<p>如图所示，对于给定正三角形，共计有六种不同的操作可以使得它与自身重合。</p>
<p><img alt="正三角形的空间对称群 D_6" src="../../images/triangle_d6.svg" /></p>
<p>这里，使用 <span class="arithmatex">\(r\)</span> 表示顺时针旋转，使用 <span class="arithmatex">\(s\)</span> 表示沿顶点 <span class="arithmatex">\(1\)</span> 到三角形中心的连线翻转，操作自右向左复合，即 <span class="arithmatex">\(sr\)</span> 表示先旋转（<span class="arithmatex">\(r\)</span>）再翻转（<span class="arithmatex">\(s\)</span>）。两个操作不同，当且仅当某个三角形的顶点在两个操作之后所处位置不同。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">记号</th>
<th style="text-align: center;">操作</th>
<th style="text-align: center;">阶</th>
<th style="text-align: center;">置换表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(e\)</span></td>
<td style="text-align: center;">恒等变换，即什么也不做</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="arithmatex">\((1)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(r\)</span></td>
<td style="text-align: center;">顺时针旋转 <span class="arithmatex">\(120^\circ\)</span></td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="arithmatex">\((123)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(r^2\)</span></td>
<td style="text-align: center;">顺时针旋转 <span class="arithmatex">\(240^\circ\)</span></td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="arithmatex">\((132)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(s\)</span></td>
<td style="text-align: center;">沿 <span class="arithmatex">\(1\)</span> 到中心连线翻转</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="arithmatex">\((23)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(sr\)</span></td>
<td style="text-align: center;">先旋转 <span class="arithmatex">\(120^\circ\)</span>，再翻转</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="arithmatex">\((13)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(sr^2\)</span></td>
<td style="text-align: center;">先旋转 <span class="arithmatex">\(240^\circ\)</span>，再翻转</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="arithmatex">\((12)\)</span></td>
</tr>
</tbody>
</table>
<p>容易验证，这些操作确实构成了群。比如说，该群的单位元是 <span class="arithmatex">\(e\)</span>，而 <span class="arithmatex">\(sr\)</span> 的逆元是它自身。而且，群 <span class="arithmatex">\(D_6\)</span> 并不是交换群，比如可以直接验证 <span class="arithmatex">\(rs=sr^{-1}\)</span>。</p>
<p>表中记录的操作并不是该记号对应的唯一的对称操作。比如，「沿 <span class="arithmatex">\(2\)</span> 到中心的连线翻转」也是三角形的对称操作，它不在表中，但它的结果和操作「先旋转 <span class="arithmatex">\(120^\circ\)</span>，再翻转」相同。表中的「阶」和「置换表示」等概念下文会给予说明。</p>
</details>
<h2 id="子群">子群<a class="headerlink" href="#子群" title="Permanent link"></a></h2>
<p>要理解给定群的结构，可以首先分析其子结构。群的子结构就是那些在同一运算下仍然成为一个群的该群的子集。由此，有如下定义。</p>
<details class="abstract" open="open">
<summary>子群</summary>
<p>对于群 <span class="arithmatex">\((G,\cdot)\)</span> 和它的一个子集 <span class="arithmatex">\(H\subseteq G\)</span>，如果 <span class="arithmatex">\((H,\cdot)\)</span> 也是一个群，则称子集 <span class="arithmatex">\(H\)</span> 是 <span class="arithmatex">\(G\)</span> 的一个 <strong>子群</strong>（subgroup），记作 <span class="arithmatex">\(H\le G\)</span>。</p>
</details>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>在 <span class="arithmatex">\(D_6\)</span> 中，容易验证它的子群有 <span class="arithmatex">\(\{e\}\)</span>，<span class="arithmatex">\(\{e,s\}\)</span>，<span class="arithmatex">\(\{e,sr\}\)</span>，<span class="arithmatex">\(\{e,sr^2\}\)</span>，<span class="arithmatex">\(\{e,r,r^2\}\)</span> 和 <span class="arithmatex">\(D_6\)</span> 本身，共计六个。除群 <span class="arithmatex">\(D_6\)</span> 外，这些子群的结构都是更为简单，而且蕴含了关于原来群的部分信息。</p>
</details>
<p>要判断给定子集 <span class="arithmatex">\(H\subseteq G\)</span> 是不是子群，并不需要逐一验证群的定义：结合律自然成立；子集成为子群，只要保证它对二元运算封闭、有单位元且对取逆封闭就好了。事实上，这些条件可以总结在一起。</p>
<details class="note" open="open">
<summary>定理（子群判别法）</summary>
<p>群 <span class="arithmatex">\(G\)</span> 的子集 <span class="arithmatex">\(H\)</span> 是子群，当且仅当，对于所有元素 <span class="arithmatex">\(g,h \in H\)</span> 都有 <span class="arithmatex">\(g^{-1}h\in H\)</span>。</p>
</details>
<h3 id="由子集生成的子群">由子集生成的子群<a class="headerlink" href="#由子集生成的子群" title="Permanent link"></a></h3>
<p>一般地，给定群 <span class="arithmatex">\(G\)</span> 中的子集 <span class="arithmatex">\(S\)</span>，从 <span class="arithmatex">\(S\)</span> 中的元素出发，重复进行乘法和取逆运算有限次，能够得到的所有结果的集合成为 <span class="arithmatex">\(G\)</span> 的一个子群。这称为由子集 <span class="arithmatex">\(S\)</span> 生成的子群。</p>
<details class="abstract" open="open">
<summary>由子集生成的子群</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的非空子集 <span class="arithmatex">\(S\subseteq G\)</span>，如果 <span class="arithmatex">\(H\)</span> 是包含 <span class="arithmatex">\(S\)</span> 的 <span class="arithmatex">\(G\)</span> 的子群中（依包含关系）最小的，则子群 <span class="arithmatex">\(H\)</span> 称为 <strong>由子集 <span class="arithmatex">\(S\)</span> 生成的子群</strong>（subgroup generated by a subset），并记作 <span class="arithmatex">\(\langle S\rangle\)</span>。特别地，如果 <span class="arithmatex">\(S=\{x\}\)</span> 是单元素集合，则 <span class="arithmatex">\(\langle S\rangle\)</span> 也记作 <span class="arithmatex">\(\langle x\rangle\)</span>，称为 <span class="arithmatex">\(x\)</span> 的幂的循环子群（cyclic subgroup of the powers of an element）。</p>
</details>
<p>可以证明，任给定这样的子集 <span class="arithmatex">\(S\)</span>，总能找到这样的子群：<span class="arithmatex">\(\langle S\rangle\)</span> 可以构造为所有包含 <span class="arithmatex">\(S\)</span> 的 <span class="arithmatex">\(G\)</span> 的子群的交。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>在群 <span class="arithmatex">\(D_6\)</span> 中选定旋转操作 <span class="arithmatex">\(r\)</span>，重复应用它和它的逆操作，就得到子群 <span class="arithmatex">\(\{e,r,r^2\}\)</span>。它可以记作 <span class="arithmatex">\(\langle r\rangle\)</span>。群 <span class="arithmatex">\(D_6\)</span> 中的所有非平凡子群都可以通过选定某个操作来生成。</p>
</details>
<p>有些子集生成的子群是群本身。这样的子集尤为特殊，称为群的生成子集。</p>
<details class="abstract" open="open">
<summary>群的生成子集</summary>
<p>如果群 <span class="arithmatex">\((G,\cdot)\)</span> 的子集 <span class="arithmatex">\(S\subseteq G\)</span> 满足 <span class="arithmatex">\(\langle S\rangle=G\)</span>，则称 <span class="arithmatex">\(S\)</span> 是 <span class="arithmatex">\(G\)</span> 的 <strong>生成子集</strong>（generating set of a group）。生成子集 <span class="arithmatex">\(S\)</span> 中的元素称为 <strong>生成元</strong>（generator）。</p>
</details>
<p>群是自身平凡的生成子集。更为有趣的情形是，生成子集远小于群本身的规模。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>可以验证，<span class="arithmatex">\(D_6=\langle s,r\rangle\)</span>，这就是说，任何正三角形的对称操作都可以通过旋转和翻转的复合得到。</p>
</details>
<h3 id="循环群">循环群<a class="headerlink" href="#循环群" title="Permanent link"></a></h3>
<p>仅由一个元素生成的群的结构非常简单。这样的群称为循环群。</p>
<details class="abstract" open="open">
<summary>循环群</summary>
<p>对于群 <span class="arithmatex">\(G\)</span>，如果存在 <span class="arithmatex">\(x\in G\)</span>，成立 <span class="arithmatex">\(G=\langle x\rangle\)</span>，则称 <span class="arithmatex">\(G\)</span> 是一个 <strong>循环群</strong>（cyclic group）。</p>
</details>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>所有 <span class="arithmatex">\(D_6\)</span> 的非平凡子群以及 <span class="arithmatex">\(\{e\}\)</span> 都是循环群。</p>
</details>
<p>可以证明，循环群的结构由其大小唯一确定。如果循环群无限，则它必然和整数的加法群 <span class="arithmatex">\((\mathbf Z,+)\)</span> 具有相同的群结构，记作 <span class="arithmatex">\(C_\infty\)</span> 或 <span class="arithmatex">\(\mathbf Z\)</span>；否则，记群的元素个数为 <span class="arithmatex">\(n\in\mathbf N_+\)</span>，则它必然和整数模 <span class="arithmatex">\(n\)</span> 的同余类的加法群 <span class="arithmatex">\((\mathbf Z/n\mathbf Z,+)\)</span> 具有相同的群结构，记作 <span class="arithmatex">\(C_n\)</span> 或 <span class="arithmatex">\(\mathbf Z_n\)</span>。这一结论的严格叙述需要用到下文的 <a href="#群同构">群同构</a> 的概念，它严格描述了两个群结构相同这一事实。</p>
<details class="note" open="open">
<summary>循环群分类定理</summary>
<p>大小为 <span class="arithmatex">\(n\)</span> 的有限循环群 <span class="arithmatex">\(G\)</span> 同构于 <span class="arithmatex">\(C_n\)</span>；无限循环群 <span class="arithmatex">\(G\)</span> 同构于 <span class="arithmatex">\(C_\infty\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>给定循环群 <span class="arithmatex">\(G=\langle x\rangle\)</span>，它总可以写作 <span class="arithmatex">\(G=\{x^n:n\in\mathbf Z\}\)</span>。如果群 <span class="arithmatex">\(G\)</span> 有限，那么必然存在自然数 <span class="arithmatex">\(n&lt;m\)</span> 满足 <span class="arithmatex">\(x^n=x^m\)</span>，依消去律，可以得到 <span class="arithmatex">\(x^{m-n}=e\)</span>。此时，不妨取最小的正整数 <span class="arithmatex">\(n\in\mathbf N_+\)</span> 使得 <span class="arithmatex">\(x^n=e\)</span>，那么列 <span class="arithmatex">\(\{x^k\}\)</span> 将会是长度为 <span class="arithmatex">\(n\)</span> 的循环，且循环节内元素各不相同（否则违反 <span class="arithmatex">\(n\)</span> 的最小性）。此时，映射 <span class="arithmatex">\(x^k\mapsto\bar k\)</span> 就提供了同构映射 <span class="arithmatex">\(G\rightarrow\mathbf Z/n\mathbf Z\)</span>，亦即 <span class="arithmatex">\(G\cong C_n\)</span>。反之，如果群 <span class="arithmatex">\(G\)</span> 无限，那么群 <span class="arithmatex">\(G\)</span> 内元素各不相同，映射 <span class="arithmatex">\(x^k\mapsto k\)</span> 就提供了同构映射 <span class="arithmatex">\(G\rightarrow\mathbf Z\)</span>，亦即 <span class="arithmatex">\(G\cong C_\infty\)</span>。</p>
</details>
<p>所有循环群都是 Abel 群。本文的例子 <span class="arithmatex">\(D_6\)</span> 说明，即使群的所有非平凡子群都是循环群，群本身也可能不是 Abel 群。</p>
<h3 id="阶">阶<a class="headerlink" href="#阶" title="Permanent link"></a></h3>
<p>群的阶就是群的元素的个数。群内给定元素的阶就是该元素生成的循环子群的阶。由此，有如下定义：</p>
<details class="abstract" open="open">
<summary>群的阶</summary>
<p>群 <span class="arithmatex">\(G\)</span> 的 <strong>阶</strong>（order）是它的元素个数，记作 <span class="arithmatex">\(|G|\)</span>。无限群的阶也是无限。</p>
</details>
<details class="abstract" open="open">
<summary>元素的阶</summary>
<p>群 <span class="arithmatex">\(G\)</span> 中元素 <span class="arithmatex">\(x\in G\)</span> 的 <strong>阶</strong>（order）是最小的正整数 <span class="arithmatex">\(n\)</span> 使得 <span class="arithmatex">\(x^n=e\)</span> 成立，记作 <span class="arithmatex">\(|x|\)</span>；如果这样的 <span class="arithmatex">\(n\)</span> 不存在，则称元素 <span class="arithmatex">\(x\)</span> 的阶是无限，记作 <span class="arithmatex">\(|x|=\infty\)</span>。</p>
</details>
<p>元素的阶总是不大于群的阶，事实上，下文即证明，元素的阶总是整除群的阶。但是，群的阶并非总是元素的阶的最大值，比如 <span class="arithmatex">\(D_6\)</span> 是六阶群，但是元素的阶最大是 <span class="arithmatex">\(3\)</span>。群的阶也并不是所有元素的阶的最小公倍数，比如 Klein 四元群<sup id="fnref:klein"><a class="footnote-ref" href="#fn:klein">1</a></sup> <span class="arithmatex">\(V_4\)</span> 的阶是 <span class="arithmatex">\(4\)</span>，但是里面只有 <span class="arithmatex">\(1\)</span> 阶元和 <span class="arithmatex">\(2\)</span> 阶元。</p>
<details class="note" open="open">
<summary>定理</summary>
<p>有限循环群 <span class="arithmatex">\(C_n=\langle x\rangle\)</span> 中，元素 <span class="arithmatex">\(x^k\)</span> 的阶是</p>
<div class="arithmatex">\[
\frac{n}{\gcd(k,n)}.
\]</div>
<p>特别地，<span class="arithmatex">\(C_n\)</span> 的生成元的数目是 <span class="arithmatex">\(\varphi(n)\)</span>，这里，<span class="arithmatex">\(\varphi(\cdot)\)</span> 是 <a href="../../number-theory/euler-totient/">欧拉函数</a>。</p>
</details>
<p>作为上述讨论的应用，注意到模 <span class="arithmatex">\(n\)</span> 整数乘法群的阶是 <span class="arithmatex">\(\varphi(n)\)</span>，群中的任何元素 <span class="arithmatex">\(a\)</span> 的阶都整除它，故而必然有 <span class="arithmatex">\(a^{\varphi(n)}=1\)</span>。这就是 <a href="../../number-theory/fermat/#欧拉定理">欧拉定理</a>，因为该群中的元素就是所有与 <span class="arithmatex">\(n\)</span> 互质的元素。</p>
<h3 id="陪集">陪集<a class="headerlink" href="#陪集" title="Permanent link"></a></h3>
<p>子群以外的元素在群中的结构也并非杂乱无章。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>观察 <span class="arithmatex">\(D_6\)</span> 中的子群 <span class="arithmatex">\(\langle r\rangle\)</span>，剩余的元素 <span class="arithmatex">\(\{s,sr,sr^2\}\)</span> 结构和 <span class="arithmatex">\(\langle r\rangle\)</span> 十分相似：它当中的每个操作都可以通过 <span class="arithmatex">\(s\)</span> 和 <span class="arithmatex">\(\langle r\rangle\)</span> 中的操作复合得到。同理，考虑子群 <span class="arithmatex">\(\langle s\rangle\)</span>，则群中的剩余元素可以分为两类，<span class="arithmatex">\(\{r,sr\}\)</span> 和 <span class="arithmatex">\(\{r^2,sr^2\}\)</span>，它们可以通过 <span class="arithmatex">\(\langle s\rangle\)</span> 中的元素分别与 <span class="arithmatex">\(r\)</span> 和 <span class="arithmatex">\(r^2\)</span> 复合得到。这样的现象是普遍的。</p>
</details>
<p>给定子群，可以定义它的陪集。</p>
<details class="abstract" open="open">
<summary>陪集</summary>
<p>设 <span class="arithmatex">\(G\)</span> 是群，<span class="arithmatex">\(H\le G\)</span> 是它的子群，则子群 <span class="arithmatex">\(H\)</span> 的包含 <span class="arithmatex">\(g\)</span> 的 <strong>左陪集</strong>（left coset）和 <strong>右陪集</strong>（right coset）分别定义为集合</p>
<div class="arithmatex">\[
\begin{aligned}
gH &amp;= \{gh:h\in H\},\\
Hg &amp;= \{hg:h\in H\}.
\end{aligned}
\]</div>
<p>陪集中的元素称为陪集的代表元（representative element）。</p>
</details>
<p>子群本身也是其陪集。给定子群，全体陪集构成群的一个分划，即群是全体陪集的不交并。分划总可以看作某个等价关系的等价类。对于左陪集的分划，这个等价关系就是 <span class="arithmatex">\(g_1\sim g_2\)</span> 当且仅当 <span class="arithmatex">\(g_1^{-1}g_2\in H\)</span>；对于右陪集的分划，这个等价关系就是 <span class="arithmatex">\(g_1\sim g_2\)</span> 当且仅当 <span class="arithmatex">\(g_1g_2^{-1}\in H\)</span>。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>按照陪集的语言，上面的例子中，<span class="arithmatex">\(D_6\)</span> 可以分别划分成 <span class="arithmatex">\(\langle r\rangle\cup s\langle r\rangle\)</span> 和 <span class="arithmatex">\(\langle s\rangle\cup \langle s\rangle r \cup \langle s\rangle r^2\)</span>。这里，前者将群划分为若干左陪集，后者将群划分为若干右陪集。应该注意，代表元的选取并无特殊，比如可以验证 <span class="arithmatex">\(s\langle r\rangle=sr\langle r\rangle\)</span>。陪集中的任何元素都是该陪集的代表元。</p>
</details>
<p>同一子群的不同陪集大小都相同，都等于对应子群的大小。由于给定子群的全体陪集构成群的一个分划，有限群的阶必然是子群的阶的整数倍。这叫做 Lagrange 定理。</p>
<details class="note" open="open">
<summary>Lagrange 定理</summary>
<p>对于有限群 <span class="arithmatex">\(G\)</span> 和它的子群 <span class="arithmatex">\(H\le G\)</span>，成立 <span class="arithmatex">\(|G|=[G:H]|H|\)</span>，这里，<span class="arithmatex">\([G:H]\)</span> 表示 <span class="arithmatex">\(G\)</span> 中子群 <span class="arithmatex">\(H\)</span> 的左（右）陪集数，称为群 <span class="arithmatex">\(G\)</span> 中子群 <span class="arithmatex">\(H\)</span> 的 <strong>指数</strong>（index）。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>考察左乘以 <span class="arithmatex">\(g\)</span> 的映射 <span class="arithmatex">\(h\mapsto gh\)</span>，则它和映射 <span class="arithmatex">\(h\mapsto g^{-1}h\)</span> 互为逆映射，因而它们都是双射。这说明，<span class="arithmatex">\(|H|=|gH|\)</span> 总是成立。</p>
</details>
<p>注意到，元素的阶就是元素生成的循环子群的阶，所以元素的阶也必然整除群的阶。</p>
<h3 id="正规子群">正规子群<a class="headerlink" href="#正规子群" title="Permanent link"></a></h3>
<p>一般情况下，给定子群的左右陪集并不相同。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>群 <span class="arithmatex">\(D_6\)</span> 中，<span class="arithmatex">\(\langle s\rangle r=\{r,sr\}\)</span>，但是 <span class="arithmatex">\(r\langle s\rangle=\{r,sr^2\}\)</span>。但是如果考虑子群 <span class="arithmatex">\(\langle r\rangle\)</span>，那么左右陪集又总是相同的，因为此时群只有两个陪集，而子群作为一个陪集又必然重合。</p>
</details>
<p>左右陪集是否相同，反映了相应的子群的性质。</p>
<details class="abstract" open="open">
<summary>正规子群</summary>
<p>设 <span class="arithmatex">\(N\le G\)</span> 是群 <span class="arithmatex">\(G\)</span> 的子群，如果对所有 <span class="arithmatex">\(h\in N\)</span> 和 <span class="arithmatex">\(g\in G\)</span>，都成立 <span class="arithmatex">\(ghg^{-1}\in N\)</span>，换言之，对所有 <span class="arithmatex">\(g\in G\)</span>，都成立 <span class="arithmatex">\(gNg^{-1}\subseteq N\)</span>，则称 <span class="arithmatex">\(N\)</span> 是 <span class="arithmatex">\(G\)</span> 的一个 <strong>正规子群</strong>（normal subgroup），记作 <span class="arithmatex">\(N\trianglelefteq G\)</span>。</p>
</details>
<p>这个定义中的条件正等价于 <span class="arithmatex">\(gN=Ng\)</span> 永远成立。群 <span class="arithmatex">\(G\)</span> 总有平凡的正规子群，即 <span class="arithmatex">\(\langle e\rangle\)</span> 和 <span class="arithmatex">\(G\)</span> 自身。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>在群 <span class="arithmatex">\(D_6\)</span> 中，<span class="arithmatex">\(\langle s\rangle\)</span> 不是正规子群，而 <span class="arithmatex">\(\langle r\rangle\)</span> 是正规子群。</p>
</details>
<h3 id="商群">商群<a class="headerlink" href="#商群" title="Permanent link"></a></h3>
<p>正规子群是非常重要的一类子群，原因之一就是基于正规子群可以定义商群。</p>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的正规子群 <span class="arithmatex">\(N\trianglelefteq G\)</span>，考虑全体陪集的集合</p>
<div class="arithmatex">\[
G/N = \{gN:g\in G\}.
\]</div>
<p>此时，左右陪集相同，不必区分。可以从群 <span class="arithmatex">\(G\)</span> 的运算出发，定义 <span class="arithmatex">\(G/N\)</span> 上的二元运算 <span class="arithmatex">\(\circ\)</span>，它满足</p>
<div class="arithmatex">\[
g_1N\circ g_2N=(g_1g_2)N.
\]</div>
<p>可以证明，运算的结果与代表元的选取无关<sup id="fnref:quotient"><a class="footnote-ref" href="#fn:quotient">2</a></sup>。此时，<span class="arithmatex">\((G/N,\circ)\)</span> 确实具有群的结构，它称为 <span class="arithmatex">\(G\)</span> 模 <span class="arithmatex">\(N\)</span> 的 <strong>商群</strong>（quotient group）。商群 <span class="arithmatex">\(G/N\)</span> 并不是群 <span class="arithmatex">\(G\)</span> 的子群，它的每个元素都是群 <span class="arithmatex">\(G\)</span> 的一个子集。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>在群 <span class="arithmatex">\(D_6\)</span> 中，商群 <span class="arithmatex">\(G/\langle r\rangle\)</span> 的意义非常显然。它相当于在所有这些对称操作中，忽视操作中将三角形旋转的角度，而只关注它是否将三角形翻转。两个将三角形翻转的操作的复合相当于没有翻转原三角形；但是，如果两个操作一个翻转了三角形而另一个没有，那么复合也必然翻转了三角形。翻转与否也具有群的结构。从群 <span class="arithmatex">\(D_6\)</span> 中忽视旋转的细节而只考虑翻转的有无，在代数上就是将复杂的群 <span class="arithmatex">\(D_6\)</span> 模掉 <span class="arithmatex">\(\langle r\rangle\)</span> 而得到商群 <span class="arithmatex">\(D_6/\langle r\rangle\)</span>。这些论述对子群 <span class="arithmatex">\(\langle s\rangle\)</span> 是无效的，因为如果忽视翻转的有无，那么旋转的度数没有办法明确判断的，这也是为什么 <span class="arithmatex">\(G/\langle s\rangle\)</span> 不具有商群的结构。</p>
</details>
<p>群的商群可以将复杂的群简化，允许观察群的部分结构来了解原来群的结构。这也是商群也称为 <strong>因子群</strong>（factor group）的原因。除平凡正规子群外，再不含其他正规子群的群称为 <strong>单群</strong>（simple group），这些群没有办法简化为更小的群。如同素数一样，它们是组成更复杂的群结构的基石。</p>
<h2 id="群同态">群同态<a class="headerlink" href="#群同态" title="Permanent link"></a></h2>
<p>理解给定群结构的第二种方法，是将两个群的结构相互比较。</p>
<p>对于两个群，要比较它们的结构，就是要构造两个群之间的映射。但是，这样的映射并不能是任意的，它们要保持群的结构，也就是要保持群的运算在映射前后一致。这样的映射称为群的同态。</p>
<details class="abstract" open="open">
<summary>群同态</summary>
<p>设映射 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span> 是自群 <span class="arithmatex">\((G,\cdot)\)</span> 到群 <span class="arithmatex">\((H,\odot)\)</span> 的映射，如果 <span class="arithmatex">\(\varphi\)</span> 保持群的运算，即对所有 <span class="arithmatex">\(g_1,g_2\in G\)</span> 都成立 <span class="arithmatex">\(\varphi(g_1\cdot g_2)=\varphi(g_1)\odot\varphi(g_2)\)</span>，则称映射 <span class="arithmatex">\(\varphi\)</span> 是一个自群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(H\)</span> 的 <strong>同态</strong>（homomorphism）。</p>
</details>
<p>群同态必然将单位元映射到单位元，也必然将逆元映射到逆元。</p>
<details class="info" open="open">
<summary>记号</summary>
<p>在下文中，如果不引起歧义，不会区分群 <span class="arithmatex">\(G\)</span> 和 <span class="arithmatex">\(H\)</span> 中的运算的记号，并且为表述简便，将省略这些记号。</p>
</details>
<h3 id="群同构">群同构<a class="headerlink" href="#群同构" title="Permanent link"></a></h3>
<p>对于自群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(H\)</span> 的同态 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span>，一个自然的问题是，这一同态在多大程度上反映了群 <span class="arithmatex">\(G\)</span> 和群 <span class="arithmatex">\(H\)</span> 的结构是一致的。为此，考察群 <span class="arithmatex">\(G\)</span> 在同态 <span class="arithmatex">\(\varphi\)</span> 下的像 <span class="arithmatex">\(\varphi(G)\)</span>，它将群 <span class="arithmatex">\(G\)</span> 的结构映射到群 <span class="arithmatex">\(H\)</span> 中。一方面，<span class="arithmatex">\(\varphi(G)\)</span> 是群 <span class="arithmatex">\(H\)</span> 的一个子群；但若同态 <span class="arithmatex">\(\varphi\)</span> 不是满射，<span class="arithmatex">\(\varphi(G)\)</span> 与群 <span class="arithmatex">\(H\)</span> 并不相同。另一方面，同态 <span class="arithmatex">\(\varphi\)</span> 也未必是单射；如果 <span class="arithmatex">\(\varphi\)</span> 不是单射，那么 <span class="arithmatex">\(\varphi(G)\)</span> 只反映了群 <span class="arithmatex">\(G\)</span> 的部分结构。只有当同态 <span class="arithmatex">\(\varphi\)</span> 是双射时，群 <span class="arithmatex">\(G\)</span> 和群 <span class="arithmatex">\(H\)</span> 的结构才是完全一致的。这种特殊的群同态叫做群同构。</p>
<details class="abstract" open="open">
<summary>群同构</summary>
<p>设 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span> 是自群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(H\)</span> 的同态，如果 <span class="arithmatex">\(\varphi\)</span> 是双射，则称 <span class="arithmatex">\(\varphi\)</span> 是群 <span class="arithmatex">\(G\)</span> 和群 <span class="arithmatex">\(H\)</span> 之间的 <strong>同构</strong>（isomorphism），记作 <span class="arithmatex">\(G\cong H\)</span>。</p>
</details>
<p>同构的两个群结构完全一致。如果只关心群的结构，两个同构的群没有必要区分。前文关于循环群的分类定理就是在同构的意义下给出的。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>回到前文的例子，正三角形的每个对称操作都唯一对应了顶点集合上的置换操作。顶点集合上的全体置换也构成群，即 <span class="arithmatex">\(S_3\)</span>。容易验证，这样得到的映射 <span class="arithmatex">\(\varphi:D_6\rightarrow S_3\)</span> 是群同态；进一步地，它也是群同构。所以，<span class="arithmatex">\(D_6\cong S_3\)</span>。事实上，六阶群要么同构于 <span class="arithmatex">\(C_6\)</span>，要么同构于 <span class="arithmatex">\(S_3\)</span>（证明见下文）。</p>
</details>
<p>对给定阶的有限群的结构进行分类，是群论的重要研究内容，但超出了本文的范畴。</p>
<h3 id="同态的核">同态的核<a class="headerlink" href="#同态的核" title="Permanent link"></a></h3>
<p>对于一般的同态，可以进一步讨论有多少关于群的结构的信息损失在了同态中。延续上文的记号。已知 <span class="arithmatex">\(\varphi(G)\)</span> 是群 <span class="arithmatex">\(H\)</span> 的子群，现在问题的关键在于 <span class="arithmatex">\(\varphi(G)\)</span> 和群 <span class="arithmatex">\(G\)</span> 之间的关系。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>考虑如下定义的映射 <span class="arithmatex">\(\varphi: D_6 \rightarrow C_2 = \langle x\rangle\)</span>：</p>
<div class="arithmatex">\[
\varphi(e)=\varphi(r)=\varphi(r^2)=e,\ \varphi(s)=\varphi(sr)=\varphi(sr^2)=x.
\]</div>
<p>容易验证，<span class="arithmatex">\(\varphi\)</span> 是群同态；它是满射，但不是单射。它的意义很明显，就是在群的每一个对称操作映射到其翻转的有无。这样的同态压缩的群 <span class="arithmatex">\(D_6\)</span> 中的信息，就是有关它旋转角度的信息。比如说，如果没有翻转，任何角度的旋转都映射到了群 <span class="arithmatex">\(C_2\)</span> 中的单位元。</p>
</details>
<p>这个例子启发使用 <span class="arithmatex">\(\{e\}\)</span> 的原像衡量同态中损失的结构信息。为此，有如下定义。</p>
<details class="abstract" open="open">
<summary>同态的核</summary>
<p>设 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span> 是自群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(H\)</span> 的同态，则同态 <span class="arithmatex">\(\varphi\)</span> 的 <strong>核</strong>（kernel）是 <span class="arithmatex">\(\ker\varphi=\{g\in G:\varphi(g)=e\}\)</span>，这里，<span class="arithmatex">\(e\)</span> 是 <span class="arithmatex">\(H\)</span> 的单位元。</p>
</details>
<h3 id="同态基本定理">同态基本定理<a class="headerlink" href="#同态基本定理" title="Permanent link"></a></h3>
<p>同态的核 <span class="arithmatex">\(\ker\varphi\)</span> 的确刻画了群同态中损失的结构信息。这一结论的精确表述就是 <strong>同态基本定理</strong>（亦称 <strong>第一同构定理</strong>）（fundamental theorem of group homomorphism, a.k.a., first isomorphism theorem）。</p>
<details class="note" open="open">
<summary>同态基本定理（第一同构定理）</summary>
<p>设 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span> 是自群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(H\)</span> 的同态，则 <span class="arithmatex">\(\ker\varphi\trianglelefteq G\)</span>，且 <span class="arithmatex">\(G/\ker\varphi\cong\varphi(G)\le H\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>首先，<span class="arithmatex">\(N=\ker\varphi\)</span> 是正规子群，因为对于任意 <span class="arithmatex">\(h\in N\)</span> 都有 <span class="arithmatex">\(\varphi(ghg^{-1})=\varphi(g)\varphi(h)\varphi(g)^{-1}=\varphi(g)\varphi(g)^{-1}=e\)</span>，亦即 <span class="arithmatex">\(ghg^{-1}\in\ker\varphi\)</span>。然后，考察映射 <span class="arithmatex">\(\Phi:G/N\rightarrow\varphi(G)\)</span>，它满足 <span class="arithmatex">\(\Phi(gN)=\varphi(g)\)</span>。映射是良定义的，因为如果 <span class="arithmatex">\(g_1N=g_2N\)</span>，那么 <span class="arithmatex">\(g_1^{-1}g_2\in N\)</span>，则 <span class="arithmatex">\(\varphi(g_1^{-1}g_2)=e\)</span>，即 <span class="arithmatex">\(\varphi(g_1)=\varphi(g_2)\)</span>。映射 <span class="arithmatex">\(\Phi\)</span> 显然是满射；它也是单射，因为 <span class="arithmatex">\(\ker\Phi=\{gN:\varphi(g)=e\}=\{N\}\)</span>。故而，<span class="arithmatex">\(\Phi\)</span> 是群同构。最后，<span class="arithmatex">\(\varphi(g_1)\varphi(g_2)^{-1}=\varphi(g_1g_2^{-1})\in\varphi(G)\)</span>，根据子群判别法，<span class="arithmatex">\(\varphi(G)\)</span> 必然是子群。</p>
</details>
<details class="note" open="open">
<summary>推论</summary>
<p>同态 <span class="arithmatex">\(\varphi:G\rightarrow H\)</span> 是单射，当且仅当 <span class="arithmatex">\(\ker\varphi=\{e\}\)</span>。此时，<span class="arithmatex">\(G\)</span> 同构于 <span class="arithmatex">\(H\)</span> 的一个子群，即 <span class="arithmatex">\(G\cong\varphi(G)\le H\)</span>。</p>
</details>
<p>也就是说，同态 <span class="arithmatex">\(\varphi\)</span> 的核是群 <span class="arithmatex">\(G\)</span> 的正规子群，而模 <span class="arithmatex">\(\ker\varphi\)</span> 得到的商群 <span class="arithmatex">\(G/\ker\varphi\)</span> 同构于同态的像 <span class="arithmatex">\(\varphi(G)\)</span>，而这一同态的像正是群 <span class="arithmatex">\(H\)</span> 的子群。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>上文给出的群同态 <span class="arithmatex">\(\varphi: D_6 \rightarrow C_2\)</span> 的核是 <span class="arithmatex">\(\langle r\rangle\)</span>，前文讨论正规子群时也已经说明 <span class="arithmatex">\(D_6/\langle r\rangle\)</span> 的确同构于 <span class="arithmatex">\(C_2\)</span>。</p>
</details>
<h3 id="自然同态">自然同态<a class="headerlink" href="#自然同态" title="Permanent link"></a></h3>
<p>得到这样的结论并不为奇。这是因为在构造同态 <span class="arithmatex">\(\varphi: D_6 \rightarrow C_2\)</span> 时，利用的正是商群 <span class="arithmatex">\(D_6/\langle r\rangle\)</span> 的几何意义。这样的现象并不罕见。事实上，对每个商群，都可以构造出群同态，使得同态的像同构于给定的商群。</p>
<details class="abstract" open="open">
<summary>自然同态</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和其正规子群 <span class="arithmatex">\(N\trianglelefteq G\)</span>，由 <span class="arithmatex">\(\pi(g)=gN\)</span> 给出的映射 <span class="arithmatex">\(\pi: G\rightarrow G/N\)</span> 是自 <span class="arithmatex">\(G\)</span> 到 <span class="arithmatex">\(G/N\)</span> 的满同态，称为自群 <span class="arithmatex">\(G\)</span> 到商群 <span class="arithmatex">\(G/N\)</span> 的 <strong>自然同态</strong>（natural homomorphism）或 <strong>自然映射</strong>。</p>
</details>
<p>这一结论也说明，对于任何给定群的正规子群，都能够找到对应的群同态，使得这一同态的核就是给定的正规子群。前文同态基本定理则说明，任何同态的核都是正规子群。故而，正规子群和同态的核是一体两面。</p>
<p>利用自然映射的概念，群的同态基本定理其实是在说如下的 <strong>交换图</strong>（commutative diagram）成立。</p>
<p><img alt="同态基本定理的交换图" src="../../images/homomorphism.svg" /></p>
<p>这里，所有箭头都是群同态，且 <span class="arithmatex">\(N=\ker\varphi\)</span> 是同态 <span class="arithmatex">\(\varphi\)</span> 的核，<span class="arithmatex">\(\varphi(G)\)</span> 是同态 <span class="arithmatex">\(\varphi\)</span> 的像。这些映射依次是，<span class="arithmatex">\(\pi:g\mapsto gN\)</span> 为群 <span class="arithmatex">\(G\)</span> 到商群 <span class="arithmatex">\(G/N\)</span> 的自然映射（满同态），<span class="arithmatex">\(\Phi:gN\mapsto\varphi(g)\)</span> 是同构映射，<span class="arithmatex">\(\iota\)</span> 则是嵌入映射（单同态）。交换图意味着，图中从 <span class="arithmatex">\(G\)</span> 出发到 <span class="arithmatex">\(H\)</span> 结束的两条不同路径上的映射的复合得到的结果是一致的，即 <span class="arithmatex">\(\varphi=\iota\circ\Phi\circ\pi\)</span>。交换图清晰地说明，同态 <span class="arithmatex">\(\varphi\)</span> 损失的信息就反映在 <span class="arithmatex">\(\pi\)</span> 和 <span class="arithmatex">\(\iota\)</span> 中。</p>
<h3 id="群的同构定理">群的同构定理<a class="headerlink" href="#群的同构定理" title="Permanent link"></a></h3>
<p>用于理解群的结构的有力工具，是群的同构定理。前文已经给出第一同构定理。为了内容完整，这里再给出其他常见的同构定理。</p>
<p>第二同构定理涉及到子群的乘积的概念。</p>
<details class="abstract" open="open">
<summary>子集的乘积</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子集 <span class="arithmatex">\(A,B\subseteq G\)</span>，子集 <span class="arithmatex">\(A\)</span> 和 <span class="arithmatex">\(B\)</span> 的 <strong>乘积</strong>（product）是子集 <span class="arithmatex">\(AB=\{ab:a\in A,b\in B\}\)</span>。</p>
</details>
<p>子群的乘积并不总是子群。比如，群 <span class="arithmatex">\(D_6\)</span> 的子群 <span class="arithmatex">\(A=\langle s\rangle\)</span> 和子群 <span class="arithmatex">\(B=\langle sr\rangle\)</span> 的乘积等于 <span class="arithmatex">\(AB=\{e,s,r,sr\}\)</span>，这并不是 <span class="arithmatex">\(G\)</span> 的子群，因为 <span class="arithmatex">\((sr)s=r^2\notin AB\)</span>。其实，这种 <span class="arithmatex">\(a\in A\)</span>，<span class="arithmatex">\(b\in B\)</span>，但 <span class="arithmatex">\(ba\notin AB\)</span> 形式的反例正是乘积不是子群的根本原因。对此，有如下定理。</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子群 <span class="arithmatex">\(A,B\le G\)</span>，乘积 <span class="arithmatex">\(AB\)</span> 是子群，当且仅当 <span class="arithmatex">\(AB=BA\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>乘积 <span class="arithmatex">\(AB\)</span> 是子群，则必然有 <span class="arithmatex">\(ba=(a^{-1}b^{-1})^{-1}\in AB\)</span> 对任意 <span class="arithmatex">\(a\in A\)</span> 和 <span class="arithmatex">\(b\in B\)</span> 都成立，所以 <span class="arithmatex">\(BA\subseteq AB\)</span>。反过来，如果 <span class="arithmatex">\(AB=BA\)</span>，则对于任意 <span class="arithmatex">\(a_1,a_2\in A\)</span> 和 <span class="arithmatex">\(b_1,b_2\in B\)</span>，都有 <span class="arithmatex">\((a_1b_1)(a_2b_2)^{-1}=a_1b_1b_2^{-1}a_2^{-1}\in a_1BA=a_1AB=AB\)</span>，则根据子群判别法，必然有 <span class="arithmatex">\(AB\)</span> 是子群。</p>
</details>
<p><strong>第二同构定理</strong>（second isomorphism theorem, a.k.a., diamond isomorphism theorem）则给出了子群乘积仍是子群的更为简单的充分条件，并且进一步确定了其结构。</p>
<details class="note" open="open">
<summary>第二同构定理</summary>
<p>设群 <span class="arithmatex">\(G\)</span> 和子群 <span class="arithmatex">\(A,B\le G\)</span> 满足 <span class="arithmatex">\(A\le N_G(B)\)</span>，那么，<span class="arithmatex">\(AB\le G\)</span>，且 <span class="arithmatex">\(B\trianglelefteq AB\)</span>，<span class="arithmatex">\(A\cap B\trianglelefteq A\)</span>，<span class="arithmatex">\(AB/B\cong A/(A\cap B)\)</span>。这里，<span class="arithmatex">\(N_G(B)\)</span> 是 <span class="arithmatex">\(B\)</span> 的 <a href="#正规化子和中心化子">正规化子</a>。特别地，<span class="arithmatex">\(A\le N_G(B)\)</span> 的一个充分条件是 <span class="arithmatex">\(B\trianglelefteq G\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>因为 <span class="arithmatex">\(A\le N_G(B)\)</span>，必然有 <span class="arithmatex">\(aBa^{-1}=B\)</span> 对于所有 <span class="arithmatex">\(a\in A\)</span> 都成立，此即 <span class="arithmatex">\(aB=Ba\)</span>。因此，必然有 <span class="arithmatex">\(AB=BA\)</span>，则由上述定理知 <span class="arithmatex">\(AB\)</span> 是子群。子群 <span class="arithmatex">\(B\)</span> 作为 <span class="arithmatex">\(AB\)</span> 的子群，左右陪集相同，因而 <span class="arithmatex">\(B\trianglelefteq AB\)</span>。</p>
<p>考察映射 <span class="arithmatex">\(\varphi:A\rightarrow AB/B\)</span> 满足 <span class="arithmatex">\(\varphi(a)=aB\)</span>，则它是满射，且它的核 <span class="arithmatex">\(\ker\varphi=\{a\in A:aB=B\}=A\cap B\)</span>。应用同态基本定理就可得证。</p>
</details>
<p><strong>第三同构定理</strong>（third isomorphism theorem）则给出了商群的正规子群和商群与原来群的正规子群和商群之间的对应关系。它解释了将商群进一步分解这一想法的合理性。</p>
<details class="note" open="open">
<summary>第三同构定理</summary>
<p>设群 <span class="arithmatex">\(G\)</span> 有正规子群 <span class="arithmatex">\(H,K\trianglelefteq G\)</span>，且 <span class="arithmatex">\(H\le K\)</span>，则 <span class="arithmatex">\(K/H\trianglelefteq G/H\)</span>，且 <span class="arithmatex">\((G/H)/(K/H)\cong G/K\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>考察映射 <span class="arithmatex">\(\varphi:G/H\rightarrow G/K\)</span> 满足 <span class="arithmatex">\(\varphi(gH)=gK\)</span>，则它是满的群同态，且 <span class="arithmatex">\(\ker\varphi=\{gH:g\in K\}=K/H\)</span>。应用同态基本定理就可得证。</p>
</details>
<p>这一结论可以推广到第四同构定理，或称 <strong>对应定理</strong>（correspondence theorem），它进一步给出了群的子群格和商群的子群格之间的对应关系。</p>
<details class="note" open="open">
<summary>对应定理</summary>
<p>设群 <span class="arithmatex">\(G\)</span> 有正规子群 <span class="arithmatex">\(N\trianglelefteq G\)</span>，则全体包含 <span class="arithmatex">\(N\)</span> 的群 <span class="arithmatex">\(G\)</span> 的子群 <span class="arithmatex">\(\mathcal H=\{H:N\subseteq H\subseteq G\}\)</span> 和商群 <span class="arithmatex">\(G/N\)</span> 的全体子群 <span class="arithmatex">\(\mathcal S=\{S:S\le G/N\}\)</span> 之间存在双射 <span class="arithmatex">\(\varphi:\mathcal H\rightarrow\mathcal S\)</span>，它将 <span class="arithmatex">\(H\in\mathcal H\)</span> 映射至 <span class="arithmatex">\(H/N\in\mathcal S\)</span>。这个双射保持子群的包含关系，且 <span class="arithmatex">\(G\)</span> 的正规子群总是映射到 <span class="arithmatex">\(G/N\)</span> 的正规子群。</p>
</details>
<details class="info">
<summary>关于同构定理的内容</summary>
<p>不同的教材中，群的同构定理的内容和名称可能有所差异。这里选取的是常见的一个版本。<a href="https://en.wikipedia.org/wiki/Isomorphism_theorems#Note_on_numbers_and_names">维基百科</a> 总结了常见教材中同构定理内容和名称的差异。</p>
</details>
<h2 id="群作用">群作用<a class="headerlink" href="#群作用" title="Permanent link"></a></h2>
<p>理解给定群结构的第三种方法，是考察群在集合上的作用。</p>
<p>比如说，本文考察的正三角形的空间对称群就是通过群的元素（即对称操作）在三角形上的作用来定义的。再比如说，对称群 <span class="arithmatex">\(S_M\)</span> 的定义可以通过它的元素在集合 <span class="arithmatex">\(M\)</span> 上的作用给出。这里所谓的作用，指的是每个群的元素都对应一个集合上的置换。</p>
<details class="abstract" open="open">
<summary>群在集合上的作用</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和集合 <span class="arithmatex">\(X\)</span> 以及映射 <span class="arithmatex">\(G\times X\rightarrow X\)</span>，记 <span class="arithmatex">\((g,x)\)</span> 在该映射下的像为 <span class="arithmatex">\(g\cdot x\)</span>，如果该映射对所有 <span class="arithmatex">\(g_1,g_2\in G\)</span> 和 <span class="arithmatex">\(x\in X\)</span> 都满足条件 <span class="arithmatex">\(g_1\cdot(g_2\cdot x)=(g_1g_2)\cdot x\)</span> 和 <span class="arithmatex">\(e\cdot x=x\)</span>，那么就称该映射为群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的 <strong>群作用</strong>（group action）。</p>
</details>
<details class="info">
<summary>「左作用」和「右作用」</summary>
<p>这里采取的群作用的定义在有些地方<sup id="fnref:group-action"><a class="footnote-ref" href="#fn:group-action">3</a></sup>会称为左作用（left action），因为在记号 <span class="arithmatex">\(g\cdot x\)</span> 中，群的元素写在了集合的元素的左侧。相应地，此时群元素的复合 <span class="arithmatex">\(g_1g_2\)</span> 作用在集合上时，需要先进行 <span class="arithmatex">\(g_2\)</span> 的作用，再进行 <span class="arithmatex">\(g_1\)</span> 的作用。当然，也可以相应地定义右作用，记作 <span class="arithmatex">\(x\cdot g\)</span>。此时，群元素的复合顺序与左作用相反，即 <span class="arithmatex">\(x\cdot (g_1g_2)=(x\cdot g_1)\cdot g_2\)</span>。两者只有记号上的区别，而无本质区别，因而本文默认采用左作用的记号。</p>
</details>
<p>对于满足上述定义的群作用，自然有如下构造</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi:{\color{Maroon}{G}}\rightarrow {\color{Orchid}{S_X}}&amp;\\
{\color{Maroon}{g}}\mapsto {\color{Orchid}{\varphi_g}}&amp;: {\color{RoyalBlue}{X}}\rightarrow{\color{YellowGreen}{X}}\\
&amp;\quad {\color{RoyalBlue}{x}}\mapsto {\color{YellowGreen}{g\cdot x}}.
\end{aligned}
\]</div>
<p>这一映射，将每个群 <span class="arithmatex">\(G\)</span> 中的元素 <span class="arithmatex">\(g\)</span> 都对应到集合 <span class="arithmatex">\(X\)</span> 上的一个置换 <span class="arithmatex">\(\varphi_g\)</span>，且置换 <span class="arithmatex">\(\varphi_g\)</span> 将元素 <span class="arithmatex">\(x\)</span> 映射到 <span class="arithmatex">\(g\cdot x\)</span>。</p>
<p>根据定义，群中的单位元 <span class="arithmatex">\(e\)</span> 对应的双射 <span class="arithmatex">\(\varphi_e\)</span> 是 <span class="arithmatex">\(X\)</span> 上的恒等映射，而群中元素 <span class="arithmatex">\(g\)</span> 对应的映射 <span class="arithmatex">\(\varphi_g\)</span> 和其逆元 <span class="arithmatex">\(g^{-1}\)</span> 对应的映射 <span class="arithmatex">\(\varphi_{g^{-1}}\)</span> 互为逆映射（这也说明为什么 <span class="arithmatex">\(\varphi_g\)</span> 总是双射）。可以验证，<span class="arithmatex">\(\varphi_{g_1g_2}=\varphi_{g_1}\varphi_{g_2}\)</span>，即 <span class="arithmatex">\(\varphi\)</span> 是群 <span class="arithmatex">\(G\)</span> 到群 <span class="arithmatex">\(S_X\)</span> 的群同态。</p>
<p>这一群同态 <span class="arithmatex">\(\varphi\)</span> 称为该群作用的 <strong>置换表示</strong>（permutation representation），它将群 <span class="arithmatex">\(G\)</span> 映射到了某个置换群上。</p>
<details class="abstract" open="open">
<summary>置换群</summary>
<p>如果群 <span class="arithmatex">\(G\)</span> 是某个对称群的子群，则称群 <span class="arithmatex">\(G\)</span> 是一个 <strong>置换群</strong>（permutation group）。</p>
</details>
<p>该群同态的核也称为该群作用的核。如果这一群同态的核是平凡的，即这个同态是单射，则称该群作用是 <strong>忠实的</strong>（faithful），即该作用的置换表示忠实地反映了群结构的信息。此时，群 <span class="arithmatex">\(G\)</span> 与置换表示得到的的置换群同构。</p>
<details class="info" open="open">
<summary>记号</summary>
<p>下文中，为表述方便，将省略群作用中的 <span class="arithmatex">\(\cdot\)</span> 记号。</p>
</details>
<h3 id="轨道">轨道<a class="headerlink" href="#轨道" title="Permanent link"></a></h3>
<p>群作用是二元映射。固定群中的元素 <span class="arithmatex">\(g\)</span>，则可以得到集合上的置换 <span class="arithmatex">\(\varphi_g\)</span>。而如果固定集合上的元素 <span class="arithmatex">\(x\)</span>，则可以得到群对该元素作用的所有可能的结果。</p>
<details class="abstract" open="open">
<summary>轨道</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的作用和 <span class="arithmatex">\(x\in X\)</span>，称 <span class="arithmatex">\(x\)</span> 在群 <span class="arithmatex">\(G\)</span> 作用下的 <strong>轨道</strong>（orbit）是子集 <span class="arithmatex">\(Gx=\{gx:g\in G\}\)</span>。</p>
</details>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>比如说，如果考虑群 <span class="arithmatex">\(\langle s\rangle\le D_6\)</span> 在正三角形顶点集合上的作用，则顶点 <span class="arithmatex">\(1\)</span> 的轨道是 <span class="arithmatex">\(\{1\}\)</span>，而顶点 <span class="arithmatex">\(2\)</span> 和 <span class="arithmatex">\(3\)</span> 的轨道是 <span class="arithmatex">\(\{2,3\}\)</span>。但是，群 <span class="arithmatex">\(\langle r\rangle\le D_6\)</span> 在顶点集合上的作用只有一个轨道，即全体顶点集。</p>
</details>
<p>容易证明，群 <span class="arithmatex">\(G\)</span> 的作用下，集合 <span class="arithmatex">\(X\)</span> 的全体轨道构成了该集合的一个分划，记作 <span class="arithmatex">\(X/G\)</span>。但是和陪集不同，这些轨道并不一定是等长的。</p>
<h3 id="稳定化子">稳定化子<a class="headerlink" href="#稳定化子" title="Permanent link"></a></h3>
<p>群作用下，集合中的一个元素的轨道长度取决于有多少群里的元素对应的置换以它为不动点。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>比如说，之所以在群 <span class="arithmatex">\(\langle s\rangle\le D_6\)</span> 的作用下，顶点 <span class="arithmatex">\(1\)</span> 的轨道长是一，是因为所有群里的元素都将顶点 <span class="arithmatex">\(1\)</span> 映到其自身；而顶点 <span class="arithmatex">\(2\)</span> 的轨道长是二，是因为只有单位元 <span class="arithmatex">\(e\)</span> 将顶点 <span class="arithmatex">\(2\)</span> 映射到其自身。</p>
</details>
<p>这启发了如下的定义。</p>
<details class="abstract" open="open">
<summary>稳定化子</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的作用和 <span class="arithmatex">\(x\in X\)</span>，称群 <span class="arithmatex">\(G\)</span> 中 <span class="arithmatex">\(x\)</span> 的 <strong>稳定化子</strong>（stabilizer）是子群 <span class="arithmatex">\(G_x=\{g\in G:gx=x\}\)</span>。</p>
</details>
<p>群作用的核就是集合中所有元素的稳定化子的交。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>考虑群 <span class="arithmatex">\(D_6\)</span> 在顶点集合上的群作用，则顶点 <span class="arithmatex">\(1\)</span> 的稳定化子是 <span class="arithmatex">\(\{e,s\}=\langle s\rangle\)</span>。这是 <span class="arithmatex">\(D_6\)</span> 的子群。因为 <span class="arithmatex">\(D_6\)</span> 可以划分成左陪集 <span class="arithmatex">\(\langle s\rangle\)</span>，<span class="arithmatex">\(r\langle s\rangle\)</span> 和 <span class="arithmatex">\(r^2\langle s\rangle\)</span>，容易发现，每个左陪集对顶点 <span class="arithmatex">\(1\)</span> 作用的结果是一样的。</p>
</details>
<p>这一例子说明，轨道上的元素，都和稳定化子的左陪集一一对应。这说明如下结果。</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的作用，元素 <span class="arithmatex">\(x\in X\)</span> 的稳定化子 <span class="arithmatex">\(G_x\)</span> 是 <span class="arithmatex">\(G\)</span> 的子群，且子群 <span class="arithmatex">\(G_x\)</span> 的左陪集与轨道 <span class="arithmatex">\(Gx\)</span> 存在双射。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>验证映射 <span class="arithmatex">\(gG_x\mapsto gx\)</span> 是良定义的双射即可。</p>
</details>
<p>利用 Lagrange 定理，可以将轨道长和稳定化子的陪集数目联系起来。这就是 <strong>轨道稳定子定理</strong>（orbit-stabilizer theorem）。</p>
<details class="note" open="open">
<summary>轨道稳定子定理</summary>
<p>对于有限群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的作用和 <span class="arithmatex">\(x\in X\)</span>，有 <span class="arithmatex">\(|Gx|=[G:G_x]=|G|/|G_x|\)</span>。</p>
</details>
<p>可以在上面的例子中验证这一结论。</p>
<h3 id="burnside-引理">Burnside 引理<a class="headerlink" href="#burnside-引理" title="Permanent link"></a></h3>
<p>这一引理给出了群作用的轨道个数公式。</p>
<details class="note" open="open">
<summary>Burnside 引理</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 在集合 <span class="arithmatex">\(X\)</span> 上的作用，轨道的个数等于群中每个元素对应置换的不动点的平均个数，即</p>
<div class="arithmatex">\[
|X/G| = \frac{1}{|G|}\sum_{g\in G}|X^g|.
\]</div>
<p>这里，<span class="arithmatex">\(X^g=\{x\in X:gx=x\}\)</span> 是元素 <span class="arithmatex">\(g\in G\)</span> 对应置换的不动点集合。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>这一定理的证明十分简明。注意到，轨道个数可以写作</p>
<div class="arithmatex">\[
|X/G|=\sum_{o\in X/G}1=\sum_{x\in X}\frac{1}{|Gx|}=\frac1{|G|}\sum_{x\in X}|G_x|.
\]</div>
<p>最后一个等号就是上面的推论；而右式和所要求证的只差一个 Fubini 定理，因为它们中的求和式都是对集合 <span class="arithmatex">\(\{(g,x)\in G\times X:gx=x\}\)</span> 的计数，只不过右式先对 <span class="arithmatex">\(g\)</span> 求和，而所求证的式子先对 <span class="arithmatex">\(x\)</span> 求和。</p>
</details>
<p>这一定理在组合数学中有很多用处，可以用于统计「本质不同」的对象的数目。更多例子和讨论可以参考 <a href="../../combinatorics/polya/">Pólya 计数</a>。</p>
<h3 id="cayley-定理">Cayley 定理<a class="headerlink" href="#cayley-定理" title="Permanent link"></a></h3>
<p>利用群作用研究群的结构，需要选取合适的集合。事实上，群自身就是这样一个集合。因此，接下来考虑群对自身的两类常见的群作用，并借此分析群的结构。</p>
<p>第一个这样的群作用是群对自身的 <strong>左乘作用</strong>（left multiplication）。它的置换表示如下。</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi:G\rightarrow S_G&amp;\\
g\mapsto \varphi_g&amp;: G\rightarrow G\\
&amp;\quad x\mapsto gx
\end{aligned}
\]</div>
<p>群的左乘作用必然是忠实的，因为群满足消去律。所以，由同态基本定理，<span class="arithmatex">\(G\)</span> 可以嵌入对称群 <span class="arithmatex">\(S_G\)</span> 中。这意味着，每个群都同构于某个置换群<sup id="fnref:cayley"><a class="footnote-ref" href="#fn:cayley">4</a></sup>。</p>
<details class="note" open="open">
<summary>Cayley 定理</summary>
<p>群 <span class="arithmatex">\(G\)</span> 同构于对称群 <span class="arithmatex">\(S_G\)</span> 的子群。</p>
</details>
<p>这个群作用只有一个轨道，而且，每个元素的稳定化子都是 <span class="arithmatex">\(\{e\}\)</span>。</p>
<h3 id="共轭作用">共轭作用<a class="headerlink" href="#共轭作用" title="Permanent link"></a></h3>
<p>第二个群到自身的作用叫做 <strong>共轭作用</strong>（conjugation）。它的置换表示如下。</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi:G\rightarrow S_G&amp;\\
g\mapsto \varphi_g&amp;: G\rightarrow G\\
&amp;\quad x\mapsto gxg^{-1}
\end{aligned}
\]</div>
<p>在群的共轭作用下，轨道和稳定化子都有特别的名字。</p>
<details class="abstract" open="open">
<summary>共轭类</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和 <span class="arithmatex">\(g\in G\)</span>，元素 <span class="arithmatex">\(g\)</span> 在群 <span class="arithmatex">\(G\)</span> 中的 <strong>共轭类</strong>（conjugacy class）是共轭作用下 <span class="arithmatex">\(g\)</span> 的轨道。如果元素 <span class="arithmatex">\(g\)</span> 和 <span class="arithmatex">\(h\)</span> 处在同一共轭类中，则称 <span class="arithmatex">\(g\)</span> 和 <span class="arithmatex">\(h\)</span>  <strong>共轭</strong>（conjugate）。</p>
</details>
<details class="abstract" open="open">
<summary>中心化子</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和 <span class="arithmatex">\(a\in G\)</span>，元素 <span class="arithmatex">\(a\)</span> 在群 <span class="arithmatex">\(G\)</span> 中的 <strong>中心化子</strong>（centralizer）是 <span class="arithmatex">\(C_G(a)=\{g\in G:ga=ag\}\)</span>。</p>
</details>
<details class="abstract" open="open">
<summary>中心</summary>
<p>对于群 <span class="arithmatex">\(G\)</span>，群 <span class="arithmatex">\(a\)</span> 的 <strong>中心</strong>（center）为 <span class="arithmatex">\(Z(G)=\cap_{a\in G}C_G(a)=\{g\in G:\forall a\in G(ga=ag)\}\)</span>。</p>
</details>
<p>群的中心，是与群中所有元素都交换的元素的集合；因为它是群作用的核，它必然是正规子群。群的中心的大小，表明了它和交换群之间的差距。给定元素的中心化子，是与该元素交换的所有元素的集合；也是所有中心包括它的子群中最大的，这也就是它的名字来源；同时，因为它是共轭作用下某元素的稳定化子，所以它是子群。共轭类一般不是子群。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>回到群 <span class="arithmatex">\(D_6\)</span>，它的中心是 <span class="arithmatex">\(\{e\}\neq G\)</span>，这说明它不是交换群。元素 <span class="arithmatex">\(r\)</span> 的中心化子 <span class="arithmatex">\(C_G(r)\)</span> 是 <span class="arithmatex">\(\langle r\rangle\)</span>，元素 <span class="arithmatex">\(s\)</span> 的中心化子 <span class="arithmatex">\(C_G(s)\)</span> 为 <span class="arithmatex">\(\langle s\rangle\)</span>。一般地，对所有 <span class="arithmatex">\(g\in G\)</span>，总成立 <span class="arithmatex">\(\langle g\rangle\le C_G(g)\)</span>。群 <span class="arithmatex">\(D_6\)</span> 的共轭类共三个，即 <span class="arithmatex">\(\{e\},\{r,r^2\},\{s,sr,sr^2\}\)</span>。容易发现，共轭的元素都是同阶的<sup id="fnref:conjugate"><a class="footnote-ref" href="#fn:conjugate">5</a></sup>。</p>
</details>
<p>群在共轭作用下划分成若干个共轭类。所以，可以写出 <strong>类方程</strong>（class equation）。</p>
<details class="note" open="open">
<summary>类方程</summary>
<p>对于群 <span class="arithmatex">\(G\)</span>，设 <span class="arithmatex">\(\{\mathcal K_i\}_{i=1}^r\)</span> 为全体长度大于一的共轭类，且 <span class="arithmatex">\(g_i\)</span> 是 <span class="arithmatex">\(\mathcal K_i\)</span> 的代表元，成立</p>
<div class="arithmatex">\[
|G|=|Z(G)|+\sum_{i=1}^r[G:C_G(g_i)].
\]</div>
</details>
<p>它可以用于分析群的结构，比如用于证明下文的 <a href="#sylow-定理">Sylow 定理</a>。</p>
<h3 id="正规化子和中心化子">正规化子和中心化子<a class="headerlink" href="#正规化子和中心化子" title="Permanent link"></a></h3>
<p>事实上，群的幂集也可以是群作用的对象。这里着重讨论群在它的全体子集 <span class="arithmatex">\(X=\mathcal P(G)\)</span> 上的共轭作用。它的置换表示如下。</p>
<div class="arithmatex">\[
\begin{aligned}
\varphi:G\rightarrow S_X&amp;\\
g\mapsto \varphi_g&amp;: X\rightarrow X\\
&amp;\quad S\mapsto gSg^{-1} = \{gsg^{-1}:s\in S\}
\end{aligned}
\]</div>
<p>在这一共轭作用下，同样可以定义群的子集的共轭类。它的核依然是群的中心。它的稳定化子则称为正规化子。</p>
<details class="abstract" open="open">
<summary>正规化子</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子集 <span class="arithmatex">\(S\subseteq G\)</span>，子集 <span class="arithmatex">\(S\)</span> 在群 <span class="arithmatex">\(G\)</span> 中的 <strong>正规化子</strong>（normalizer）是 <span class="arithmatex">\(N_G(S)=\{g\in G:gSg^{-1}=S\}\)</span>。</p>
</details>
<p>正规化子是共轭作用下 <span class="arithmatex">\(S\)</span> 的稳定化子，必然是 <span class="arithmatex">\(G\)</span> 的子群；<span class="arithmatex">\(S\)</span> 的正规化子是能够使得 <span class="arithmatex">\(S\)</span> 包含在其正规子群中的子群中最大的，这也是正规化子的名字来源。特别地，对于单元素集合 <span class="arithmatex">\(\{a\}\)</span>，<span class="arithmatex">\(N_G(\{a\})=C_G(a)\)</span>。</p>
<p>中心化子也可以类似地推广到子集的情形。</p>
<details class="abstract" open="open">
<summary>中心化子</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子集 <span class="arithmatex">\(S\subseteq G\)</span>，子集 <span class="arithmatex">\(S\)</span> 在群 <span class="arithmatex">\(G\)</span> 中的 <strong>中心化子</strong>（centralizer）是 <span class="arithmatex">\(C_G(S)=\{g\in G:\forall s\in S(gsg^{-1}=s)\}\)</span>。</p>
</details>
<p>中心化子实际上是群 <span class="arithmatex">\(N_G(S)\)</span> 在 <span class="arithmatex">\(S\)</span> 的共轭作用的核。所以，必然有 <span class="arithmatex">\(C_G(S)\trianglelefteq N_G(S)\le G\)</span>，所以由子群的传递性，中心化子也是子群。特别地，群的中心 <span class="arithmatex">\(Z(G)=C_G(G)\trianglelefteq N_G(G)=G\)</span> 必然是正规子群。</p>
<h3 id="sylow-定理">Sylow 定理<a class="headerlink" href="#sylow-定理" title="Permanent link"></a></h3>
<p>进一步地，对有限群的共轭作用进行分析，可以得到 Sylow 定理。它是处理有限群的结构的有力工具，可以迅速地得到大量小阶群的结构。</p>
<details class="abstract" open="open">
<summary><span class="arithmatex">\(p\)</span>‑群</summary>
<p>对于群 <span class="arithmatex">\(G\)</span>，如果存在素数 <span class="arithmatex">\(p\)</span> 和正整数 <span class="arithmatex">\(\alpha\)</span> 使得 <span class="arithmatex">\(|G|=p^\alpha\)</span>，则称它为 <strong><span class="arithmatex">\(p\)</span>‑群</strong>（<span class="arithmatex">\(p\)</span>-group）。</p>
</details>
<details class="info">
<summary>关于 <span class="arithmatex">\(p\)</span>‑群的定义</summary>
<p><span class="arithmatex">\(p\)</span>‑群还有另外一种定义，即所有元素的阶都是素数的幂的群。这两种定义对于有限群是等价的；但是，第二种定义同样适用于无限群的情形。另外，关于 <span class="arithmatex">\(p\)</span>‑群的定义，不同的文献可能对于是否将 <span class="arithmatex">\(\{e\}\)</span> 算作 <span class="arithmatex">\(p\)</span>‑群存在分歧，读者在阅读时应当加以分辨。</p>
</details>
<details class="abstract" open="open">
<summary><span class="arithmatex">\(p\)</span>‑子群</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子群 <span class="arithmatex">\(P\le G\)</span>，如果 <span class="arithmatex">\(P\)</span> 本身是一个 <span class="arithmatex">\(p\)</span>‑群，则称 <span class="arithmatex">\(P\)</span> 为 <strong><span class="arithmatex">\(p\)</span>‑子群</strong>（<span class="arithmatex">\(p\)</span>-subgroup）。</p>
</details>
<details class="note" open="open">
<summary>Cauchy 定理</summary>
<p>如果素数 <span class="arithmatex">\(p\)</span> 能够整除群 <span class="arithmatex">\(G\)</span> 的阶，则必然存在 <span class="arithmatex">\(p\)</span> 阶元。</p>
</details>
<p>Cauchy 定理保证了 <span class="arithmatex">\(p\)</span>‑子群的存在性。其实，通过更为细致的分析，能够得到更强的结论，即 Sylow <span class="arithmatex">\(p\)</span>‑子群的存在性。</p>
<details class="abstract" open="open">
<summary>Sylow <span class="arithmatex">\(p\)</span>‑子群</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子群 <span class="arithmatex">\(P\le G\)</span>，如果 <span class="arithmatex">\(|G|=p^\alpha m\)</span>，<span class="arithmatex">\(p\perp m\)</span> 且 <span class="arithmatex">\(|P|=p^\alpha\)</span>，则称 <span class="arithmatex">\(P\)</span> 为 <strong>Sylow <span class="arithmatex">\(p\)</span>‑子群</strong>（Sylow <span class="arithmatex">\(p\)</span>-subgroup）。</p>
</details>
<p>也就是说，Sylow <span class="arithmatex">\(p\)</span>‑子群是极大的 <span class="arithmatex">\(p\)</span>‑子群。Sylow 定理断言了 Sylow <span class="arithmatex">\(p\)</span>‑子群的存在性，这提供了 Lagrange 定理的一定程度的逆命题。</p>
<details class="note" open="open">
<summary>Sylow 定理</summary>
<p>设有限群 <span class="arithmatex">\(G\)</span> 的阶 <span class="arithmatex">\(|G|\)</span> 能表达成 <span class="arithmatex">\(p^\alpha m\)</span> 的形式，其中，<span class="arithmatex">\(p\)</span> 是质数且 <span class="arithmatex">\(p\)</span> 不能整除 <span class="arithmatex">\(m\)</span>，那么有如下结论：</p>
<ol>
<li>存在 Sylow <span class="arithmatex">\(p\)</span>‑子群；</li>
<li>对于一个 Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P\)</span> 和一个群 <span class="arithmatex">\(G\)</span> 的 <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(Q\)</span>，存在 <span class="arithmatex">\(g\in G\)</span> 使得 <span class="arithmatex">\(Q\le gPg^{-1}\)</span> 成立，特别地，所有 Sylow <span class="arithmatex">\(p\)</span>‑子群都共轭；</li>
<li>群 <span class="arithmatex">\(G\)</span> 中的 Sylow <span class="arithmatex">\(p\)</span>‑子群的数目 <span class="arithmatex">\(n_p\)</span> 满足 <span class="arithmatex">\(n_p\equiv 1\pmod p\)</span>，<span class="arithmatex">\(n_p\mid m\)</span> 且 <span class="arithmatex">\(n_p=[G:N_G(P)]\)</span>，其中 <span class="arithmatex">\(P\)</span> 是任意的 Sylow <span class="arithmatex">\(p\)</span>‑子群。</li>
</ol>
</details>
<details class="note">
<summary>证明</summary>
<p>为证明第一部分，对 <span class="arithmatex">\(|G|\)</span> 进行归纳。考虑类方程</p>
<div class="arithmatex">\[
|G|=|Z(G)|+\sum_{i=1}^r[G:C_G(g_i)].
\]</div>
<p>如果 <span class="arithmatex">\(p\mid|Z(G)|\)</span>，那么可以任取中心的 <span class="arithmatex">\(p\)</span> 阶子群 <span class="arithmatex">\(N\le Z(G)\)</span>，则必然有 <span class="arithmatex">\(N\trianglelefteq Z(G)\trianglelefteq G\)</span>，因而，<span class="arithmatex">\(G/N\)</span> 是更小的群。根据归纳假设，它有 Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P/N\)</span>，则自然同态下相应的原像 <span class="arithmatex">\(P\)</span> 就是原来的群 <span class="arithmatex">\(G\)</span> 的 Sylow <span class="arithmatex">\(p\)</span>‑子群。于是，只要考虑 <span class="arithmatex">\(p\)</span> 不能整除 <span class="arithmatex">\(|Z(G)|\)</span> 的情形。此时，可以取 <span class="arithmatex">\(g_i\in G\)</span>，使得 <span class="arithmatex">\(p\)</span> 不能整除 <span class="arithmatex">\([G:C_G(g_i)]\)</span>，因而，<span class="arithmatex">\(|G|\)</span> 中 <span class="arithmatex">\(p\)</span> 的全部幂次都出现在 <span class="arithmatex">\(|C_G(g_i)|\)</span> 中。再次根据归纳假设，<span class="arithmatex">\(|C_G(g_i)|\)</span> 有 Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P\)</span>，它正是原来的群 <span class="arithmatex">\(G\)</span> 的 Sylow <span class="arithmatex">\(p\)</span>‑子群。</p>
<p>为证明第二部分和第三部分，设群 <span class="arithmatex">\(G\)</span> 的 Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P\)</span> 的共轭类为 <span class="arithmatex">\(\mathcal S=\{gPg^{-1}:g\in G\}\)</span>，并考察群 <span class="arithmatex">\(G\)</span> 在 <span class="arithmatex">\(\mathcal S\)</span> 上的共轭作用限制在某一 <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(Q\)</span> 上的结果。集合 <span class="arithmatex">\(\mathcal S\)</span> 可以在该作用下可以划分成若干轨道。设总共有 <span class="arithmatex">\(r\)</span> 个轨道，每个轨道的代表元为 <span class="arithmatex">\(P_i\)</span>，则有恒等式</p>
<div class="arithmatex">\[
|\mathcal S|=\sum_{i=1}^r[Q:Q\cap N_G(P_i)].
\]</div>
<p>这里，<span class="arithmatex">\(Q\cap N_G(P_i)\)</span> 是 <span class="arithmatex">\(P_i\)</span> 在上述群作用下的稳定化子。设 <span class="arithmatex">\(H=Q\cap N_G(P_i)\)</span>，则显然 <span class="arithmatex">\(H\le N_G(P_i)\)</span>，故而根据群的第二同构定理，有 <span class="arithmatex">\(P_iH/P_i\cong H/(P_i\cap H)\)</span>。所以，<span class="arithmatex">\(|P_iH|=|P_i||H|/|P_i\cap H|\)</span>，而右侧是 <span class="arithmatex">\(p\)</span> 的幂，左侧必然也是 <span class="arithmatex">\(p\)</span> 的幂，而且需要成立 <span class="arithmatex">\(|P_i|\le |P_iH|\)</span>。但是，<span class="arithmatex">\(P_i\)</span> 已经是 <span class="arithmatex">\(G\)</span> 的子群中 <span class="arithmatex">\(p\)</span> 的幂次最大的，所以 <span class="arithmatex">\(P_i=P_iH\)</span>。代入前文的同构关系中，就有 <span class="arithmatex">\(H=P_i\cap H=Q\cap P_i\)</span>。这里用到了显然的关系 <span class="arithmatex">\(P_i\le N_G(P_i)\)</span>。这样，就知道稳定化子 <span class="arithmatex">\(Q\cap N_G(P_i)\)</span> 实际上就是 <span class="arithmatex">\(Q\cap P_i\)</span>。所以，上式可以写作</p>
<div class="arithmatex">\[
|\mathcal S|=\sum_{i=1}^r[Q:Q\cap P_i].
\]</div>
<p>这一等式对于所有 <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(Q\)</span> 都成立。</p>
<p>自然，Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P\)</span> 也是 <span class="arithmatex">\(p\)</span>‑子群。将 <span class="arithmatex">\(P\)</span> 代入上式中的 <span class="arithmatex">\(Q\)</span>，则右侧有且仅有一项的大小是 <span class="arithmatex">\(1\)</span>，其余都是 <span class="arithmatex">\(p\)</span> 的倍数。因此，Sylow <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(P\)</span> 的共轭类的大小 <span class="arithmatex">\(|\mathcal S|\)</span> 必然模 <span class="arithmatex">\(p\)</span> 余 <span class="arithmatex">\(1\)</span>。同时，因为这一式子对于任何 <span class="arithmatex">\(p\)</span>‑子群 <span class="arithmatex">\(Q\)</span> 都成立，就自然存在 <span class="arithmatex">\(g\in G\)</span>，使得 <span class="arithmatex">\(Q\le gPg^{-1}\)</span>；否则，对所有上述等式中的 <span class="arithmatex">\(P_i\)</span> 都有 <span class="arithmatex">\(|Q\cap P_i|&lt;|Q|\)</span>，就与 <span class="arithmatex">\(|\mathcal S|\equiv 1\pmod p\)</span> 矛盾。如果此时再考虑 <span class="arithmatex">\(Q\)</span> 是某个不同于 <span class="arithmatex">\(P\)</span> 的 Sylow <span class="arithmatex">\(p\)</span>‑子群，则必然有 <span class="arithmatex">\(Q=gPg^{-1}\)</span> 对某个 <span class="arithmatex">\(g\in G\)</span> 成立，即所有 Sylow <span class="arithmatex">\(p\)</span>‑子群都共轭。因而，Sylow <span class="arithmatex">\(p\)</span>‑子群的数目 <span class="arithmatex">\(n_p\)</span> 就是 <span class="arithmatex">\(|\mathcal S|\)</span>，它必然满足 <span class="arithmatex">\(n_p\equiv 1\pmod p\)</span>。最后，注意到 <span class="arithmatex">\(n_p=|\mathcal S|=[G:N_G(P)]\)</span>，且 <span class="arithmatex">\(P\le N_G(P)\)</span>，就成立 <span class="arithmatex">\(n_p\mid m\)</span>。这样就完整地证明了定理的第二部分和第三部分。</p>
</details>
<details class="example">
<summary>应用：同构意义下，六阶群只有 <span class="arithmatex">\(C_6\)</span> 和 <span class="arithmatex">\(S_3\)</span></summary>
<p>设 <span class="arithmatex">\(G\)</span> 的阶是 <span class="arithmatex">\(6\)</span>。那么，根据 Sylow 定理，它有 Sylow <span class="arithmatex">\(2\)</span>‑子群，且它的数目满足 <span class="arithmatex">\(n_2\equiv 1\pmod 2\)</span> 和 <span class="arithmatex">\(n_2\mid 3\)</span>，所以，只有两个情形：<span class="arithmatex">\(n_2=1\)</span> 或 <span class="arithmatex">\(n_2=3\)</span>。同理，可以证明群 <span class="arithmatex">\(G\)</span> 有且只有一个 Sylow <span class="arithmatex">\(3\)</span>‑子群，即 <span class="arithmatex">\(n_3=1\)</span>。</p>
<p>对于 <span class="arithmatex">\(n_2=1\)</span> 的情形，可以发现群 <span class="arithmatex">\(G\)</span> 中有一个 Sylow <span class="arithmatex">\(2\)</span>‑子群，故而有一个 <span class="arithmatex">\(2\)</span> 阶元；又有一个 Sylow <span class="arithmatex">\(3\)</span>‑子群，故而有两个 <span class="arithmatex">\(3\)</span> 阶元。群 <span class="arithmatex">\(G\)</span> 还有一个单位元，而剩下的元素，根据 Lagrange 定理，它的阶数必须整除 <span class="arithmatex">\(6\)</span>。又不能是新的 <span class="arithmatex">\(2\)</span> 阶或 <span class="arithmatex">\(3\)</span> 阶元，否则会出现与前文不同的新的 Sylow <span class="arithmatex">\(p\)</span>‑子群；所以，剩下的元素只能是 <span class="arithmatex">\(6\)</span> 阶元。存在和群的阶数相同的元素，这意味着群 <span class="arithmatex">\(G\)</span> 是循环群，所以 <span class="arithmatex">\(G\cong C_6\)</span>。</p>
<p>对于 <span class="arithmatex">\(n_2=3\)</span> 的情形，群 <span class="arithmatex">\(G\)</span> 有三个共轭的 Sylow <span class="arithmatex">\(3\)</span>‑子群。考虑群 <span class="arithmatex">\(G\)</span> 在这三个 Sylow <span class="arithmatex">\(3\)</span>‑子群上的共轭作用。对于任何一个 Sylow <span class="arithmatex">\(3\)</span>‑子群 <span class="arithmatex">\(P\)</span>，根据 Sylow 定理，有 <span class="arithmatex">\(|N_G(P)|=2\)</span>；但又有 <span class="arithmatex">\(P\le N_G(P)\)</span>，所以 <span class="arithmatex">\(P=N_G(P)\)</span>。因此，这三个 Sylow <span class="arithmatex">\(3\)</span>‑子群的正规化子的交集，即这个共轭作用的核，是平凡的。所以，这个作用是忠实的，它将 <span class="arithmatex">\(G\)</span> 嵌入到了这三个 Sylow <span class="arithmatex">\(3\)</span>‑子群上的置换群 <span class="arithmatex">\(S_3\)</span>。但是，因为 <span class="arithmatex">\(|G|=|S_3|\)</span>，必然有 <span class="arithmatex">\(G\cong S_3\)</span>。</p>
</details>
<h2 id="有限生成-abel-群">有限生成 Abel 群<a class="headerlink" href="#有限生成-abel-群" title="Permanent link"></a></h2>
<p>在掌握分析群结构的基本工具后，现在重点讨论一类群的结构。</p>
<p>在概述中提到，Abel 群因为元素可以交换，结构相较于其它群更为简单。其中尤为简单的是那些可以通过有限多个元素生成的 Abel 群。</p>
<details class="abstract" open="open">
<summary>有限生成</summary>
<p>如果群 <span class="arithmatex">\(G\)</span> 有一个有限的生成子集，则称群 <span class="arithmatex">\(G\)</span> 是 <strong>有限生成的</strong>（finitely generated）。</p>
</details>
<p>本节的分类定理说明，有限生成的 Abel 群可以看作是有限多个的循环群的简单组合。算法竞赛中涉及的群多为有限群。有限 Abel 群必然是有限生成的，因此总是适用这一结论。</p>
<h3 id="直积">直积<a class="headerlink" href="#直积" title="Permanent link"></a></h3>
<p>前文对群的分析主要集中在如何将群分解为更小的群；相反地，自然可以讨论如何将两个群组合成更大的群。在所有可能的组合方式中，群的直积是最为简单的一种。</p>
<p>群的直积的基本想法是，给定两个群 <span class="arithmatex">\(G\)</span> 和 <span class="arithmatex">\(H\)</span>，考虑其笛卡尔积 <span class="arithmatex">\(G\times H\)</span>，二元对 <span class="arithmatex">\((g,h)\)</span> 的运算定义为对两分量分别运算，分量之间互不影响。这样得到的结果显然是更大的群，且原来的两个群可以平凡地嵌入新的群中。</p>
<details class="abstract" open="open">
<summary>直积</summary>
<p>群 <span class="arithmatex">\((G,\cdot_G)\)</span> 和群 <span class="arithmatex">\((H,\cdot_H)\)</span> 的 <strong>直积</strong>（direct product）是群 <span class="arithmatex">\((G\times H,\cdot)\)</span>，其中，二元运算 <span class="arithmatex">\(\cdot:(G\times H)\times(G\times H)\rightarrow G\times H\)</span> 定义为 <span class="arithmatex">\((g_1,h_1)\cdot(g_2,h_2)=(g_1\cdot_G g_2,h_1\cdot_H h_2)\)</span>。群 <span class="arithmatex">\(G\)</span> 和群 <span class="arithmatex">\(H\)</span> 的直积记为 <span class="arithmatex">\(G\times H\)</span>。</p>
</details>
<p>对于直积 <span class="arithmatex">\(G\times H\)</span>，平凡地有嵌入映射 <span class="arithmatex">\(g\mapsto(g,e_H)\)</span> 和 <span class="arithmatex">\(h\mapsto(e_G,h)\)</span>。反过来，映射 <span class="arithmatex">\((g,h)\mapsto g\)</span> 和映射 <span class="arithmatex">\((g,h)\mapsto h\)</span> 是群同态，同态的核分别是 <span class="arithmatex">\(\{e_G\}\times H\)</span> 和 <span class="arithmatex">\(G\times\{e_H\}\)</span>。这两个核恰好是上述嵌入映射的像，且它们的交集是平凡的，即 <span class="arithmatex">\(\{(e_G,e_H)\}\)</span>。所以，群的直积 <span class="arithmatex">\(G\times H\)</span> 中有两个子群，都是正规子群，交集是平凡的，且它们的乘积就是直积 <span class="arithmatex">\(G\times H\)</span> 本身。</p>
<p>这样的分析其实给出了一个群能够写成它的两个子群的直积的充分必要条件。</p>
<details class="note" open="open">
<summary>定理</summary>
<p>对于群 <span class="arithmatex">\(G\)</span> 和它的子群 <span class="arithmatex">\(H_1,H_2\le G\)</span>，<span class="arithmatex">\(G\cong H_1\times H_2\)</span> 当且仅当 <span class="arithmatex">\(H_1,H_2\trianglelefteq G\)</span>，<span class="arithmatex">\(H_1\cap H_2=\{e\}\)</span> 且 <span class="arithmatex">\(G=H_1H_2\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>这些条件的必要性在正文中已经讨论过，这里证明它们的充分性。考察映射 <span class="arithmatex">\(\varphi:G\rightarrow H_1\times H_2\)</span> 满足 <span class="arithmatex">\(h_1h_2\mapsto(h_1,h_2)\)</span>。映射 <span class="arithmatex">\(\varphi\)</span> 是良定义的，因为对于任意 <span class="arithmatex">\(h_1,k_1\in H_1\)</span> 和 <span class="arithmatex">\(h_2,k_2\in H_2\)</span>，满足 <span class="arithmatex">\(h_1h_2=k_1k_2\)</span> 就意味着 <span class="arithmatex">\(h_1=k_1\)</span> 和 <span class="arithmatex">\(h_2=k_2\)</span>；这是因为 <span class="arithmatex">\(k_1^{-1}h_1=k_2h_2^{-1}\in H_1\cap H_2=\{e\}\)</span>。要说明 <span class="arithmatex">\(\varphi\)</span> 是群同态，则就是要说明 <span class="arithmatex">\((h_1h_2)(k_1k_2)=h_1k_1h_2k_2\)</span>，这等价于 <span class="arithmatex">\(k_1\)</span> 和 <span class="arithmatex">\(h_2\)</span> 是可交换的，亦即 <span class="arithmatex">\(k_1h_2k_1^{-1}h_2^{-1}=e\)</span>。要证明这一关系，只要注意到 <span class="arithmatex">\(k_1h_2k_1^{-1}h_2^{-1}=(k_1h_2k_1^{-1})h_2^{-1}\in (k_1H_2k_1^{-1})H_2=H_2\)</span>，同理也有 <span class="arithmatex">\(k_1(h_2k_1^{-1}h_2^{-1})\in H_1\)</span>，故而 <span class="arithmatex">\(k_1h_2k_1^{-1}h_2^{-1}\in H_1\cap H_2=\{e\}\)</span>。这些就证明了 <span class="arithmatex">\(\varphi\)</span> 是群同态。它显然是双射，故而它是同构，即 <span class="arithmatex">\(G\cong H_1\times H_2\)</span>。</p>
</details>
<p>在直积中，两个直积因子的元素必然是可以交换的，这是因为 <span class="arithmatex">\(hg=(e_G,h)(g,e_H)=(g,h)=gh\)</span>。所以，如果两个直积因子都是 Abel 群，那么直积也必然是 Abel 群。</p>
<p>并不是所有的群都可以写成两个非平凡子群的直积。</p>
<details class="example" open="open">
<summary>例子：正三角形的空间对称群 <span class="arithmatex">\(D_6\)</span>（续）</summary>
<p>例如，群 <span class="arithmatex">\(D_6=\langle r,s\rangle\)</span> 就不同构于 <span class="arithmatex">\(\langle r\rangle\times\langle s\rangle\)</span>，因为作为两个循环群的直积，后者必然是 Abel 群。</p>
</details>
<p>下面的分类定理则说明，有限生成的 Abel 群都可以写作有限多个循环群的直积。</p>
<h3 id="分类定理">分类定理<a class="headerlink" href="#分类定理" title="Permanent link"></a></h3>
<p>对于有限生成的 Abel 群，有如下分类定理。它称为 <strong>有限生成 Abel 群基本定理</strong>（fundamental theorem of finitely generated Abelian groups）。</p>
<details class="note" open="open">
<summary>有限生成 Abel 群基本定理</summary>
<p>对于有限生成的 Abel 群 <span class="arithmatex">\(G\)</span>，存在整数 <span class="arithmatex">\(r\ge0\)</span> 和 <span class="arithmatex">\(n_1,\cdots,n_s\ge 2\)</span>，使得</p>
<div class="arithmatex">\[
G\cong C_\infty^r\times C_{n_1}\times\cdots\times C_{n_s}.
\]</div>
<p>特别地，<span class="arithmatex">\(r\)</span> 是唯一确定的，称为群 <span class="arithmatex">\(G\)</span> 的 <strong>阶</strong>（rank），而且</p>
<ul>
<li>可以选取整数 <span class="arithmatex">\(n_1,\cdots,n_s\)</span> 使其满足 <span class="arithmatex">\(n_1\ge2,\ n_1|n_2,\ \cdots,\ n_{s-1}|n_s\)</span>，此时，整数 <span class="arithmatex">\(n_1,\cdots,n_s\)</span> 唯一确定，因子 <span class="arithmatex">\(C_{n_i}\)</span> 称为群 <span class="arithmatex">\(G\)</span> 的 <strong>不变因子</strong>（invariant factor）；</li>
<li>也可以选取整数 <span class="arithmatex">\(n_1,\cdots,n_s\)</span> 使其都是素数幂的形式，此时，这些素数幂也都唯一确定，因子 <span class="arithmatex">\(C_{n_i}\)</span> 称为群 <span class="arithmatex">\(G\)</span> 的 <strong>初等因子</strong>（elementary divisor）。</li>
</ul>
</details>
<p>定理首先断言，有限生成的 Abel 群一定是有限多个循环群的直积。</p>
<details class="note">
<summary>证明</summary>
<p>这里给出一个形式简单的证明<sup id="fnref:proof-abelian"><a class="footnote-ref" href="#fn:proof-abelian">6</a></sup>；更深刻的证明应当参考主理想整环上的有限生成模的结构定理<sup id="fnref:module-pid"><a class="footnote-ref" href="#fn:module-pid">7</a></sup>。在证明中，为书写简便，将使用加法记号代替一般的群中的乘法记号，此时 <span class="arithmatex">\(0\)</span> 代表单位元，而记号 <span class="arithmatex">\(mx\)</span> 代表 <span class="arithmatex">\(x\)</span> 的 <span class="arithmatex">\(m\)</span> 次幂。</p>
<p>设 <span class="arithmatex">\(G\)</span> 最少可以由 <span class="arithmatex">\(k\)</span> 个元素生成。定理的证明需要对 <span class="arithmatex">\(k\)</span> 进行归纳。当 <span class="arithmatex">\(k=1\)</span> 时结论是平凡的。当 <span class="arithmatex">\(k&gt;1\)</span> 时，取 <span class="arithmatex">\(G\)</span> 的全体生成元组 <span class="arithmatex">\(\langle x_1,x_2,\cdots,x_k\rangle\)</span> 中 <span class="arithmatex">\(x_1\)</span> 的阶最小的那个。下面要说明 <span class="arithmatex">\(G=\langle x_1\rangle\times\langle x_2,\cdots,x_k\rangle\)</span>，后者则根据归纳假设已经可以分解成 <span class="arithmatex">\((k-1)\)</span> 个循环群的直积，故归纳步骤得证。</p>
<p>根据群的直积的刻画，如果直积分解不成立，必然存在关系 <span class="arithmatex">\(m_1x_1+m_2x_2+\cdots+m_kx_k=0\)</span>，且 <span class="arithmatex">\(m_1x_1\neq 0\)</span>。对于负的系数 <span class="arithmatex">\(m_i\)</span>，可以用逆元 <span class="arithmatex">\(-x_i\)</span> 代替 <span class="arithmatex">\(x_i\)</span>，则所有系数 <span class="arithmatex">\(m_i\)</span> 都可以取作非负整数。而且，此时可以取 <span class="arithmatex">\(0&lt; m_1 &lt;|x_1|\)</span>。如果再取 <span class="arithmatex">\(d=\gcd(m_1,m_2,\cdots,m_k)\)</span> 和 <span class="arithmatex">\(c_i=m_i/d\)</span>，则必然有 <span class="arithmatex">\(y_1=c_1x_1+c_2x_2+\cdots+c_kx_k\)</span> 满足 <span class="arithmatex">\(dy_1=0\)</span>，因而 <span class="arithmatex">\(|y_1|\le d\le m_1&lt; |x_1|\)</span>，即 <span class="arithmatex">\(y_1\)</span> 是比 <span class="arithmatex">\(x_1\)</span> 阶更小的元素。</p>
<p>下面证明，<span class="arithmatex">\(y_1\)</span> 可以扩张成 <span class="arithmatex">\(G\)</span> 的一组生成元。也就是说，存在元素 <span class="arithmatex">\(y_2,\cdots,y_k\in G\)</span> 满足 <span class="arithmatex">\(G=\langle y_1,y_2,\cdots,y_k\rangle\)</span>。这里唯一的已知条件是 <span class="arithmatex">\(y_1\)</span> 本身可以写作 <span class="arithmatex">\(c_1x_1+c_2x_2+\cdots+c_kx_k\)</span>，其中，系数 <span class="arithmatex">\(c_i\)</span> 都是自然数且它们的最大公约数是一。不妨假设系数（非严格）递减排列，则 <span class="arithmatex">\(y_1\)</span> 也可以写作 <span class="arithmatex">\((c_1-c_2)x_1+c_2(x_1+x_2)+\cdots+c_kx_k\)</span>。此时，对比之前的条件，可以发现系数依然全部是自然数，且最大公约数是一，而且 <span class="arithmatex">\(G=\langle x_1,x_1+x_2,x_3,\cdots,x_k\rangle\)</span>，但是全体系数的和减少了 <span class="arithmatex">\(c_2\)</span>。如果 <span class="arithmatex">\(c_2=0\)</span>，则必然有 <span class="arithmatex">\(c_1=1\)</span>，结论是平凡的；否则，系数的和严格地减少了。这意味着，如果对系数的和进行归纳，就可以证明满足上述条件的 <span class="arithmatex">\(y_1\)</span> 总可以扩张成 <span class="arithmatex">\(G\)</span> 的一组生成元。</p>
<p>进而，此时找到了比 <span class="arithmatex">\(x_1\)</span> 更小阶的生成元 <span class="arithmatex">\(y_1\)</span>，这与 <span class="arithmatex">\(x_1\)</span> 的选取矛盾。所以，直积分解必然成立，根据归纳原理就知道所求证的结论成立。</p>
</details>
<p>当然，循环群可能是无限阶的或是有限阶的，它们分别是上述分解的 <span class="arithmatex">\(C_\infty\)</span> 部分和 <span class="arithmatex">\(C_{n_i}\)</span> 部分。然后，定理给出了有限阶循环群 <span class="arithmatex">\(C_n\)</span> 的结构。定理的初等因子分解的部分其实依赖于如下观察。</p>
<details class="note" open="open">
<summary>引理</summary>
<p>如果 <span class="arithmatex">\(m\)</span> 与 <span class="arithmatex">\(n\)</span> 互质，那么 <span class="arithmatex">\(C_{mn}\cong C_m\times C_n\)</span>。</p>
</details>
<details class="note">
<summary>证明</summary>
<p>设 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 分别是 <span class="arithmatex">\(C_m\)</span> 和 <span class="arithmatex">\(C_n\)</span> 的生成元，那么因为 <span class="arithmatex">\((m,n)=1\)</span>，就有 <span class="arithmatex">\(|(x,y)|=mn=|C_m\times C_n|\)</span>。所以，<span class="arithmatex">\((x,y)\)</span> 就是 <span class="arithmatex">\(C_m\times C_n\)</span> 的生成元，亦即 <span class="arithmatex">\(C_m\times C_n=\langle(x,y)\rangle\)</span>。所以，它是 <span class="arithmatex">\(mn\)</span> 阶循环群，必然同构于 <span class="arithmatex">\(C_{mn}\)</span>。</p>
</details>
<p>给定循环群 <span class="arithmatex">\(C_{n}\)</span>，如果根据算术基本定理有 <span class="arithmatex">\(n=p_1^{r_1}\cdots p_k^{r_k}\)</span>，那么重复利用引理，就可以证明 <span class="arithmatex">\(C_n=C_{p_1^{r_1}}\times\cdots\times C_{p_k^{r_k}}\)</span>。在这两步分解之后，实际上就已经得到了定理中的初等因子分解。再根据引理，重组这些素数幂阶循环群，使得它们的阶数符合要求，就可以得到定理中的不变因子分解。定理中的唯一性可以归纳证明得出。</p>
<details class="example">
<summary>例子：24 阶 Abel 群的分类</summary>
<p>作为示例，可以通过定理得知所有的 24 阶 Abel 群共三种，列举如下。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">不变因子分解</th>
<th style="text-align: center;">初等因子分解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(C_{24}\)</span></td>
<td style="text-align: center;"><span class="arithmatex">\(C_{3}\times C_{8}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(C_{2}\times C_{12}\)</span></td>
<td style="text-align: center;"><span class="arithmatex">\(C_2\times C_{3}\times C_4\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(C_2\times C_2\times C_6\)</span></td>
<td style="text-align: center;"><span class="arithmatex">\(C_2\times C_2\times C_2\times C_3\)</span></td>
</tr>
</tbody>
</table>
</details>
<h2 id="参考资料与注释">参考资料与注释<a class="headerlink" href="#参考资料与注释" title="Permanent link"></a></h2>
<ul>
<li>Dummitt, D.S. and Foote, R.M. (2004) Abstract Algebra. 3<sup>rd</sup> Edition, John Wiley &amp; Sons, Inc.</li>
<li><a href="https://www.jmilne.org/math/CourseNotes/GT.pdf">Milne, J.S. (2021) Group Theory</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Group_%28mathematics%29">Group (mathematics) - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Group_theory">Group theory - Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/Group.html">Group - Wolfram MathWorld</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLwV-9DG53NDxU337smpTwm6sef4x-SCLv">Visual Group Theory</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:klein">
<p>这个群可以表示为置换群 <span class="arithmatex">\(\{(1),(12)(34),(13)(24),(14)(23)\}\)</span>，也可以写作 <span class="arithmatex">\(C_2\times C_2\)</span>。&#160;<a class="footnote-backref" href="#fnref:klein" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:quotient">
<p>对于一般的子群 <span class="arithmatex">\(H\le G\)</span>，也可以在全体左（右）陪集上尝试定义类似的运算。但是，这样的运算是良定义的，当且仅当 <span class="arithmatex">\(H\)</span> 是 <span class="arithmatex">\(G\)</span> 的正规子群。&#160;<a class="footnote-backref" href="#fnref:quotient" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:group-action">
<p>比如 <a href="https://en.wikipedia.org/wiki/Group_action">Group action - Wikipedia</a>。&#160;<a class="footnote-backref" href="#fnref:group-action" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:cayley">
<p>Cayley 定理本身没有反映太多群本身结构的信息，因为 <span class="arithmatex">\(S_G\)</span> 这个群的规模通常很庞大，很难讲它的某个大小恰为 <span class="arithmatex">\(|G|\)</span> 的子群拥有哪些确定的性质。但是，早期群论的发展主要集中在置换群上。所以，Cayley 定理其实是在说，所有可能的群结构都是这些已经充分研究过的对象。尽管在实际研究时，需要更为精细的工具。&#160;<a class="footnote-backref" href="#fnref:cayley" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:conjugate">
<p>更一般地，置换群中共轭的元素必然有着相同的 <a href="../../permutation/#置换的型">型</a>。&#160;<a class="footnote-backref" href="#fnref:conjugate" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:proof-abelian">
<p>参见 Milne, J.S. (2021) Group Theory 第 25 页。&#160;<a class="footnote-backref" href="#fnref:proof-abelian" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:module-pid">
<p>参见 <a href="https://en.wikipedia.org/wiki/Structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain">Structure theorem for finitely generated modules over a principal ideal domain - Wikipedia</a>。&#160;<a class="footnote-backref" href="#fnref:module-pid" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../_static/js/math-csr.js?math-csr"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>