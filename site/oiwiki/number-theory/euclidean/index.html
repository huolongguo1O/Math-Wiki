
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="sshwy, FFjet, qz-cqy">
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Euclidean - Math-wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.618322db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#引入" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Math-wiki" class="md-header__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Math-wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Euclidean
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ineq/" class="md-tabs__link">
          
  
  
  不等式

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../basic/" class="md-tabs__link">
          
  
  
  数论

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../combinatorics/combination/" class="md-tabs__link">
          
  
  
  组合数学

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../complex/" class="md-tabs__link">
          
  
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Math-wiki" class="md-nav__button md-logo" aria-label="Math-wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Math-wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    不等式
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    不等式
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    最最最基本的不等关系
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/am-gm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    均值不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/cauchy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    柯西不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/derivative/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    求导法
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/jensen/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    琴生不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/karamata/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Karamata不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/smoothing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    调整法
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/rearrangement/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    排列不等式与切比雪夫不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/schur/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    schur不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/minkowski/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    闵可夫斯基不等式
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_11" >
        
          
          <label class="md-nav__link" for="__nav_2_11" id="__nav_2_11_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    恒等变形
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_11">
            <span class="md-nav__icon md-icon"></span>
            
  
    恒等变形
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ineq/abel/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    abel变换
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数论
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    数论
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础知识
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../bezouts/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bezout定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../inverse/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    逆元
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../crt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    中国剩余定理（CRT）
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../euler-totient/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    欧拉函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fermat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    费马小定理与欧拉定理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../primitive-root/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    阶与原根
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../congruence-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    同余方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../prime/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    有关素数的更深入的研究
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quad-residue/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次剩余
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pell-equation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    pell方程
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mobius/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    莫比乌斯反演
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lift-the-exponent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    LTE引理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quadratic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    二次域
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    组合数学
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    组合数学
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/combination/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    排列组合
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/drawer-principle/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    抽屉原理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/inclusion-exclusion-principle/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    容斥原理
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/fibonacci/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    斐波那契数列
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/catalan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    卡特兰数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/bernoulli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    伯努利数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../combinatorics/stirling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Stirling数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../poly/ogf/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    普通生成函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../poly/egf/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    指数生成函数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    杂项
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    杂项
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../complex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    复数
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#引入" class="md-nav__link">
    <span class="md-ellipsis">
      
        引入
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#类欧几里得算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        类欧几里得算法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="类欧几里得算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#代数解法" class="md-nav__link">
    <span class="md-ellipsis">
      
        代数解法
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#几何直观" class="md-nav__link">
    <span class="md-ellipsis">
      
        几何直观
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#例题" class="md-nav__link">
    <span class="md-ellipsis">
      
        例题
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#万能欧几里得算法" class="md-nav__link">
    <span class="md-ellipsis">
      
        万能欧几里得算法
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="万能欧几里得算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#问题转化" class="md-nav__link">
    <span class="md-ellipsis">
      
        问题转化
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#算法过程" class="md-nav__link">
    <span class="md-ellipsis">
      
        算法过程
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#例题_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        例题
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#习题" class="md-nav__link">
    <span class="md-ellipsis">
      
        习题
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#参考资料与注释" class="md-nav__link">
    <span class="md-ellipsis">
      
        参考资料与注释
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Euclidean</h1>

<h2 id="引入">引入<a class="headerlink" href="#引入" title="Permanent link"></a></h2>
<p>类欧几里德算法是洪华敦在 2016 年冬令营营员交流中提出的内容。它常用于解决形如</p>
<div class="arithmatex">\[
\left\lfloor\dfrac{ai+b}{c}\right\rfloor
\]</div>
<p>结构的数列（下标为 <span class="arithmatex">\(i\)</span>）的求和问题。它的主要想法是，利用分数自身的递归结构，将问题转化为更小规模的问题，递归求解。因为分数的递归结构和 <a href="../gcd/#欧几里得算法">欧几里得算法</a> 存在直接的 <a href="../continued-fraction/#连分数表示的求法">联系</a>，因此，这一求和方法也称为类欧几里得算法。</p>
<p>因为 <a href="../continued-fraction/">连分数</a> 和 <a href="../stern-brocot/">Stern–Brocot 树</a> 等方法同样刻画了分数的递归结构，所以利用类欧几里得算法可以解决的问题，通常也可以用这些方法解决。与这些方法相比，类欧几里得算法通常更容易理解，它的实现也更为简明。</p>
<h2 id="类欧几里得算法">类欧几里得算法<a class="headerlink" href="#类欧几里得算法" title="Permanent link"></a></h2>
<p>最简单的例子，就是求和问题：</p>
<div class="arithmatex">\[
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor,
\]</div>
<p>其中，<span class="arithmatex">\(a,b,c,n\)</span> 都是正整数。</p>
<h3 id="代数解法">代数解法<a class="headerlink" href="#代数解法" title="Permanent link"></a></h3>
<p>首先，将 <span class="arithmatex">\(a,b\)</span> 对 <span class="arithmatex">\(c\)</span> 取模，可以简化问题，将问题转化为 <span class="arithmatex">\(0\le a,b&lt;c\)</span> 的情形：</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n)&amp;=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&amp;=\sum_{i=0}^n\left\lfloor
\frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+(a\bmod c)\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+(b\bmod c)\right)}{c}\right\rfloor\\
&amp;=\sum_{i=0}^n\left(\left\lfloor\frac{a}{c}\right\rfloor i+\left\lfloor\frac{b}{c}\right\rfloor+\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c}
\right\rfloor\right)\\
&amp;=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor
+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n).
\end{aligned}
\]</div>
<p>现在，考虑转化后的问题。令</p>
<div class="arithmatex">\[
m = \left\lfloor \frac{an+b}{c} \right\rfloor.
\]</div>
<p>那么，原问题可以写作二次求和式：</p>
<div class="arithmatex">\[
\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
=\sum_{i=0}^n\sum_{j=0}^{m-1}\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right].
\]</div>
<p>交换求和次序，这需要对于每个 <span class="arithmatex">\(j\)</span> 计算满足条件的 <span class="arithmatex">\(i\)</span> 的范围。为此，将条件变形：</p>
<div class="arithmatex">\[
\begin{aligned}
&amp;j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor = \left\lceil \frac{ai+b+1}{c} \right\rceil-1\\
&amp;\iff j + 1 &lt; \left\lceil \frac{ai+b+1}{c} \right\rceil
\iff j+1&lt; \frac{ai+b+1}{c} \\
&amp;\iff \dfrac{cj+c-b-1}{a} &lt; i
\iff \left\lfloor\dfrac{cj+c-b-1}{a}\right\rfloor &lt; i.
\end{aligned}
\]</div>
<p>变形过程中多次利用了 <a href="../basic/#取整函数">取整函数</a> 的性质。代入变形后的条件，原式可以写作：</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n)&amp;=\sum_{j=0}^{m-1}
\sum_{i=0}^n\left[i&gt;\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor \right]\\
&amp;=\sum_{j=0}^{m-1}\left(n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)\\
&amp;=nm-f\left(c,c-b-1,a,m-1\right).
\end{aligned}
\]</div>
<p>令 <span class="arithmatex">\((a',b',c',n')=(c,c-b-1,a,m-1)\)</span>，这就又回到了前面讨论过的 <span class="arithmatex">\(a'&gt;c'\)</span> 的情形。</p>
<p>将这两步转化结合在一起，可以发现在过程中，<span class="arithmatex">\((a,c)\)</span> 不断地取模后交换位置，直到 <span class="arithmatex">\(a=0\)</span>。这就类似于对 <span class="arithmatex">\((a,c)\)</span> 进行辗转相除，这也是类欧几里德算法的得名。它的时间复杂度是 <span class="arithmatex">\(O(\log\min\{a,c\})\)</span> 的。</p>
<p>在计算过程中，可能会出现 <span class="arithmatex">\(m=0\)</span> 的情形，此时内层递归会出现 <span class="arithmatex">\(n=-1\)</span>。这并不影响最终的结果。但是，如果要求出现 <span class="arithmatex">\(m=0\)</span> 时，直接终止算法，那么算法的时间复杂度可以改良为 <span class="arithmatex">\(O(\log\min\{a,c,n\})\)</span> 的。</p>
<details class="note">
<summary>对复杂度的解释</summary>
<p>利用该算法和欧几里得算法的相似性，很容易说明它的时间复杂度是 <span class="arithmatex">\(O(\log\min\{a,c\})\)</span> 的。因此，只需要说明，如果在 <span class="arithmatex">\(m=0\)</span> 时终止算法，那么它的时间复杂度也是 <span class="arithmatex">\(O(\log n)\)</span> 的。</p>
<p>令 <span class="arithmatex">\(m=\lfloor(an+b)/c\rfloor\)</span>，并记 <span class="arithmatex">\(S=mn\)</span>，<span class="arithmatex">\(k=m/n\)</span>，它们分别相当于几何直观（见下一节）中点阵图的面积和直线的斜率。对于充分大的 <span class="arithmatex">\(n\)</span>，近似有 <span class="arithmatex">\(k\doteq a/c\)</span>。</p>
<p>考察 <span class="arithmatex">\(S\)</span> 和 <span class="arithmatex">\(k\)</span> 在算法过程中的变化。第一步取模时，<span class="arithmatex">\(n\)</span> 保持不变，<span class="arithmatex">\(k\)</span> 近似由 <span class="arithmatex">\(a/c\)</span> 变为 <span class="arithmatex">\((a\bmod c)/c\)</span>，相当于斜率由 <span class="arithmatex">\(k\)</span> 变为 <span class="arithmatex">\(k-\lfloor k\rfloor\)</span>，而 <span class="arithmatex">\(S\)</span> 也近似变为原来的 <span class="arithmatex">\((k-\lfloor k\rfloor)\)</span> 倍。第二步交换横纵坐标时，<span class="arithmatex">\(S\)</span> 近似保持不变，<span class="arithmatex">\(k\)</span> 则变为它的倒数。因此，若设两步操作后，二元组 <span class="arithmatex">\((k,S)\)</span> 变为 <span class="arithmatex">\((k',S')\)</span>，则有 <span class="arithmatex">\(k'=(k-\lfloor k\rfloor)^{-1}\)</span> 且 <span class="arithmatex">\(S'=(k-\lfloor k\rfloor)S\)</span>。</p>
<p>因为 <span class="arithmatex">\(1\le\lfloor k'\rfloor\le k'&lt;\lfloor k'\rfloor+1\)</span>，所以，递归计算两轮后，乘积缩小的倍数最少为</p>
<div class="arithmatex">\[
(k'-\lfloor k'\rfloor)(k-\lfloor k\rfloor) = 1-\dfrac{\lfloor k'\rfloor}{k'} &lt; 1-\dfrac{\lfloor k'\rfloor}{\lfloor k'\rfloor+1} = \dfrac{1}{\lfloor k'\rfloor+1}\le \dfrac{1}{2}.
\]</div>
<p>因此，至多 <span class="arithmatex">\(O(\log S)\)</span> 轮，算法必然终止。因为从第二轮开始，每轮开始时的 <span class="arithmatex">\(S\)</span> 总是不超过上一轮取模结束后的 <span class="arithmatex">\(S\)</span>，而后者大致为 <span class="arithmatex">\(kn^2\)</span> 且 <span class="arithmatex">\(k&lt;1\)</span>，因而 <span class="arithmatex">\(O(\log S)\subseteq O(\log n)\)</span>。这就得到了上述结论。</p>
</details>
<p>模板题的参考实现如下：</p>
<details class="example">
<summary>模板题实现（<a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">Library Checker - Sum of Floor of Linear</a>）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-0.cpp:full-text&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h3 id="几何直观">几何直观<a class="headerlink" href="#几何直观" title="Permanent link"></a></h3>
<p>这个算法还可以从几何的角度理解。类欧几里得算法可以解决的问题主要是直线下整点计数问题。</p>
<p>如下图最左部分所示，该求和式相当于求直线</p>
<div class="arithmatex">\[
y = \dfrac{ax+b}{c}
\]</div>
<p>下方，<span class="arithmatex">\(x\)</span> 轴上方（不包括 <span class="arithmatex">\(x\)</span> 轴），且横坐标位于 <span class="arithmatex">\([0,n]\)</span> 之间的格点数目。</p>
<p><img alt="" src="../images/euclidean-1.svg" /></p>
<p>首先，移除斜率和截距中的整数部分。这一步相当于将上图中间部分的蓝点数量单独计算出来。当斜率和截距都是整数时，蓝点一定构成一个梯形阵列，也就是说，不同纵列的格点形成等差数列，因而这些点的数量是容易计算的。将这些点移除后，剩余的格点和上图最右部分的红点数量一致。问题就转化成了斜率和截距都小于一的情形。因为梯形的高为 <span class="arithmatex">\(n+1\)</span> 且两个底边长度分别为 <span class="arithmatex">\(\lfloor b/c\rfloor\)</span> 和 <span class="arithmatex">\((\lfloor a/c\rfloor n+\lfloor b/c\rfloor)\)</span>，所以，利用梯形面积公式，这一步骤可以归纳为算式</p>
<div class="arithmatex">\[
f(a,b,c,n) = f(a\bmod c,b\bmod c,c,n) + \dfrac{1}{2}(n+1)\left(\left\lfloor\dfrac{b}{c}\right\rfloor+\left(\left\lfloor\dfrac{a}{c}\right\rfloor n+\left\lfloor\dfrac{b}{c}\right\rfloor\right)\right).
\]</div>
<p>然后，翻转横纵坐标轴。如下图最左部分所示，图中的红点和蓝点构成了一个横向长度为 <span class="arithmatex">\(n\)</span>、纵向长度为 <span class="arithmatex">\(m=\lfloor(an+b)/c\rfloor\)</span> 的矩形点阵。要计算红点的数量，只需要计算蓝点的数量，再用矩形点阵的数量减去蓝点的数量即可。翻转后，上图左半部分中的蓝点点阵就变成了某条直线下的红色点阵。而且，翻转后，斜率大于一，就又回到了上文已经处理过的情形。</p>
<p><img alt="" src="../images/euclidean-2.svg" /></p>
<p>关键在于如何计算新的红色点阵上方的直线的方程。将上图最左部分的横纵坐标轴翻转，就得到上图中间部分。翻转后的红色点阵上方的直线（中间部分的实线），并非对应翻转前的直线（最左部分的实线），而是翻转前的直线向左上平移一点点的结果（最左部分的虚线）。这是因为，如果直接将直线（最左部分的实线）翻转，将得到中间部分的虚线，但是按照定义，它下方的格点包括恰好落在直线上的格点，这就会导致直线上的格点重复计数。为了避免这一点，需要将翻转直线 <span class="arithmatex">\(y=(ax+b)/c\)</span> 后得到的直线 <span class="arithmatex">\(y=(cx-b)/a\)</span> 向下平移一点点，得到直线 <span class="arithmatex">\(y=(cx-b-1)/a\)</span>，这样它下方的点阵才恰为翻转前的蓝色点阵。</p>
<p>还有另一处细节需要处理。上图中间部分的直线的截距是负数，这意味着还没有回到之前的初始情形。要让截距恢复为非负数，只需要将直线（中间部分的实线）向左平移一个单位。这样做不会漏掉任何格点，因为翻转前的蓝色点阵中没有纵坐标为零的点，翻转后也就不存在横坐标为零的点。最后，直线方程就变为 <span class="arithmatex">\(y=(cx+c-b-1)/a\)</span>；同时，点阵的横坐标的上界也从 <span class="arithmatex">\(m\)</span> 变成了 <span class="arithmatex">\(m-1\)</span>。这一步骤可以归纳为算式</p>
<div class="arithmatex">\[
f(a,b,c,n) = mn - f(c,c-b-1,a,m-1).
\]</div>
<p>这种递归的算法行得通，主要有两个原因：</p>
<ul>
<li>第一，直线的斜率不断地先取小数部分再取倒数，这等价于计算直线斜率 <span class="arithmatex">\(k=a/c\)</span> 的 <a href="../continued-fraction/#连分数表示的求法">连分数展开</a>。因为有理分数的连分数展开的长度是 <span class="arithmatex">\(O(\log\min\{a,c\})\)</span> 的，所以这一过程一定在 <span class="arithmatex">\(O(\log\min\{a,c\})\)</span> 步后终止；</li>
<li>第二，因为每次翻转坐标轴的时候，直线斜率都是小于一的，因此，直觉上应该有 <span class="arithmatex">\(m&lt;n\)</span>，也就是说，经过这样一轮迭代后，横坐标的范围一直是在缩小的。前文的复杂度计算中通过严格的分析说明，每两轮迭代后，<span class="arithmatex">\(n\)</span> 至多为原来的一半，故而这一过程一定在 <span class="arithmatex">\(O(\log n)\)</span> 步后终止。</li>
</ul>
<p>这也是斜率为有理数时的类欧几里得算法的复杂度是 <span class="arithmatex">\(O(\log\min\{a,c,n\})\)</span> 的原因。</p>
<p>利用类似的几何直观，可以将类欧几里得算法推广到斜率为无理数的情形，具体分析请参考后文的例题。</p>
<h3 id="例题">例题<a class="headerlink" href="#例题" title="Permanent link"></a></h3>
<details class="example" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P5170">【模板】类欧几里得算法</a></summary>
<p>多组询问。给定正整数 <span class="arithmatex">\(a,b,c,n\)</span>，求</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n) &amp;= \sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor,\\
g(a,b,c,n) &amp;= \sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor,\\
h(a,b,c,n) &amp;= \sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2.
\end{aligned}
\]</div>
</details>
<details class="note">
<summary>解答一</summary>
<p>类似于 <span class="arithmatex">\(f\)</span> 的推导，可以得到 <span class="arithmatex">\(g,h\)</span> 的递归表达式。</p>
<p>首先，利用取模，将问题转化为 <span class="arithmatex">\(0\le a,b&lt;c\)</span> 的情形：</p>
<div class="arithmatex">\[
\begin{aligned}
g(a,b,c,n)
&amp;=g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2}, \\
h(a,b,c,n)&amp;=h(a\bmod c,b\bmod c,c,n)\\
&amp;\quad+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)
+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)\\
&amp;\quad+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1)
+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1).
\end{aligned}
\]</div>
<p>然后，利用交换求和次序，可以进一步转化。同样地，令</p>
<div class="arithmatex">\[
m = \left\lfloor \frac{an+b}{c} \right\rfloor.
\]</div>
<p>那么，对于和式 <span class="arithmatex">\(g\)</span>，有</p>
<div class="arithmatex">\[
\begin{aligned}
g(a,b,c,n)&amp;=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\\
&amp;=\sum_{i=0}^n \sum_{j=0}^{m-1}i
\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right] \\
&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i\left[i&gt;\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor \right]\\
&amp;=\sum_{j=0}^{m-1}\dfrac{1}{2}\left(\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor+n+1\right)\left(n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)\\
&amp;=\dfrac{1}{2}mn(n+1) - \dfrac{1}{2}\sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor - \dfrac{1}{2}\sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor^2\\
&amp;=\dfrac{1}{2}mn(n+1) - \dfrac{1}{2}f(c,c-b-1,a,m-1) - \dfrac{1}{2}h(c,c-b-1,a,m-1).
\end{aligned}
\]</div>
<p>对于和式 <span class="arithmatex">\(h\)</span>，有</p>
<div class="arithmatex">\[
\begin{aligned}
h(a,b,c,n)&amp;=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2\\
&amp;=\sum_{i=0}^n\sum_{j=0}^{m-1}(2j+1)\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\\
&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n(2j+1)\left[i&gt;\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor \right]\\
&amp;=\sum_{j=0}^{m-1}(2j+1)\left(n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\right)\\
&amp;=nm^2 - \sum_{j=0}^{m-1}\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor - 2\sum_{j=0}^{m-1}j\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\\
&amp;=nm^2 - f(c,c-b-1,a,m-1) - 2g(c,c-b-1,a,m-1).
\end{aligned}
\]</div>
<p>从几何直观的角度看，这些非线性的求和式相当于给区域中的每个点 <span class="arithmatex">\((i,j)\)</span> 都赋予了相应的权重 <span class="arithmatex">\(w(i,j)\)</span>。除了这些权重之外，其余部分的计算过程是完全一致的。对于权重的选择，一般地，有</p>
<div class="arithmatex">\[
\sum_{i=0}^ni^r\left\lfloor \frac{ai+b}{c} \right\rfloor^s = \sum_{i=0}^n\sum_{j=0}^{m-1} i^r\left((j+1)^s-j^s\right)\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right].
\]</div>
<p>本题的另一个特点是，<span class="arithmatex">\(g\)</span> 和 <span class="arithmatex">\(h\)</span> 在递归计算时，会相互交错。因此，需要将 <span class="arithmatex">\((f,g,h)\)</span> 作为三元组同时递归。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-1.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<details class="example" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P5172">[清华集训 2014] Sum</a></summary>
<p>多组询问。给定正整数 <span class="arithmatex">\(n\)</span> 和 <span class="arithmatex">\(r\)</span>，求</p>
<div class="arithmatex">\[
\sum_{d=1}^n(-1)^{\lfloor d\sqrt{r}\rfloor}.
\]</div>
</details>
<details class="note">
<summary>解答一</summary>
<p>如果 <span class="arithmatex">\(r\)</span> 是完全平方数，那么当 <span class="arithmatex">\(\sqrt{r}\)</span> 为偶数时，和式为 <span class="arithmatex">\(n\)</span>；否则，和式依据 <span class="arithmatex">\(n\)</span> 奇偶性不同，在 <span class="arithmatex">\(0\)</span> 和 <span class="arithmatex">\(-1\)</span> 之间交替变化。下面考虑 <span class="arithmatex">\(r\)</span> 不是完全平方数的情形。</p>
<p>为了应用类欧几里得算法，首先将求和式转化为熟悉的形式：</p>
<div class="arithmatex">\[
\begin{aligned}
\sum_{d=1}^n(-1)^{\lfloor d\sqrt{r}\rfloor} &amp;= \sum_{d=1}^n\left(1 - 2(\lfloor d\sqrt{r}\rfloor\bmod 2)\right)\\
&amp;= n - 2\sum_{d=1}^n\left(\lfloor d\sqrt{r}\rfloor - 2\left\lfloor\dfrac{\lfloor d\sqrt{r}\rfloor}{2}\right\rfloor\right) \\
&amp;= n - 2\sum_{d=1}^n\lfloor d\sqrt{r}\rfloor + 4 \sum_{d=1}^n\left\lfloor\dfrac{d\sqrt{r}}{2}\right\rfloor\\
&amp;= n - 2f(n,1,0,1) + 4f(n,1,0,2)
\end{aligned}
\]</div>
<p>其中的函数 <span class="arithmatex">\(f\)</span> 具有形式</p>
<div class="arithmatex">\[
f(a,b,c,n) = \sum_{i=1}^n\left\lfloor\dfrac{a\sqrt{r}+b}{c}i\right\rfloor.
\]</div>
<p>与正文中的算法不同的是，此处的斜率不再是有理数。设斜率</p>
<div class="arithmatex">\[
k = \dfrac{a\sqrt{r}+b}{c}.
\]</div>
<p>同样分为两种情形讨论。如果 <span class="arithmatex">\(k\ge 1\)</span>，那么</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n) &amp;= \sum_{i=1}^n \lfloor ki\rfloor = \sum_{i=1}^n \lfloor(k-\lfloor k\rfloor)i\rfloor + \lfloor k\rfloor \sum_{i=1}^ni\\
&amp;= \lfloor k\rfloor\dfrac{n(n+1)}{2} + f(a,b-c\lfloor k\rfloor,c,n).
\end{aligned}
\]</div>
<p>问题转化为斜率小于一的情形。如果 <span class="arithmatex">\(k&lt;1\)</span>，那么设 <span class="arithmatex">\(m=\lfloor nk\rfloor\)</span>，有</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n) &amp;= \sum_{i=1}^n \lfloor ki\rfloor = \sum_{i=1}^n\sum_{j=1}^m[j\le\lfloor ki\rfloor]\\
&amp;= \sum_{j=1}^m\sum_{i=1}^n[i&gt;\lfloor k^{-1}j\rfloor] = nm - \sum_{j=1}^m\sum_{i=1}^n[i\le\lfloor k^{-1}j\rfloor].
\end{aligned}
\]</div>
<p>此处的推导中，交换 <span class="arithmatex">\(i\)</span> 和 <span class="arithmatex">\(j\)</span> 的条件比正文中的情形更为简单，是因为直线 <span class="arithmatex">\(y=kx\)</span> 上没有除了原点之外的格点。关键在于交换后的求和式写成 <span class="arithmatex">\(f(a,b,c,n)\)</span> 的形式，这相当于要求 <span class="arithmatex">\(a',b',c'\)</span> 满足</p>
<div class="arithmatex">\[
k^{-1} = \dfrac{a'\sqrt{r}+b'}{c'}.
\]</div>
<p>这并不困难，只需要将分母有理化，就能得到</p>
<div class="arithmatex">\[
k^{-1} = \dfrac{c}{a\sqrt{r}+b} = \dfrac{ca\sqrt{r}-cb}{a^2r-b^2}.
\]</div>
<p>因此，有</p>
<div class="arithmatex">\[
a'=ca,~b'=-cb,~c'=a^2r-b^2.
\]</div>
<p>这说明</p>
<div class="arithmatex">\[
f(a,b,c,n) = nm - f(ca,-cb,a^2r-b^2,m).
\]</div>
<p>为了避免整数溢出，需要每次都将 <span class="arithmatex">\(a,b,c\)</span> 同除以它们的最大公约数。因为这个计算过程和计算 <span class="arithmatex">\(k\)</span> 的连分数的过程完全一致，所以根据 <a href="../continued-fraction/#二次无理数">连分数理论</a>，只要保证 <span class="arithmatex">\(\gcd(a,b,c)=1\)</span>，它们在计算过程中必然在整型范围内。另外，尽管 <span class="arithmatex">\((a,b,c,n)\)</span> 不会溢出，但是在该题数据范围下，<span class="arithmatex">\(f(a,b,c,n)\)</span> 可能会超过 <span class="arithmatex">\(64\)</span> 位整数的范围，自然溢出即可，无需额外处理，最后结果一定在 <span class="arithmatex">\([-n,n]\)</span> 之间。</p>
<p>尽管斜率不会变为零，算法的复杂度仍然是 <span class="arithmatex">\(O(\log n)\)</span> 的，这一点从前文关于算法复杂度的论证容易看出。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-2.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<details class="example" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P5179">Fraction</a></summary>
<p>给定正整数 <span class="arithmatex">\(a,b,c,d\)</span>，求所有满足 <span class="arithmatex">\(a/b&lt;p/q&lt;c/d\)</span> 的最简分数 <span class="arithmatex">\(p/q\)</span> 中 <span class="arithmatex">\((q,p)\)</span> 的字典序最小的那个。</p>
</details>
<details class="note">
<summary>解答</summary>
<p>这道题目也是 <a href="../stern-brocot/">Stern–Brocot 树</a> 的经典应用，相关题解可以在 <a href="../continued-fraction/#连分数的树">此处</a> 找到。因为它只依赖于分数的递归结构，所以它同样可以利用类似欧几里得算法的方法求解，故而也可以视作类欧几里得算法的一个应用。</p>
<p>如果 <span class="arithmatex">\(a/b\)</span> 和 <span class="arithmatex">\(c/d\)</span> 之间（不含端点）存在至少一个自然数，可以直接取 <span class="arithmatex">\((q,p)=(1,\lfloor a/b\rfloor+1)\)</span>。否则，必然有</p>
<div class="arithmatex">\[
\left\lfloor\dfrac{a}{b}\right\rfloor \le \dfrac{a}{b} &lt;\dfrac{p}{q} &lt;\dfrac{c}{d}\le\left\lfloor\dfrac{a}{b}\right\rfloor+1.
\]</div>
<p>从这个不等式中可以看出，<span class="arithmatex">\(p/q\)</span> 的整数部分可以确定为 <span class="arithmatex">\(\lfloor a/b\rfloor\)</span>，直接消去该整数部分，然后整体取倒数，用于确定它的小数部分。这正是确定 <span class="arithmatex">\(p/q\)</span> 的连分数的 <a href="../continued-fraction/#连分数表示的求法">基本方法</a>。若最终的答案是 <span class="arithmatex">\(p/q\)</span>，那么算法的时间复杂度为 <span class="arithmatex">\(O(\log\min\{p,q\})\)</span>。</p>
<p>此处，有一个细节问题，即取倒数之后得到的字典序最小的分数，是否是取倒数之前的字典序最小的分数。换句话说，满足 <span class="arithmatex">\(a/b&lt;p/q&lt;c/d\)</span> 的分数 <span class="arithmatex">\(p/q\)</span> 中，字典序 <span class="arithmatex">\((q,p)\)</span> 最小的，是否也是字典序 <span class="arithmatex">\((p,q)\)</span> 最小的。假设不然，设 <span class="arithmatex">\(p/q\)</span> 是字典序 <span class="arithmatex">\((q,p)\)</span> 最小的，但是 <span class="arithmatex">\(r/s\neq p/q\)</span> 是字典序 <span class="arithmatex">\((r,s)\)</span> 最小的。这必然有 <span class="arithmatex">\(r&lt;p\)</span> 且 <span class="arithmatex">\(q&lt;s\)</span>。但是，这说明</p>
<div class="arithmatex">\[
\dfrac{a}{b} &lt; \dfrac{r}{s} &lt; \dfrac{r}{q} &lt; \dfrac{p}{q} &lt; \dfrac{c}{d}.
\]</div>
<p>因此，<span class="arithmatex">\(r/q\)</span> 无论按照哪个字典序怎样都是严格更小于当前解的。这与所设条件矛盾。因此，上述算法是正确的。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-3.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h2 id="万能欧几里得算法">万能欧几里得算法<a class="headerlink" href="#万能欧几里得算法" title="Permanent link"></a></h2>
<p>上一节讨论的类欧几里得算法推导通常较为繁琐，而且能够解决的和式主要是可以转化为直线下（带权）整点计数问题的和式。本节讨论一种更为一般的方法，它进一步抽象了上述过程，从而可以解决更多的问题。因此，这一方法也称为万能欧几里得算法。它同样利用了分数的递归结构求解问题，但是与类欧几里得算法约化问题的思路稍有不同。</p>
<p>仍然考虑最经典的求和问题：</p>
<div class="arithmatex">\[
f(a,b,c,n)=\sum_{i=1}^n\left\lfloor \frac{ai+b}{c} \right\rfloor,
\]</div>
<p>其中，<span class="arithmatex">\(a,b,c,n\)</span> 都是正整数。</p>
<h3 id="问题转化">问题转化<a class="headerlink" href="#问题转化" title="Permanent link"></a></h3>
<p>设参数为 <span class="arithmatex">\((a,b,c,n)\)</span> 的线段为</p>
<div class="arithmatex">\[
y = \frac{ax+b}{c},~0&lt; x\le n.
\]</div>
<p>对于这条线段，可以按照如下方法定义一个由 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span> 组成的字符串 <span class="arithmatex">\(S\)</span>，也称为 <strong>操作序列</strong>：</p>
<ul>
<li>字符串恰有 <span class="arithmatex">\(n\)</span> 个 <span class="arithmatex">\(R\)</span> 和 <span class="arithmatex">\(m=\lfloor(an+b)/c\rfloor\)</span> 个 <span class="arithmatex">\(U\)</span> 组成；</li>
<li>第 <span class="arithmatex">\(i\)</span> 个 <span class="arithmatex">\(R\)</span> 前方的 <span class="arithmatex">\(U\)</span> 的数量恰等于 <span class="arithmatex">\(\lfloor(ai+b)/c\rfloor\)</span>，其中，<span class="arithmatex">\(i=1,\cdots,n\)</span>。</li>
</ul>
<p>从几何直观上看，这大致相当于从原点开始，每向右穿过一次竖向的网格线，就写下一个 <span class="arithmatex">\(R\)</span>，每向上穿过一次横向的网格线，就写下一个 <span class="arithmatex">\(U\)</span>。如下图所示：</p>
<p><img alt="" src="../images/euclidean-universal.svg" /></p>
<p>当然，这样的定义还需要考量一系列特殊情形：</p>
<ul>
<li>经过整点（即同时上穿和右穿）时，需要先写 <span class="arithmatex">\(U\)</span> 再写 <span class="arithmatex">\(R\)</span>；</li>
<li>字符串开始时，除了在 <span class="arithmatex">\((0,1]\)</span> 区间内上穿网格线的次数外，还需要格外补充 <span class="arithmatex">\(\lfloor b/c\rfloor\)</span> 个 <span class="arithmatex">\(U\)</span>；</li>
<li>字符串结束时，不能有格外的 <span class="arithmatex">\(U\)</span>。</li>
</ul>
<p>如果对于几何直观的描述有任何不明晰的地方，可以参考上述代数方法的定义辅助理解。几何直观的描述，有助于理解下文的算法过程。</p>
<p>万能欧几里得算法的基本思路，就是将操作序列中的 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span> 都视作某个 <a href="../../algebra/basic/#群">幺半群</a> 内的元素，将整个操作序列视为幺半群内元素的乘积，而问题最终的答案与这个乘积有关。</p>
<p>比如，本题中，可以定义状态向量 <span class="arithmatex">\(v = (1,y,\sum y)\)</span>，表示自原点开始，经历了若干次上穿和右穿网格线后，当前的状态。其中，第一个分量是常数，第二个分量是纵坐标 <span class="arithmatex">\(y\)</span>，第三个分量是要求的和式。起始时，有 <span class="arithmatex">\(v=(1,0,0)\)</span>。每向上穿过一次网格线，纵坐标就累加一，即相当于将状态向量右乘以矩阵</p>
<div class="arithmatex">\[
U = \begin{pmatrix}1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix}.
\]</div>
<p>每向右穿过一次网格线，和式就累加一次纵坐标，即相当于将状态向量右乘以矩阵</p>
<div class="arithmatex">\[
R = \begin{pmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1\end{pmatrix}.
\]</div>
<p>因此，最终的状态就是乘积 <span class="arithmatex">\((1,0,0)S\)</span>，其中，<span class="arithmatex">\(S\)</span> 理解为上述矩阵的乘积。所求的答案，就是最终状态的第三个分量。</p>
<p>除了将幺半群中的元素定义为矩阵以外，还可以将它们定义为一段操作序列对于最终结果的贡献，然后将操作的乘积定义为两段操作序列的贡献的合并。</p>
<p>本题中，可以定义每段操作序列的贡献为 <span class="arithmatex">\((x,y,\sum y)\)</span>。为了严谨地解释这些记号，可以将这些分量都看作是操作序列的函数，也就是说，对于操作序列 <span class="arithmatex">\(S\)</span>，它的贡献可以写作 <span class="arithmatex">\((x(S),y(S),(\sum y)(S))\)</span>。其中，<span class="arithmatex">\(x(S)\)</span> 和 <span class="arithmatex">\(y(S)\)</span> 分别对应着操作序列 <span class="arithmatex">\(S\)</span> 中 <span class="arithmatex">\(R\)</span> 和 <span class="arithmatex">\(U\)</span> 的数量，也就是该线段右穿和上穿网格线的次数。最后一项中的求和符号，一般地，有如下定义：对于操作序列上的函数 <span class="arithmatex">\(f(S)\)</span>，可以定义 <span class="arithmatex">\((\sum f)(S)\)</span>，或记作 <span class="arithmatex">\(\sum_S f\)</span>，为下面的表达式：</p>
<div class="arithmatex">\[
\sum_S f := \sum\{f(S_{[1,r]}):S_r=R\}.
\]</div>
<p>其中，<span class="arithmatex">\(S_r\)</span> 是 <span class="arithmatex">\(S\)</span> 中的第 <span class="arithmatex">\(r\)</span> 个字符，<span class="arithmatex">\(S_{[1,r]}\)</span> 是 <span class="arithmatex">\(S\)</span> 中前 <span class="arithmatex">\(r\)</span> 个字符组成的前缀。也就是说，这个求和记号，可以看作是对于操作序列 <span class="arithmatex">\(S\)</span> 中所有以 <span class="arithmatex">\(R\)</span> 结尾的前缀进行的求和。比如说，有</p>
<div class="arithmatex">\[
\sum_S 1 = x,~ \sum_S x = \dfrac{1}{2}x(x+1).
\]</div>
<p>再比如说，<span class="arithmatex">\(\sum y\)</span> 就是操作序列中，每次右穿网格线时，之前上穿网格线的次数的累加。对于整段操作序列来说，<span class="arithmatex">\(y\)</span> 在所有以 <span class="arithmatex">\(R\)</span> 结尾的前缀处的值，就是在 <span class="arithmatex">\(i=1,\cdots,n\)</span> 处的所有 <span class="arithmatex">\(\lfloor(ai+b)/c\rfloor\)</span> 的值。因此，对于整段操作序列计算的 <span class="arithmatex">\(\sum y\)</span>，就是本题最终要求的量。</p>
<p>初始时，有 <span class="arithmatex">\(U=(0,1,0)\)</span>，<span class="arithmatex">\(R=(1,0,0)\)</span>。进一步，可以将两个元素 <span class="arithmatex">\((x_1,y_1,s_1)\)</span> 和 <span class="arithmatex">\((x_2,y_2,s_2)\)</span> 的乘积定义为</p>
<div class="arithmatex">\[
(x_1,y_1,s_1)\cdot (x_2,y_2,s_2) = (x_1+x_2,y_1+y_2,s_1+s_2+x_2y_1).
\]</div>
<p>其中，最后一项贡献合并的结果可以通过如下计算得到：</p>
<div class="arithmatex">\[
\sum_{S_1+S_2}y = \sum_{S_1}y + \sum_{S_2}(y+y_1) = \sum_{S_1}y + \sum_{S_2}y + y_1\sum_{S_2}1 = s_1+s_2+x_2y_1.
\]</div>
<p>容易验证，这个乘法运算满足结合律，且幺元为 <span class="arithmatex">\((0,0,0)\)</span>，所以这些元素在该乘法运算下构成幺半群。所求的答案，就是乘积的第三个分量。</p>
<p>这两种方法都可以得到正确的结果。但是，因为保留了较多的冗余信息，矩阵运算的常数较大，所以第二种方法在处理实际问题时更为实用。</p>
<h3 id="算法过程">算法过程<a class="headerlink" href="#算法过程" title="Permanent link"></a></h3>
<p>与类欧几里得算法整体约化不同，万能欧几里得算法约化问题的手段是将这些操作分批次地合并。记字符串对应的操作的乘积为</p>
<div class="arithmatex">\[
F(a,b,c,n,U,R).
\]</div>
<p>约化过程具体如下：</p>
<ul>
<li>
<p>当 <span class="arithmatex">\(b\ge c\)</span> 时，操作序列的开始有 <span class="arithmatex">\(\lfloor b/c\rfloor\)</span> 个 <span class="arithmatex">\(U\)</span>，直接计算它们的乘积，并将这些 <span class="arithmatex">\(U\)</span> 从操作序列中移除。此时，第 <span class="arithmatex">\(i\)</span> 个 <span class="arithmatex">\(R\)</span> 前方的 <span class="arithmatex">\(U\)</span> 的数量等于</p>
<div class="arithmatex">\[
\left\lfloor\dfrac{ai+b}{c}\right\rfloor - \left\lfloor\dfrac{b}{c}\right\rfloor = \left\lfloor\dfrac{ai+(b\bmod c)}{c}\right\rfloor.
\]</div>
<p>因此，这相当于将线段参数由 <span class="arithmatex">\((a,b,c,n)\)</span> 变为 <span class="arithmatex">\((a,b\bmod c,c,n)\)</span>。所以，对于这种情形，有</p>
<div class="arithmatex">\[
F(a,b,c,n,U,R) = U^{\lfloor b/c\rfloor}F(a,b\bmod c,c,n,U,R).
\]</div>
</li>
<li>
<p>当 <span class="arithmatex">\(a\ge c\)</span> 时，操作序列中每个 <span class="arithmatex">\(R\)</span> 的前方都至少有 <span class="arithmatex">\(\lfloor a/c\rfloor\)</span> 个 <span class="arithmatex">\(U\)</span>，可以将它们合并到 <span class="arithmatex">\(R\)</span> 上。也就是说，可以用 <span class="arithmatex">\(U^{\lfloor a/c\rfloor}R\)</span> 替代 <span class="arithmatex">\(R\)</span>。合并后的字符串中，第 <span class="arithmatex">\(i\)</span> 个 <span class="arithmatex">\(R\)</span> 前方的 <span class="arithmatex">\(U\)</span> 的数量等于</p>
<div class="arithmatex">\[
\left\lfloor\dfrac{ai+b}{c}\right\rfloor - \left\lfloor\dfrac{a}{c}\right\rfloor i = \left\lfloor\dfrac{(a\bmod c)i+b}{c}\right\rfloor.
\]</div>
<p>因此，这相当于将线段参数由 <span class="arithmatex">\((a,b,c,n)\)</span> 变为 <span class="arithmatex">\((a\bmod c,b,c,n)\)</span>。所以，对于这种情形，有</p>
<div class="arithmatex">\[
F(a,b,c,n,U,R) = F(a\bmod c,b,c,n,U,U^{\lfloor a/c\rfloor}R).
\]</div>
</li>
<li>
<p>对于剩下的情形，需要翻转横纵坐标，这基本是在交换 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span>，只是翻转后线段的参数需要仔细计算。结合操作序列的定义可知，需要确定系数 <span class="arithmatex">\((a',b',c',n')\)</span> 使得变换前的操作序列中，第 <span class="arithmatex">\(j\)</span> 个 <span class="arithmatex">\(U\)</span> 前方的 <span class="arithmatex">\(R\)</span> 的数量恰为 <span class="arithmatex">\(\lfloor(a'j+b')/c'\rfloor\)</span> 且总共有 <span class="arithmatex">\(n'\)</span> 个 <span class="arithmatex">\(U\)</span>。根据定义可知，</p>
<div class="arithmatex">\[
n'=\left\lfloor\dfrac{an+b}{c}\right\rfloor = m,
\]</div>
<p>而第 <span class="arithmatex">\(j\)</span> 个 <span class="arithmatex">\(U\)</span> 前方的 <span class="arithmatex">\(R\)</span> 的数量，就等于最大的 <span class="arithmatex">\(i\)</span> 使得</p>
<div class="arithmatex">\[
\begin{aligned}
\left\lfloor\dfrac{ai+b}{c}\right\rfloor &lt; j 
&amp;\iff \dfrac{ai+b}{c} &lt; j \iff i &lt; \dfrac{cj-b}{a} \\
&amp;\iff i &lt; \left\lceil\dfrac{cj-b}{a}\right\rceil = \left\lfloor\dfrac{cj-b - 1}{a}\right\rfloor + 1.
\end{aligned}
\]</div>
<p>因此，<span class="arithmatex">\(i = \lfloor(cj-b-1)/a\rfloor\)</span>。这一推导过程与前文类欧几里得算法的推导类似，同样利用了上下取整函数的性质。</p>
<p>有两处细节需要处理：</p>
<ul>
<li>截距项 <span class="arithmatex">\(-(b+1)/a\)</span> 为负数。注意到，如果将线段向左平移一个单位，就可以让截距项恢复为非负数，因为总有 <span class="arithmatex">\((c-b-1)/a\ge 0\)</span>。因此，可以将交换前的第一段 <span class="arithmatex">\(R^{\lfloor(c-b-1)/a\rfloor}U\)</span> 提取出来，只交换剩余操作序列中的 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span>；</li>
<li>交换 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span> 后，结尾存在多余的 <span class="arithmatex">\(U\)</span>。因此，交换 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span> 之前，需要首先将最后一段 <span class="arithmatex">\(R\)</span> 提取出来，只交换剩余操作序列中的 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span>。这一段 <span class="arithmatex">\(R\)</span> 的数量为 <span class="arithmatex">\(n-\lfloor(cm-b-1)/a\rfloor\)</span>。</li>
</ul>
<p>去掉头尾若干个字符后，第 <span class="arithmatex">\(j\)</span> 个 <span class="arithmatex">\(U\)</span> 前方的 <span class="arithmatex">\(R\)</span> 的数量变为：</p>
<div class="arithmatex">\[
\left\lfloor\dfrac{c(j+1)-b-1}{a}\right\rfloor - \left\lfloor\dfrac{c-b-1}{a}\right\rfloor = \left\lfloor\dfrac{cj+(c-b-1)\bmod a}{a}\right\rfloor.
\]</div>
<p>回忆起，交换前的序列中 <span class="arithmatex">\(U\)</span> 的数量为 <span class="arithmatex">\(m = \lfloor(an+b)/c\rfloor\)</span>。而上述左移一个单位的操作，要求保证交换前至少存在一个 <span class="arithmatex">\(U\)</span>，也就是 <span class="arithmatex">\(m&gt;0\)</span>。利用这一条件，可以分为两种情形：</p>
<ul>
<li>
<p>对于 <span class="arithmatex">\(m&gt;0\)</span> 的情形，处理了上面的两点后，交换完 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span> 的操作序列就是对应着参数为 <span class="arithmatex">\((c,(c-b-1)\bmod a,a,m-1)\)</span> 的线段的合法序列。所以，有</p>
<div class="arithmatex">\[
F(a,b,c,n,U,R) = R^{\lfloor(c-b-1)/a\rfloor}UF(c,(c-b-1)\bmod a,a,m-1,R,U)R^{n-\lfloor(cm-b-1)/a\rfloor}.
\]</div>
</li>
<li>
<p>特别地，对于 <span class="arithmatex">\(m=0\)</span> 的情形，交换前的操作序列中只包含 <span class="arithmatex">\(n\)</span> 个 <span class="arithmatex">\(R\)</span>，无需交换，可以直接返回：</p>
<div class="arithmatex">\[
F(a,b,c,n,U,R) = R^n.
\]</div>
<p>与类欧几里得算法不同，万能欧几里得算法的这一特殊情形需要单独处理，否则会因涉及负幂次而无法正确计算。</p>
</li>
</ul>
</li>
</ul>
<p>利用这些讨论，就可以将问题递归地解决。</p>
<p>假设幺半群内元素单次相乘的时间复杂度是 <span class="arithmatex">\(O(1)\)</span> 的。那么，如果计算过程中这些元素的幂次计算都使用 <a href="../../binary-exponentiation/">快速幂</a> 进行，最终的算法复杂度就是 <span class="arithmatex">\(O(\log\max\{a,c\}+\log(b/c))\)</span> 的<sup id="fnref:complexity"><a class="footnote-ref" href="#fn:complexity">1</a></sup>。</p>
<details class="note">
<summary>对复杂度的解释</summary>
<p>对比（类）欧几里得算法，万能欧几里得算法只是多了求快速幂的步骤。其余的计算过程的复杂度和类欧几里得算法相仿，已经说明是 <span class="arithmatex">\(O(\log\min\{a,c,n\})\)</span> 的。现在，需要计算这些快速幂的总复杂度。</p>
<p>除了第一轮迭代，都有 <span class="arithmatex">\(b&lt;c\)</span>，因此这些迭代每轮都涉及三次快速幂的计算，总的复杂度是：</p>
<div class="arithmatex">\[
O\left(\log\left\lfloor\dfrac{a}{c}\right\rfloor+\log\left\lfloor\dfrac{c-b_1-1}{a_1}\right\rfloor+\log\left(n-\left\lfloor\dfrac{cm-b_1-1}{a_1}\right\rfloor\right)\right),
\]</div>
<p>其中，<span class="arithmatex">\(a_1=a\bmod c\)</span>，<span class="arithmatex">\(b_1=b\bmod c\)</span> 且 <span class="arithmatex">\(m=\lfloor(a_1n+b_1)/c\rfloor\)</span>。后面两项，分别有估计：</p>
<div class="arithmatex">\[
\begin{aligned}
\dfrac{c-b_1-1}{a_1} &amp;\le \dfrac{c}{a_1},\\
n-\left\lfloor\dfrac{cm-b_1-1}{a_1}\right\rfloor &amp;\le n - \dfrac{cm-b_1-1}{a_1} + 1 \\
&amp;\le n - \dfrac{c((a_1n+b_1)/c-1)-b_1-1}{a_1} +1 \\
&amp;= \dfrac{c+1}{a_1}+1.
\end{aligned}
\]</div>
<p>因此，这两项的复杂度都是 <span class="arithmatex">\(O(\log(c/a_1))\)</span> 的。</p>
<p>每一轮迭代中，线段的参数都由 <span class="arithmatex">\((a,\cdot,c,\cdot)\)</span> 变换为 <span class="arithmatex">\((c,\cdot,a\bmod c,\cdot)\)</span>，且该轮总的时间复杂度为</p>
<div class="arithmatex">\[
O\left(\log\dfrac{a}{c}+\log\dfrac{c}{a\bmod c}\right).
\]</div>
<p>对于全部递归的轮次，这些项可以裂项相消，因此，最后总和复杂度就是 <span class="arithmatex">\(O(\log a+\log c)=O(\log\max\{a,c\})\)</span> 的。</p>
<p>最后，再加上第一轮迭代中快速幂 <span class="arithmatex">\(U^{\lfloor b/c\rfloor}\)</span> 的复杂度 <span class="arithmatex">\(O(\log(b/c))\)</span>，就得到总的复杂度为 <span class="arithmatex">\(O(\log\max\{a,c\}+\log(b/c))\)</span>。</p>
</details>
<p>万能欧几里得算法的流程可以写成统一的模板，处理具体问题时只需要更改模板类型 <code>T</code> 的实现即可。</p>
<details class="example" open="open">
<summary>参考实现</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-4.cpp:euclidean&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<p>利用万能欧几里得算法可以得到模板题的实现如下：</p>
<details class="example">
<summary>模板题实现（<a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">Library Checker - Sum of Floor of Linear</a>）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-4.cpp:full-text&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h3 id="例题_1">例题<a class="headerlink" href="#例题_1" title="Permanent link"></a></h3>
<details class="example" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P5170">【模板】类欧几里得算法</a></summary>
<p>多组询问。给定正整数 <span class="arithmatex">\(a,b,c,n\)</span>，求</p>
<div class="arithmatex">\[
\begin{aligned}
f(a,b,c,n) &amp;= \sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor,\\
g(a,b,c,n) &amp;= \sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor,\\
h(a,b,c,n) &amp;= \sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2.
\end{aligned}
\]</div>
</details>
<details class="note">
<summary>解答二</summary>
<p>为了应用万能欧几里得算法的模板，首先将 <span class="arithmatex">\(i=0\)</span> 的项提出来，单独考虑。对于剩下的部分，可以看作是对参数为 <span class="arithmatex">\((a,b,c,n)\)</span> 的线段分别计算 <span class="arithmatex">\(\sum y,\sum xy,\sum y^2\)</span>。如正文所言，有两种将操作序列转换为幺半群元素的方式。</p>
<p><strong>矩阵运算</strong>：状态向量定义为 <span class="arithmatex">\((1,x,y,xy,y^2,\sum y,\sum xy,\sum y^2)\)</span>。初始状态为 <span class="arithmatex">\((1,0,0,0,0,0,0,0)\)</span>，两个操作分别为</p>
<div class="arithmatex">\[
U =
\begin{pmatrix}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 
\end{pmatrix},~
R = 
\begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 
\end{pmatrix}.
\]</div>
<p>最终答案为初始状态右乘这些操作矩阵的乘积得到的向量末尾三个分量。</p>
<p>这个做法的常数巨大，并不能通过本题，这里给出细节仅仅是为了辅助理解。</p>
<p><strong>贡献合并</strong>：一段操作序列的贡献定义为 <span class="arithmatex">\((x,y,\sum y,\sum xy,\sum y^2)\)</span>。两个操作分别为</p>
<div class="arithmatex">\[
U = (0,1,0,0,0),~ R = (1,0,0,0,0).
\]</div>
<p>贡献合并时，有</p>
<div class="arithmatex">\[
\begin{aligned}
\sum_{S_1+S_2} y 
&amp;= \sum_{S_1}y + \sum_{S_2}(y+y_1) = \sum_{S_1}y + \sum_{S_2}y + x_2y_1,\\
\sum_{S_1+S_2} xy
&amp;= \sum_{S_1}xy + \sum_{S_2}(x+x_1)(y+y_1) \\
&amp;= \sum_{S_1}xy + \sum_{S_2}xy + x_1\sum_{S_2}y + y_1\sum_{S_2}x + x_1y_1\sum_{S_2}1\\
&amp;= \sum_{S_1}xy + \sum_{S_2}xy + x_1\sum_{S_2}y + \dfrac{1}{2}x_2(x_2+1)y_1 + x_1x_2y_1,\\
\sum_{S_1+S_2}y^2
&amp;= \sum_{S_1}y^2 + \sum_{S_2}(y+y_1)^2 \\
&amp;= \sum_{S_1}y^2 + \sum_{S_2}y^2 + 2y_1\sum_{S_2}y + y_1^2\sum_{S_2}1  \\
&amp;= \sum_{S_1}y^2 + \sum_{S_2}y^2 + 2y_1\sum_{S_2}y + x_2y_1^2.
\end{aligned}
\]</div>
<p>这说明，应该将操作的乘法定义为</p>
<div class="arithmatex">\[
\begin{aligned}
&amp;(x_1,y_1,s_1,t_1,u_1)\cdot(x_2,y_2,s_2,t_2,u_2)\\
&amp;= (x_1+x_2,y_1+y_2,s_1+s_2+x_2y_1,\\
&amp;\qquad t_1+t_2+x_1s_2+(1/2)x_2(x_2+1)y_1+x_1x_2y_1,\\
&amp;\qquad u_1+u_2+2y_1s_2+x_2y_1^2).
\end{aligned}
\]</div>
<p>虽然直接验证较为繁琐，但是上述定义的贡献向量在该乘法下的确构成幺半群，单位元为 <span class="arithmatex">\((0,0,0,0,0)\)</span>。</p>
<p>对于一般的情形，有</p>
<div class="arithmatex">\[
\begin{aligned}
\sum_{S_1+S_2}x^ry^s &amp;= \sum_{S_1}x^ry^s + \sum_{S_2}(x+x_1)^r(y+y_1)^s \\
&amp;= \sum_{S_1}x^ry^s + \sum_{i=0}^r\sum_{j=0}^s\binom{r}{i}\binom{s}{j}x_1^{r-i}y_1^{s-j}\sum_{S_2}x^iy^j.
\end{aligned}
\]</div>
<p>只要维护好所有更低幂次的贡献，就可以计算一般情形的和式。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-5.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<details class="example" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P5172">[清华集训 2014] Sum</a></summary>
<p>多组询问。给定正整数 <span class="arithmatex">\(n\)</span> 和 <span class="arithmatex">\(r\)</span>，求</p>
<div class="arithmatex">\[
\sum_{d=1}^n(-1)^{\lfloor d\sqrt{r}\rfloor}.
\]</div>
</details>
<details class="note">
<summary>解答二</summary>
<p>首先，单独处理 <span class="arithmatex">\(r\)</span> 为完全平方数的情形，与前文完全一致，从略。此处，仅考虑 <span class="arithmatex">\(r\)</span> 不是完全平方数的情形。</p>
<p>本题应用万能欧几里得算法的方式有很多。比如说，可以为每个操作定义一个线性变换：</p>
<div class="arithmatex">\[
U(x) = -x,~ R(x) = x + 1.
\]</div>
<p>操作的乘法定义为线性变换的复合。那么，最终的答案就是操作序列对应的变换的复合得到的函数在 <span class="arithmatex">\(x=0\)</span> 处的值。</p>
<p>还可以为每段操作序列定义它的贡献。贡献可以定义为 <span class="arithmatex">\(((-1)^y,\sum(-1)^y)\)</span>。那么，两个操作分别取</p>
<div class="arithmatex">\[
U = (0,-1),~ R = (1,1).
\]</div>
<p>贡献的合并定义为</p>
<div class="arithmatex">\[
(u_1,v_1)\cdot(u_2,v_2) = (u_1u_2,v_1+u_1v_2).
\]</div>
<p>容易验证，在该乘法下，所有操作构成了幺半群，且单位元为 <span class="arithmatex">\((0,1)\)</span>。最终的答案就是所有元素乘积的第二个分量。</p>
<p>这两种方法是一致的，因为如果将线性变换写作 <span class="arithmatex">\(f(x)=u+vx\)</span>，那么线性变换的复合对应的系数的变化，恰恰就是上述操作的乘法。也就是说，这两个幺半群是同构的。</p>
<p>本题中，线段的参数为 <span class="arithmatex">\((k,n)\)</span>，其中，<span class="arithmatex">\(k\in\mathbf R\)</span> 为直线的斜率。设操作序列对应的乘积为 <span class="arithmatex">\(F(k,n,U,R)\)</span>。那么，有如下递归算法：</p>
<ul>
<li>
<p>如果 <span class="arithmatex">\(k\ge 1\)</span>，那么操作序列中每个 <span class="arithmatex">\(R\)</span> 前方都有至少 <span class="arithmatex">\(\lfloor k\rfloor\)</span> 个 <span class="arithmatex">\(U\)</span>，所以，有</p>
<div class="arithmatex">\[
F(k,n,U,R) = F(k-\lfloor k\rfloor,n,U,U^{\lfloor k\rfloor} R).
\]</div>
</li>
<li>
<p>如果 <span class="arithmatex">\(k&lt;1\)</span>，那么交换操作序列中的 <span class="arithmatex">\(U\)</span> 和 <span class="arithmatex">\(R\)</span>，并舍去末尾的 <span class="arithmatex">\(U\)</span>（即交换前的 <span class="arithmatex">\(R\)</span>），所以，有</p>
<div class="arithmatex">\[
F(k,n,U,R) = F(k^{-1},m,R,U)R^{n-\lfloor k^{-1}m\rfloor}.
\]</div>
</li>
</ul>
<p>算法中，<span class="arithmatex">\(k\)</span> 的迭代过程其实就是在求 <span class="arithmatex">\(\sqrt{r}\)</span> 的连分数展开。为此，可以应用 <a href="../pell-equation/#pqa-算法">PQa 算法</a>。求连分数的过程和万能欧几里得算法迭代的过程可以同时进行。</p>
<p>和类欧几里得算法的情形一致，算法的复杂度仍然是 <span class="arithmatex">\(O(\log n)\)</span> 的。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">-</span><span class="mi">-8</span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;docs/math/code/euclidean/euclidean-6.cpp&quot;</span>
</code></pre></div></td></tr></table></div>
</details>
<h2 id="习题">习题<a class="headerlink" href="#习题" title="Permanent link"></a></h2>
<p>模板题：</p>
<ul>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">Library Checker - Sum of Floor of Linear</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5170">Luogu P5170【模板】类欧几里得算法</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5171">Luogu P5171 Earthquake</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5172">Luogu P5172 [清华集训 2014] Sum</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4132">Luogu P4132 [BJOI2012] 算不出的等式</a></li>
<li><a href="https://loj.ac/p/138">LOJ 138. 类欧几里得算法</a></li>
<li><a href="https://loj.ac/p/6440">LOJ 6440. 万能欧几里得</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5179">Luogu P5179 Fraction</a></li>
<li><a href="https://codeforces.com/problemset/problem/1182/F">Codeforces 1182 F. Maximum Sine</a></li>
</ul>
<p>应用题：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4433">Luogu P4433 [COCI 2009/2010 #1] ALADIN</a></li>
<li><a href="https://atcoder.jp/contests/abc372/tasks/abc372_g">AtCoder Beginner Contest 372 G - Ax + By &lt; C</a></li>
<li><a href="https://atcoder.jp/contests/abc313/tasks/abc313_g">AtCoder Beginner Contest 313 G - Redistribution of Piles</a></li>
<li><a href="https://atcoder.jp/contests/abc283/tasks/abc283_h">AtCoder Beginner Contest 283 Ex - Popcount Sum</a></li>
<li><a href="https://codeforces.com/problemset/problem/1098/E">Codeforces 1098 E. Fedya the Potter</a></li>
<li><a href="https://codeforces.com/problemset/problem/868/G">Codeforces 868 G. El Toll Caves</a></li>
</ul>
<h2 id="参考资料与注释">参考资料与注释<a class="headerlink" href="#参考资料与注释" title="Permanent link"></a></h2>
<div class="footnote">
<hr />
<ol>
<li id="fn:complexity">
<p>通常考虑的问题中，<span class="arithmatex">\(b\)</span> 都与 <span class="arithmatex">\(a\)</span> 同阶，<span class="arithmatex">\(O(\log(b/c))\)</span> 这一项可以忽略。而且，如果在调用万能欧几里得算法前，首先进行了一轮类欧几里得算法的取模，消除 <span class="arithmatex">\(b\)</span> 的影响，这一项的快速幂的复杂度是可以规避的。这其实是因为通常的问题中，<span class="arithmatex">\(U\)</span> 的初始形式较为特殊，它的幂次有着更简单的形式，不需要通过快速幂计算。比如正文的例子中，<span class="arithmatex">\(U^{\lfloor b/a\rfloor}\)</span> 的结果，就是将 <span class="arithmatex">\(U\)</span> 中不在对角线上的那个 <span class="arithmatex">\(1\)</span> 替换成 <span class="arithmatex">\(\lfloor b/a\rfloor\)</span>，而无需用快速幂计算。&#160;<a class="footnote-backref" href="#fnref:complexity" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../../_static/js/math-csr.js?math-csr"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>